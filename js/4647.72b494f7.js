(self["webpackChunkweb_tool_vue"]=self["webpackChunkweb_tool_vue"]||[]).push([[4647],{44647:function(e,t,n){"use strict";n.r(t),n.d(t,{default:function(){return u7}});var r={};n.r(r),n.d(r,{arraysEqual:function(){return Te},arraysEqualWithNull:function(){return Se},assert:function(){return we},assertNonNegativeIntegerDimensions:function(){return nt},assertNonNull:function(){return ke},assertShapesMatch:function(){return ve},bytesFromStringArray:function(){return Ve},bytesPerElement:function(){return We},checkConversionForErrors:function(){return ze},clamp:function(){return fe},computeStrides:function(){return Xe},convertBackendValuesAndArrayBuffer:function(){return Ze},createScalarValue:function(){return ga},createShuffledIndices:function(){return Re},decodeString:function(){return ka},distSquared:function(){return xe},encodeString:function(){return va},fetch:function(){return wa},fingerPrint64:function(){return ma},flatten:function(){return Na},getArrayFromDType:function(){return Le},getTypedArrayFromDType:function(){return Me},hasEncodingLoss:function(){return Be},hexToLong:function(){return ea},indexToLoc:function(){return st},inferDtype:function(){return je},inferFromImplicitShape:function(){return _e},isBoolean:function(){return Ge},isFunction:function(){return qe},isInt:function(){return $e},isNumber:function(){return He},isPromise:function(){return at},isScalarShape:function(){return Ne},isString:function(){return Ue},isTypedArray:function(){return Ia},isValidDtype:function(){return Pe},locToIndex:function(){return rt},makeOnesTypedArray:function(){return Qe},makeZerosNestedTypedArray:function(){return tt},makeZerosTypedArray:function(){return et},nearestDivisor:function(){return Ke},nearestLargerEven:function(){return me},now:function(){return xa},parseAxisParam:function(){return De},randUniform:function(){return be},repeatedTry:function(){return Fe},rightPad:function(){return Ae},shuffle:function(){return pe},shuffleCombo:function(){return de},sizeFromShape:function(){return Ie},sizeToSquarishShape:function(){return Ee},squeezeShape:function(){return Oe},sum:function(){return ye},swap:function(){return ge},tanh:function(){return Ce},toNestedArray:function(){return Je},toTypedArray:function(){return ba}});var s={};n.r(s),n.d(s,{assertTypesMatch:function(){return ii},getTensorsInContainer:function(){return ui},isTensorInList:function(){return oi},makeTypesMatch:function(){return ai}});var a={};n.r(a),n.d(a,{isBrowser:function(){return ki},isMobile:function(){return vi},mockIsMobile:function(){return wi}});var i={};n.r(i),n.d(i,{Serializable:function(){return Hu},SerializationMap:function(){return ju},getRegisteredName:function(){return Ku},registerClass:function(){return qu}});var o={};n.r(o),n.d(o,{assertAndGetBroadcastShape:function(){return ul},getBroadcastDims:function(){return il},getReductionAxes:function(){return ol}});var u={};n.r(u),n.d(u,{CompositeArrayBuffer:function(){return Mi},browserFiles:function(){return Sl},browserHTTPRequest:function(){return Ll},concatenateArrayBuffers:function(){return ji},copyModel:function(){return Wo},decodeWeights:function(){return Bi},encodeWeights:function(){return Pi},fromMemory:function(){return Wl},fromMemorySync:function(){return Vl},getLoadHandlers:function(){return oo},getModelArtifactsForJSON:function(){return Yi},getModelArtifactsForJSONSync:function(){return Xi},getModelArtifactsInfoForJSON:function(){return Ji},getSaveHandlers:function(){return io},getWeightSpecs:function(){return Zi},http:function(){return Ml},isHTTPScheme:function(){return Dl},listModels:function(){return Po},loadWeights:function(){return Cl},moveModel:function(){return Vo},registerLoadRouter:function(){return ao},registerSaveRouter:function(){return so},removeModel:function(){return Bo},weightsLoaderFactory:function(){return El},withSaveHandler:function(){return Ul},withSaveHandlerSync:function(){return Gl}});var l={};n.r(l),n.d(l,{confusionMatrix:function(){return sc}});var c={};n.r(c),n.d(c,{draw:function(){return yc},fromPixels:function(){return bc},fromPixelsAsync:function(){return dc},toPixels:function(){return gc}});var h={};n.r(h),n.d(h,{prepareAndValidate:function(){return xc}});var p={};n.r(p),n.d(p,{calculateShapes:function(){return kc},validateInput:function(){return vc},validateUpdateShape:function(){return wc}});var d={};n.r(d),n.d(d,{assertParamsValid:function(){return Sc},computeFlatOffset:function(){return zc},computeOutShape:function(){return $c},getNormalizedAxes:function(){return Ac},isSliceContinous:function(){return Lc},maskToAxes:function(){return Tc},parseSliceParams:function(){return Pc},sliceInfo:function(){return Bc},startForAxis:function(){return Oc},startIndicesWithElidedDims:function(){return Fc},stopForAxis:function(){return Mc},stopIndicesWithElidedDims:function(){return _c},stridesForAxis:function(){return Dc},stridesWithElidedDims:function(){return Cc}});var f={};n.r(f),n.d(f,{TEST_EPSILON_FLOAT16:function(){return Gc},createVideoElement:function(){return th},encodeStrings:function(){return eh},expectArrayBuffersEqual:function(){return Qc},expectArraysClose:function(){return Hc},expectArraysEqual:function(){return Xc},expectNumbersClose:function(){return Yc},expectPromiseToFail:function(){return Kc},expectValuesInRange:function(){return Zc},play:function(){return nh},testEpsilon:function(){return jc}});var m={};n.r(m),n.d(m,{conv2d:function(){return Sb},depthwiseConv2d:function(){return Ab},matMul:function(){return _b}});var g={};n.r(g),n.d(g,{collectGatherOpShapeInfo:function(){return _v},computeOutShape:function(){return Fv},segOpComputeOptimalWindowSize:function(){return Av}});var y={};n.r(y),n.d(y,{ERF_A1:function(){return Xw},ERF_A2:function(){return Yw},ERF_A3:function(){return Jw},ERF_A4:function(){return Zw},ERF_A5:function(){return Qw},ERF_P:function(){return Kw},PARALLELIZE_THRESHOLD:function(){return zw},RowPartitionType:function(){return _w},SELU_SCALE:function(){return qw},SELU_SCALEALPHA:function(){return jw},applyActivation:function(){return kb},assertAndGetBroadcastShape:function(){return ul},assertAxesAreInnerMostDims:function(){return Pd},assertParamsConsistent:function(){return Aw},assignToTypedArray:function(){return av},axesAreInnerMostDims:function(){return Od},calculateShapes:function(){return kc},checkEinsumDimSizes:function(){return fv},checkPadOnDimRoundingMode:function(){return qh},combineLocations:function(){return Md},combineRaggedTensorToTensorShapes:function(){return Dw},complexWithEvenIndex:function(){return nv},complexWithOddIndex:function(){return rv},computeConv2DInfo:function(){return Fh},computeConv3DInfo:function(){return _h},computeDefaultPad:function(){return Mh},computeDilation2DInfo:function(){return Eh},computeOptimalWindowSize:function(){return Pw},computeOutAndReduceShapes:function(){return Ld},computeOutShape:function(){return Fw},computePool2DInfo:function(){return Rh},computePool3DInfo:function(){return Ah},convertConv2DDataFormat:function(){return jh},decodeEinsumEquation:function(){return pv},eitherStridesOrDilationsAreOne:function(){return Gh},expandShapeToKeepDim:function(){return zd},exponent:function(){return ov},exponents:function(){return iv},fromStringArrayToUint8:function(){return Ov},fromUint8ToStringArray:function(){return Dv},getAxesPermutation:function(){return Bd},getBroadcastDims:function(){return il},getComplexWithIndex:function(){return sv},getEinsumComputePath:function(){return mv},getEinsumPermutation:function(){return dv},getFusedBiasGradient:function(){return vb},getFusedDyActivation:function(){return wb},getImageCenter:function(){return Bw},getInnerMostAxes:function(){return Vd},getPermuted:function(){return Vw},getRaggedRank:function(){return Mw},getReductionAxes:function(){return ol},getReshaped:function(){return Ww},getReshapedPermuted:function(){return Uw},getRowPartitionTypesHelper:function(){return Ow},getSliceBeginCoords:function(){return Gw},getSliceSize:function(){return Hw},getSparseFillEmptyRowsIndicesDenseShapeMismatch:function(){return xv},getSparseFillEmptyRowsNegativeIndexErrorMessage:function(){return wv},getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:function(){return vv},getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:function(){return Nv},getSparseReshapeInputOutputMismatchErrorMessage:function(){return Tv},getSparseReshapeInputOutputMultipleErrorMessage:function(){return Sv},getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:function(){return kv},getSparseReshapeNegativeOutputDimErrorMessage:function(){return Iv},getSparseSegmentReductionIndicesOutOfRangeErrorMessage:function(){return Rv},getSparseSegmentReductionNegativeSegmentIdsErrorMessage:function(){return $v},getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:function(){return Cv},getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:function(){return Ev},getUndoAxesPermutation:function(){return Wd},isIdentityPermutation:function(){return gv},log:function(){return zs},mergeRealAndImagArrays:function(){return ev},prepareAndValidate:function(){return xc},prepareSplitSize:function(){return bv},segment_util:function(){return g},shouldFuse:function(){return Ib},slice_util:function(){return d},splitRealAndImagArrays:function(){return tv},stridesOrDilationsArePositive:function(){return Hh},tupleValuesAreOne:function(){return Uh},upcastType:function(){return ti},validateDefaultValueShape:function(){return Lw},validateInput:function(){return vc},validateUpdateShape:function(){return wc},warn:function(){return Ls}});var b={};n.r(b),n.d(b,{nonMaxSuppressionV3Impl:function(){return ax},nonMaxSuppressionV4Impl:function(){return ix},nonMaxSuppressionV5Impl:function(){return ox},whereImpl:function(){return Jy}});var x={};n.r(x),n.d(x,{maxNorm:function(){return hC},minMaxNorm:function(){return fC},nonNeg:function(){return dC},unitNorm:function(){return pC}});var w={};n.r(w),n.d(w,{constant:function(){return yC},glorotNormal:function(){return NC},glorotUniform:function(){return IC},heNormal:function(){return SC},heUniform:function(){return TC},identity:function(){return vC},leCunNormal:function(){return $C},leCunUniform:function(){return CC},ones:function(){return gC},orthogonal:function(){return EC},randomNormal:function(){return xC},randomUniform:function(){return bC},truncatedNormal:function(){return wC},varianceScaling:function(){return kC},zeros:function(){return mC}});var v={};n.r(v),n.d(v,{Layer:function(){return M$},RNN:function(){return AA},RNNCell:function(){return FA},activation:function(){return w_},add:function(){return E_},alphaDropout:function(){return xD},average:function(){return R_},averagePooling1d:function(){return P_},averagePooling2d:function(){return V_},averagePooling3d:function(){return H_},avgPool1d:function(){return B_},avgPool2d:function(){return U_},avgPool3d:function(){return j_},avgPooling1d:function(){return W_},avgPooling2d:function(){return G_},avgPooling3d:function(){return q_},batchNormalization:function(){return M_},bidirectional:function(){return hD},categoryEncoding:function(){return ND},centerCrop:function(){return kD},concatenate:function(){return A_},conv1d:function(){return h_},conv2d:function(){return p_},conv2dTranspose:function(){return d_},conv3d:function(){return f_},conv3dTranspose:function(){return m_},convLstm2d:function(){return oD},convLstm2dCell:function(){return uD},cropping2D:function(){return y_},dense:function(){return v_},depthwiseConv2d:function(){return x_},dot:function(){return O_},dropout:function(){return k_},elu:function(){return a_},embedding:function(){return C_},flatten:function(){return N_},gaussianDropout:function(){return bD},gaussianNoise:function(){return yD},globalAveragePooling1d:function(){return K_},globalAveragePooling2d:function(){return X_},globalMaxPool1d:function(){return dD},globalMaxPool2d:function(){return fD},globalMaxPooling1d:function(){return Y_},globalMaxPooling2d:function(){return J_},gru:function(){return tD},gruCell:function(){return nD},input:function(){return $R},inputLayer:function(){return s_},layerNormalization:function(){return L_},leakyReLU:function(){return o_},lstm:function(){return rD},lstmCell:function(){return sD},masking:function(){return wD},maxPool1d:function(){return mD},maxPool2d:function(){return gD},maxPooling1d:function(){return Z_},maxPooling2d:function(){return Q_},maxPooling3d:function(){return eD},maximum:function(){return F_},minimum:function(){return __},multiply:function(){return D_},permute:function(){return $_},prelu:function(){return u_},randomWidth:function(){return SD},reLU:function(){return i_},repeatVector:function(){return S_},rescaling:function(){return vD},reshape:function(){return T_},resizing:function(){return ID},rnn:function(){return lD},separableConv2d:function(){return g_},simpleRNN:function(){return aD},simpleRNNCell:function(){return iD},softmax:function(){return l_},spatialDropout1d:function(){return I_},stackedRNNCells:function(){return cD},thresholdedReLU:function(){return c_},timeDistributed:function(){return pD},upSampling2d:function(){return b_},zeroPadding2d:function(){return z_}});var k={};n.r(k),n.d(k,{MAPE:function(){return MD},MSE:function(){return PD},binaryAccuracy:function(){return TD},binaryCrossentropy:function(){return $D},categoricalAccuracy:function(){return ED},categoricalCrossentropy:function(){return RD},cosineProximity:function(){return _D},mape:function(){return LD},meanAbsoluteError:function(){return DD},meanAbsolutePercentageError:function(){return OD},meanSquaredError:function(){return zD},mse:function(){return BD},precision:function(){return AD},recall:function(){return FD},sparseCategoricalAccuracy:function(){return CD}});var I={};n.r(I),n.d(I,{modelFromJSON:function(){return wR}});var N={};n.r(N),n.d(N,{l1:function(){return VD},l1l2:function(){return WD},l2:function(){return UD}});var S={};n.r(S),n.d(S,{json:function(){return hO}});var T={};n.r(T),n.d(T,{json:function(){return pO}});var $={};n.r($),n.d($,{json:function(){return dO}});var C={};n.r(C),n.d(C,{json:function(){return fO}});var E={};n.r(E),n.d(E,{json:function(){return mO}});var R={};n.r(R),n.d(R,{json:function(){return gO}});var A={};n.r(A),n.d(A,{json:function(){return yO}});var F={};n.r(F),n.d(F,{json:function(){return bO}});var _={};n.r(_),n.d(_,{json:function(){return xO}});var D={};n.r(D),n.d(D,{json:function(){return wO}});var O={};n.r(O),n.d(O,{json:function(){return vO}});var M={};n.r(M),n.d(M,{json:function(){return kO}});var L={};n.r(L),n.d(L,{json:function(){return IO}});var z={};n.r(z),n.d(z,{json:function(){return NO}});var P={};n.r(P),n.d(P,{json:function(){return SO}});var B={};n.r(B),n.d(B,{json:function(){return TO}});var W={};n.r(W),n.d(W,{json:function(){return $O}});var V={};n.r(V),n.d(V,{json:function(){return CO}});var U={};n.r(U),n.d(U,{json:function(){return EO}});var G={};n.r(G),n.d(G,{OP_SCOPE_SUFFIX:function(){return Ei},abs:function(){return al},acos:function(){return ih},acosh:function(){return uh},add:function(){return ku},addN:function(){return ch},all:function(){return ph},any:function(){return fh},argMax:function(){return gh},argMin:function(){return bh},asin:function(){return wh},asinh:function(){return kh},atan:function(){return Nh},atan2:function(){return Th},atanh:function(){return Ch},avgPool:function(){return Jh},avgPool3d:function(){return Qh},basicLSTMCell:function(){return lp},batchNorm:function(){return fp},batchNorm2d:function(){return gp},batchNorm3d:function(){return bp},batchNorm4d:function(){return wp},batchToSpaceND:function(){return hp},bincount:function(){return kp},bitwiseAnd:function(){return Np},booleanMaskAsync:function(){return tb},broadcastArgs:function(){return Tp},broadcastTo:function(){return Cp},buffer:function(){return qo},cast:function(){return Xo},ceil:function(){return Rp},clipByValue:function(){return Fp},clone:function(){return Jo},complex:function(){return Fi},concat:function(){return tp},concat1d:function(){return Dp},concat2d:function(){return Mp},concat3d:function(){return zp},concat4d:function(){return Bp},conv1d:function(){return Gp},conv2d:function(){return Vp},conv2dTranspose:function(){return Kp},conv3d:function(){return Yp},conv3dTranspose:function(){return ed},cos:function(){return nd},cosh:function(){return sd},cosineWindow:function(){return mb},cumprod:function(){return id},cumsum:function(){return ud},denseBincount:function(){return cd},depthToSpace:function(){return pd},depthwiseConv2d:function(){return fd},diag:function(){return gd},dilation2d:function(){return bd},div:function(){return Tu},divNoNan:function(){return Nd},dot:function(){return Td},dropout:function(){return db},einsum:function(){return Cd},elu:function(){return Rd},enclosingPowerOfTwo:function(){return fb},ensureShape:function(){return Fd},equal:function(){return wd},erf:function(){return Dd},euclideanNorm:function(){return Qd},exp:function(){return tf},expandDims:function(){return rf},expm1:function(){return af},eye:function(){return cf},fft:function(){return hy},fill:function(){return Ju},floor:function(){return pf},floorDiv:function(){return Nu},fused:function(){return m},gather:function(){return ff},gatherND:function(){return cb},greater:function(){return gf},greaterEqual:function(){return bf},ifft:function(){return dy},imag:function(){return Yl},image:function(){return Iw},inTopKAsync:function(){return yb},irfft:function(){return my},isFinite:function(){return wf},isInf:function(){return kf},isNaN:function(){return Nf},leakyRelu:function(){return Tf},less:function(){return Cf},lessEqual:function(){return Rf},linalg:function(){return Nw},linspace:function(){return Af},localResponseNormalization:function(){return _f},log:function(){return Of},log1p:function(){return Lf},logSigmoid:function(){return Wf},logSoftmax:function(){return Uf},logSumExp:function(){return Hf},logicalAnd:function(){return qf},logicalNot:function(){return Xf},logicalOr:function(){return Jf},logicalXor:function(){return Qf},losses:function(){return Sw},lowerBound:function(){return rm},matMul:function(){return jl},max:function(){return Gd},maxPool:function(){return am},maxPool3d:function(){return om},maxPoolWithArgmax:function(){return lm},maximum:function(){return cl},mean:function(){return hm},meshgrid:function(){return fm},min:function(){return jd},minimum:function(){return gm},mirrorPad:function(){return bm},mod:function(){return wm},moments:function(){return km},movingAverage:function(){return rb},mul:function(){return Cu},multiRNNCell:function(){return Nm},multinomial:function(){return Tm},neg:function(){return Zl},norm:function(){return Jd},notEqual:function(){return Cm},oneHot:function(){return Kl},ones:function(){return dm},onesLike:function(){return Rm},op:function(){return Ri},outerProduct:function(){return Fm},pad:function(){return Dm},pad1d:function(){return Mm},pad2d:function(){return zm},pad3d:function(){return Bm},pad4d:function(){return Vm},pool:function(){return Km},pow:function(){return el},prelu:function(){return Ym},print:function(){return Zo},prod:function(){return Zm},raggedGather:function(){return eg},raggedRange:function(){return ng},raggedTensorToTensor:function(){return sg},rand:function(){return ig},randomGamma:function(){return pg},randomNormal:function(){return fg},randomStandardNormal:function(){return gg},randomUniform:function(){return bg},randomUniformInt:function(){return wg},range:function(){return vg},real:function(){return ec},reciprocal:function(){return Ig},relu:function(){return Sg},relu6:function(){return $g},reshape:function(){return Xh},reverse:function(){return Eg},reverse1d:function(){return Ag},reverse2d:function(){return _g},reverse3d:function(){return Og},reverse4d:function(){return Lg},rfft:function(){return xy},round:function(){return Pg},rsqrt:function(){return Wg},scalar:function(){return Vu},scatterND:function(){return ab},searchSorted:function(){return nm},selu:function(){return Ug},separableConv2d:function(){return Hg},setdiff1dAsync:function(){return qg},sigmoid:function(){return rp},sign:function(){return Xg},signal:function(){return kw},sin:function(){return Jg},sinh:function(){return Qg},slice:function(){return ap},slice1d:function(){return ty},slice2d:function(){return ry},slice3d:function(){return ay},slice4d:function(){return oy},softmax:function(){return ly},softplus:function(){return Pf},spaceToBatchND:function(){return Gm},sparse:function(){return Tw},sparseToDense:function(){return ub},spectral:function(){return vw},split:function(){return yy},sqrt:function(){return Ru},square:function(){return Fu},squaredDifference:function(){return vy},squeeze:function(){return Iy},stack:function(){return Sy},step:function(){return $y},stridedSlice:function(){return Ey},string:function(){return $w},sub:function(){return nl},sum:function(){return Kd},tan:function(){return Ay},tanh:function(){return op},tensor:function(){return Di},tensor1d:function(){return Fy},tensor2d:function(){return _y},tensor3d:function(){return ac},tensor4d:function(){return Dy},tensor5d:function(){return Oy},tensor6d:function(){return My},tensorScatterUpdate:function(){return zy},tile:function(){return uf},topk:function(){return By},transpose:function(){return nc},truncatedNormal:function(){return Vy},unique:function(){return Gy},unsortedSegmentSum:function(){return jy},unstack:function(){return Ky},upperBound:function(){return Xy},variable:function(){return Yy},where:function(){return kd},whereAsync:function(){return Qy},zeros:function(){return pm},zerosLike:function(){return Du}});var H={};n.r(H),n.d(H,{CSVDataset:function(){return UL},Dataset:function(){return RL},FileDataSource:function(){return rz},TextLineDataset:function(){return ML},URLDataSource:function(){return sz},array:function(){return FL},csv:function(){return az},func:function(){return iz},generator:function(){return oz},microphone:function(){return lz},version_data:function(){return cz},webcam:function(){return uz},zip:function(){return _L}});var j={};n.r(j),n.d(j,{addImpl:function(){return Rz},bincountImpl:function(){return Dz},bincountReduceImpl:function(){return Oz},bitwiseAndImpl:function(){return Mz},castImpl:function(){return Sz},ceilImpl:function(){return Vz},concatImpl:function(){return Hz},equalImpl:function(){return jz},expImpl:function(){return Xz},expm1Impl:function(){return Zz},floorDivImpl:function(){return sP},floorImpl:function(){return tP},gatherNdImpl:function(){return oP},gatherV2Impl:function(){return uP},greaterEqualImpl:function(){return pP},greaterImpl:function(){return lP},lessEqualImpl:function(){return bP},lessImpl:function(){return mP},linSpaceImpl:function(){return vP},logImpl:function(){return kP},maxImpl:function(){return SP},maximumImpl:function(){return TP},minimumImpl:function(){return EP},multiplyImpl:function(){return FP},negImpl:function(){return MP},notEqualImpl:function(){return PP},prodImpl:function(){return HP},raggedGatherImpl:function(){return tB},raggedRangeImpl:function(){return rB},raggedTensorToTensorImpl:function(){return uB},rangeImpl:function(){return lB},rsqrtImpl:function(){return cB},scatterImpl:function(){return dB},sigmoidImpl:function(){return fB},simpleAbsImpl:function(){return fz},sliceImpl:function(){return yB},sparseFillEmptyRowsImpl:function(){return wB},sparseReshapeImpl:function(){return vB},sparseSegmentReductionImpl:function(){return kB},sqrtImpl:function(){return IB},squaredDifferenceImpl:function(){return TB},staticRegexReplaceImpl:function(){return EB},stridedSliceImpl:function(){return FB},stringNGramsImpl:function(){return DB},stringSplitImpl:function(){return MB},stringToHashBucketFastImpl:function(){return LB},subImpl:function(){return zB},tileImpl:function(){return VB},topKImpl:function(){return HB},transposeImpl:function(){return VP},uniqueImpl:function(){return jB}});var q={};n.r(q),n.d(q,{assertNotComplex:function(){return tK},bindCanvasToFramebuffer:function(){return Cq},bindColorTextureToFramebuffer:function(){return Eq},bindTextureToProgramUniformSampler:function(){return $q},bindTextureUnit:function(){return Iq},bindVertexBufferToProgramAttribute:function(){return kq},callAndCheck:function(){return nq},canBeRepresented:function(){return iq},createFragmentShader:function(){return cq},createFramebuffer:function(){return vq},createProgram:function(){return dq},createStaticIndexBuffer:function(){return yq},createStaticVertexBuffer:function(){return gq},createTexture:function(){return xq},createVertexShader:function(){return lq},getBatchDim:function(){return Oq},getExtensionOrThrow:function(){return uq},getFramebufferErrorMessage:function(){return Fq},getMaxTexturesInShader:function(){return jq},getNumChannels:function(){return bq},getProgramUniformLocation:function(){return Tq},getProgramUniformLocationOrThrow:function(){return Sq},getRowsCols:function(){return Mq},getShapeAs3D:function(){return Lq},getTextureShapeFromLogicalShape:function(){return zq},getWebGLDisjointQueryTimerVersion:function(){return qq},getWebGLErrorMessage:function(){return oq},getWebGLMaxTextureSize:function(){return Uq},hasExtension:function(){return Kq},isCapableOfRenderingToFloatTexture:function(){return Yq},isDownloadFloatTextureEnabled:function(){return Jq},isReshapeFree:function(){return Bq},isWebGLFenceEnabled:function(){return eK},isWebGLVersionEnabled:function(){return Xq},linkProgram:function(){return fq},logShaderSourceAndInfoLog:function(){return pq},resetMaxTextureSize:function(){return Gq},resetMaxTexturesInShader:function(){return Hq},unbindColorTextureFromFramebuffer:function(){return Rq},unbindTextureUnit:function(){return Nq},validateFramebuffer:function(){return Aq},validateProgram:function(){return mq},validateTextureSize:function(){return wq}});var K={};n.r(K),n.d(K,{bindVertexProgramAttributeStreams:function(){return RX},createBufferFromOutputTexture:function(){return _X},createFloat16MatrixTexture:function(){return IX},createFloat16PackedMatrixTexture:function(){return EX},createFloat32MatrixTexture:function(){return vX},createIndexBuffer:function(){return bX},createPackedMatrixTexture:function(){return $X},createUnsignedBytesMatrixTexture:function(){return SX},createVertexBuffer:function(){return yX},createVertexShader:function(){return gX},downloadByteEncodedFloatMatrixFromOutputTexture:function(){return OX},downloadFloat32MatrixFromBuffer:function(){return DX},downloadMatrixFromPackedOutputTexture:function(){return LX},downloadPackedMatrixFromBuffer:function(){return MX},getInternalFormatForFloat16MatrixTexture:function(){return kX},getInternalFormatForFloat16PackedMatrixTexture:function(){return CX},getInternalFormatForFloat32MatrixTexture:function(){return wX},getInternalFormatForPackedMatrixTexture:function(){return TX},getInternalFormatForUnsignedBytesMatrixTexture:function(){return NX},uploadDenseMatrixToTexture:function(){return AX},uploadPixelDataToTexture:function(){return FX}});var X={};n.r(X),n.d(X,{Abs:function(){return bt},Acos:function(){return xt},Acosh:function(){return wt},AdadeltaOptimizer:function(){return Yu},AdagradOptimizer:function(){return Zu},AdamOptimizer:function(){return rl},AdamaxOptimizer:function(){return hl},Add:function(){return vt},AddN:function(){return kt},All:function(){return It},Any:function(){return Nt},ArgMax:function(){return St},ArgMin:function(){return Tt},Asin:function(){return $t},Asinh:function(){return Ct},Atan:function(){return Et},Atan2:function(){return At},Atanh:function(){return Rt},AvgPool:function(){return Ft},AvgPool3D:function(){return Dt},AvgPool3DGrad:function(){return Ot},AvgPoolGrad:function(){return _t},BatchMatMul:function(){return Mt},BatchToSpaceND:function(){return Lt},Bincount:function(){return zt},BitwiseAnd:function(){return Pt},BroadcastArgs:function(){return Wt},BroadcastTo:function(){return Bt},Callback:function(){return GD},CallbackList:function(){return OC},Cast:function(){return Vt},Ceil:function(){return Ut},ClipByValue:function(){return Gt},Complex:function(){return Ht},ComplexAbs:function(){return jt},Concat:function(){return qt},Conv2D:function(){return Kt},Conv2DBackpropFilter:function(){return Xt},Conv2DBackpropInput:function(){return Yt},Conv3D:function(){return Jt},Conv3DBackpropFilterV2:function(){return Zt},Conv3DBackpropInputV2:function(){return Qt},Cos:function(){return en},Cosh:function(){return tn},CropAndResize:function(){return sn},Cumprod:function(){return nn},Cumsum:function(){return rn},CustomCallback:function(){return zC},DataStorage:function(){return le},DenseBincount:function(){return an},DepthToSpace:function(){return on},DepthwiseConv2dNative:function(){return un},DepthwiseConv2dNativeBackpropFilter:function(){return ln},DepthwiseConv2dNativeBackpropInput:function(){return cn},Diag:function(){return hn},Dilation2D:function(){return pn},Dilation2DBackpropFilter:function(){return fn},Dilation2DBackpropInput:function(){return dn},Draw:function(){return mn},ENV:function(){return pt},EarlyStopping:function(){return qD},Einsum:function(){return yn},Elu:function(){return bn},EluGrad:function(){return xn},Environment:function(){return ot},Equal:function(){return vn},Erf:function(){return wn},Exp:function(){return kn},ExpandDims:function(){return In},Expm1:function(){return Nn},FFT:function(){return Sn},Fill:function(){return Tn},FlipLeftRight:function(){return $n},Floor:function(){return Cn},FloorDiv:function(){return En},FromPixels:function(){return Fs},FusedBatchNorm:function(){return Rn},FusedConv2D:function(){return Os},FusedDepthwiseConv2D:function(){return Ms},GPGPUContext:function(){return zX},GatherNd:function(){return Fn},GatherV2:function(){return An},GraphModel:function(){return GM},Greater:function(){return _n},GreaterEqual:function(){return Dn},History:function(){return LC},IFFT:function(){return Mn},Identity:function(){return On},Imag:function(){return Ln},InputSpec:function(){return A$},IsFinite:function(){return zn},IsInf:function(){return Pn},IsNan:function(){return Bn},KernelBackend:function(){return ce},LRN:function(){return Qn},LRNGrad:function(){return er},LayerVariable:function(){return $$},LayersModel:function(){return bR},LeakyRelu:function(){return Wn},Less:function(){return Vn},LessEqual:function(){return Un},LinSpace:function(){return Gn},Log:function(){return Hn},Log1p:function(){return jn},LogSoftmax:function(){return Jn},LogicalAnd:function(){return qn},LogicalNot:function(){return Kn},LogicalOr:function(){return Xn},LogicalXor:function(){return Yn},LowerBound:function(){return Zn},MathBackendCPU:function(){return dz},MathBackendWebGL:function(){return bJ},MatrixBandPart:function(){return tr},Max:function(){return nr},MaxPool:function(){return sr},MaxPool3D:function(){return ir},MaxPool3DGrad:function(){return or},MaxPoolGrad:function(){return ar},MaxPoolWithArgmax:function(){return ur},Maximum:function(){return rr},Mean:function(){return lr},Min:function(){return cr},Minimum:function(){return hr},MirrorPad:function(){return pr},Mod:function(){return dr},MomentumOptimizer:function(){return dl},Multinomial:function(){return fr},Multiply:function(){return mr},Neg:function(){return gr},NonMaxSuppressionV3:function(){return br},NonMaxSuppressionV4:function(){return xr},NonMaxSuppressionV5:function(){return wr},NotEqual:function(){return yr},OP_SCOPE_SUFFIX:function(){return Ei},OneHot:function(){return kr},OnesLike:function(){return vr},Optimizer:function(){return Xu},OptimizerConstructors:function(){return sh},Pack:function(){return Ir},PadV2:function(){return Nr},Pool:function(){return Sr},Pow:function(){return Tr},Prelu:function(){return $r},Prod:function(){return Cr},RMSPropOptimizer:function(){return fl},RNN:function(){return AA},RaggedGather:function(){return Er},RaggedRange:function(){return Rr},RaggedTensorToTensor:function(){return Ar},Range:function(){return Fr},Rank:function(){return Xa},Real:function(){return _r},RealDiv:function(){return gn},Reciprocal:function(){return Dr},Reduction:function(){return zx},Relu:function(){return Or},Relu6:function(){return Wr},Reshape:function(){return Mr},ResizeBilinear:function(){return Pr},ResizeBilinearGrad:function(){return Br},ResizeNearestNeighbor:function(){return Lr},ResizeNearestNeighborGrad:function(){return zr},Reverse:function(){return Vr},RotateWithOffset:function(){return _s},Round:function(){return Ur},Rsqrt:function(){return Gr},SGDOptimizer:function(){return pl},ScatterNd:function(){return Hr},SearchSorted:function(){return qr},Select:function(){return Kr},Selu:function(){return Xr},Sequential:function(){return NR},Sigmoid:function(){return es},Sign:function(){return Qr},Sin:function(){return Jr},Sinh:function(){return Zr},Slice:function(){return Yr},Softmax:function(){return is},Softplus:function(){return ts},SpaceToBatchND:function(){return ss},SparseFillEmptyRows:function(){return os},SparseReshape:function(){return us},SparseSegmentMean:function(){return ls},SparseSegmentSum:function(){return cs},SparseToDense:function(){return hs},SplitV:function(){return as},Sqrt:function(){return ns},Square:function(){return ds},SquaredDifference:function(){return ps},StaticRegexReplace:function(){return fs},Step:function(){return As},StridedSlice:function(){return ms},StringNGrams:function(){return gs},StringSplit:function(){return ys},StringToHashBucketFast:function(){return bs},Sub:function(){return xs},Sum:function(){return rs},SymbolicTensor:function(){return F$},Tan:function(){return ws},Tanh:function(){return vs},Tensor:function(){return ja},TensorBuffer:function(){return Pa},TensorScatterUpdate:function(){return jr},Tile:function(){return ks},TopK:function(){return Is},Transform:function(){return Ns},Transpose:function(){return Ss},Unique:function(){return Ts},Unpack:function(){return $s},UnsortedSegmentSum:function(){return Cs},UpperBound:function(){return Es},Variable:function(){return Ka},ZerosLike:function(){return Rs},_FusedMatMul:function(){return Ds},abs:function(){return al},acos:function(){return ih},acosh:function(){return uh},add:function(){return ku},addN:function(){return ch},all:function(){return ph},any:function(){return fh},argMax:function(){return gh},argMin:function(){return bh},asin:function(){return wh},asinh:function(){return kh},atan:function(){return Nh},atan2:function(){return Th},atanh:function(){return Ch},avgPool:function(){return Jh},avgPool3d:function(){return Qh},backend:function(){return xu},backend_util:function(){return y},basicLSTMCell:function(){return lp},batchNorm:function(){return fp},batchNorm2d:function(){return gp},batchNorm3d:function(){return bp},batchNorm4d:function(){return wp},batchToSpaceND:function(){return hp},bincount:function(){return kp},bitwiseAnd:function(){return Np},booleanMaskAsync:function(){return tb},broadcastArgs:function(){return Tp},broadcastTo:function(){return Cp},broadcast_util:function(){return o},browser:function(){return c},buffer:function(){return qo},callbacks:function(){return XD},cast:function(){return Xo},ceil:function(){return Rp},clipByValue:function(){return Fp},clone:function(){return Jo},complex:function(){return Fi},concat:function(){return tp},concat1d:function(){return Dp},concat2d:function(){return Mp},concat3d:function(){return zp},concat4d:function(){return Bp},constraints:function(){return x},conv1d:function(){return Gp},conv2d:function(){return Vp},conv2dTranspose:function(){return Kp},conv3d:function(){return Yp},conv3dTranspose:function(){return ed},copyRegisteredKernels:function(){return Ks},cos:function(){return nd},cosh:function(){return sd},cosineWindow:function(){return mb},cumprod:function(){return id},cumsum:function(){return ud},customGrad:function(){return Bu},data:function(){return H},denseBincount:function(){return cd},deprecationWarn:function(){return ru},depthToSpace:function(){return pd},depthwiseConv2d:function(){return fd},deregisterOp:function(){return nO},device_util:function(){return a},diag:function(){return gd},dilation2d:function(){return bd},disableDeprecationWarnings:function(){return nu},dispose:function(){return lu},disposeVariables:function(){return su},div:function(){return Tu},divNoNan:function(){return Nd},dot:function(){return Td},dropout:function(){return db},einsum:function(){return Cd},elu:function(){return Rd},enableDebugMode:function(){return tu},enableProdMode:function(){return eu},enclosingPowerOfTwo:function(){return fb},engine:function(){return au},ensureShape:function(){return Fd},env:function(){return ht},equal:function(){return wd},erf:function(){return Dd},euclideanNorm:function(){return Qd},exp:function(){return tf},expandDims:function(){return rf},expm1:function(){return af},eye:function(){return cf},fft:function(){return hy},fill:function(){return Ju},findBackend:function(){return gu},findBackendFactory:function(){return yu},floor:function(){return pf},floorDiv:function(){return Nu},forceHalfFloat:function(){return vJ},fused:function(){return m},gather:function(){return ff},gatherND:function(){return cb},gather_util:function(){return h},getBackend:function(){return fu},getGradient:function(){return Vs},getKernel:function(){return Ws},getKernelsForBackend:function(){return Us},gpgpu_util:function(){return K},grad:function(){return Ou},grads:function(){return Mu},greater:function(){return gf},greaterEqual:function(){return bf},ifft:function(){return dy},imag:function(){return Yl},image:function(){return Iw},inTopKAsync:function(){return yb},initializers:function(){return w},input:function(){return $R},io:function(){return u},irfft:function(){return my},isFinite:function(){return wf},isInf:function(){return kf},isNaN:function(){return Nf},keep:function(){return cu},kernel_impls:function(){return b},layers:function(){return v},leakyRelu:function(){return Tf},less:function(){return Cf},lessEqual:function(){return Rf},linalg:function(){return Nw},linspace:function(){return Af},loadGraphModel:function(){return HM},loadGraphModelSync:function(){return jM},loadLayersModel:function(){return vR},localResponseNormalization:function(){return _f},log:function(){return Of},log1p:function(){return Lf},logSigmoid:function(){return Wf},logSoftmax:function(){return Uf},logSumExp:function(){return Hf},logicalAnd:function(){return qf},logicalNot:function(){return Xf},logicalOr:function(){return Jf},logicalXor:function(){return Qf},losses:function(){return Sw},lowerBound:function(){return rm},matMul:function(){return jl},math:function(){return l},max:function(){return Gd},maxPool:function(){return am},maxPool3d:function(){return om},maxPoolWithArgmax:function(){return lm},maximum:function(){return cl},mean:function(){return hm},memory:function(){return iu},meshgrid:function(){return fm},metrics:function(){return k},min:function(){return jd},minimum:function(){return gm},mirrorPad:function(){return bm},mod:function(){return wm},model:function(){return SR},models:function(){return I},moments:function(){return km},movingAverage:function(){return rb},mul:function(){return Cu},multiRNNCell:function(){return Nm},multinomial:function(){return Tm},neg:function(){return Zl},nextFrame:function(){return Rw},norm:function(){return Jd},notEqual:function(){return Cm},oneHot:function(){return Kl},ones:function(){return dm},onesLike:function(){return Rm},op:function(){return Ri},outerProduct:function(){return Fm},pad:function(){return Dm},pad1d:function(){return Mm},pad2d:function(){return zm},pad3d:function(){return Bm},pad4d:function(){return Vm},pool:function(){return Km},pow:function(){return el},prelu:function(){return Ym},print:function(){return Zo},prod:function(){return Zm},profile:function(){return ou},raggedGather:function(){return eg},raggedRange:function(){return ng},raggedTensorToTensor:function(){return sg},rand:function(){return ig},randomGamma:function(){return pg},randomNormal:function(){return fg},randomStandardNormal:function(){return gg},randomUniform:function(){return bg},randomUniformInt:function(){return wg},range:function(){return vg},ready:function(){return du},real:function(){return ec},reciprocal:function(){return Ig},registerBackend:function(){return bu},registerCallbackConstructor:function(){return CR},registerGradient:function(){return Hs},registerKernel:function(){return Gs},registerOp:function(){return eO},regularizers:function(){return N},relu:function(){return Sg},relu6:function(){return $g},removeBackend:function(){return mu},reshape:function(){return Xh},reverse:function(){return Eg},reverse1d:function(){return Ag},reverse2d:function(){return _g},reverse3d:function(){return Og},reverse4d:function(){return Lg},rfft:function(){return xy},round:function(){return Pg},rsqrt:function(){return Wg},scalar:function(){return Vu},scatterND:function(){return ab},scatter_util:function(){return p},searchSorted:function(){return nm},selu:function(){return Ug},separableConv2d:function(){return Hg},sequential:function(){return TR},serialization:function(){return i},setBackend:function(){return pu},setPlatform:function(){return wu},setWebGLContext:function(){return Uj},setdiff1dAsync:function(){return qg},shared:function(){return j},sigmoid:function(){return rp},sign:function(){return Xg},signal:function(){return kw},sin:function(){return Jg},sinh:function(){return Qg},slice:function(){return ap},slice1d:function(){return ty},slice2d:function(){return ry},slice3d:function(){return ay},slice4d:function(){return oy},slice_util:function(){return d},softmax:function(){return ly},softplus:function(){return Pf},spaceToBatchND:function(){return Gm},sparse:function(){return Tw},sparseToDense:function(){return ub},spectral:function(){return vw},split:function(){return yy},sqrt:function(){return Ru},square:function(){return Fu},squaredDifference:function(){return vy},squeeze:function(){return Iy},stack:function(){return Sy},step:function(){return $y},stridedSlice:function(){return Ey},string:function(){return $w},sub:function(){return nl},sum:function(){return Kd},sumOutType:function(){return ni},tan:function(){return Ay},tanh:function(){return op},tensor:function(){return Di},tensor1d:function(){return Fy},tensor2d:function(){return _y},tensor3d:function(){return ac},tensor4d:function(){return Dy},tensor5d:function(){return Oy},tensor6d:function(){return My},tensorScatterUpdate:function(){return zy},tensor_util:function(){return s},test_util:function(){return f},tidy:function(){return uu},tile:function(){return uf},time:function(){return hu},topk:function(){return By},train:function(){return Cw},transpose:function(){return nc},truncatedNormal:function(){return Vy},unique:function(){return Gy},unregisterGradient:function(){return qs},unregisterKernel:function(){return js},unsortedSegmentSum:function(){return jy},unstack:function(){return Ky},upcastType:function(){return ti},upperBound:function(){return Xy},util:function(){return r},valueAndGrad:function(){return Lu},valueAndGrads:function(){return zu},variable:function(){return Yy},variableGrads:function(){return Pu},version:function(){return O8},version_converter:function(){return KM},version_core:function(){return rh},version_cpu:function(){return qB},version_layers:function(){return WE},version_webgl:function(){return wJ},webgl:function(){return kJ},webgl_util:function(){return q},where:function(){return kd},whereAsync:function(){return Qy},zeros:function(){return pm},zerosLike:function(){return Du}});var Y=function(){var e=this,t=e._self._c;return t("div",{staticClass:"modern-bg"},[t("el-row",{attrs:{gutter:0,justify:"center"}},[t("el-col",{attrs:{xs:{span:24,offset:0},sm:{span:22,offset:1},md:{span:18,offset:3},lg:{span:14,offset:5},xl:{span:12,offset:6}}},[t("el-card",{staticClass:"modern-card",attrs:{shadow:"hover"}},[t("div",{staticStyle:{color:"#f56c6c","font-size":"16px","margin-bottom":"12px","text-align":"center"}},[e._v(" Ë¶ÅÁ≠âÊ®°ÂûãÂä†ËΩΩ;ÊâßË°åÈ´òÊ∏ÖÂåñË¶ÅÂæà‰πÖÔºåÊÖ¢ÊÖ¢Á≠âÂêß; ")]),e.webglNotSupported?t("div",{staticStyle:{color:"#f56c6c","font-size":"16px","margin-bottom":"12px","text-align":"center"}},[e._v(" ÂΩìÂâçÊµèËßàÂô®ÊàñÊòæÂç°‰∏çÊîØÊåÅ WebGLÔºåÊó†Ê≥ï‰ΩøÁî®È´òÊ∏ÖÂåñÂäüËÉΩÔºåËØ∑Êõ¥Êç¢ËÆæÂ§áÊàñÊµèËßàÂô®„ÄÇ ")]):e._e(),e.webglNotSupported?e._e():t("div",{staticClass:"tile-settings"},[t("div",{staticClass:"setting-row"},[t("span",{staticClass:"setting-label"},[e._v("üß© ÂàÜÁâáÂ§ßÂ∞èÔºö")]),t("el-input-number",{staticStyle:{width:"120px","margin-right":"8px"},attrs:{min:100,max:500,step:10,size:"small",disabled:e.isProcessing()||e.loadingModel||e.aiFailed},model:{value:e.tileWidth,callback:function(t){e.tileWidth=t},expression:"tileWidth"}}),t("span",{staticStyle:{margin:"0 4px"}},[e._v("√ó")]),t("el-input-number",{staticStyle:{width:"120px","margin-right":"8px"},attrs:{min:100,max:500,step:10,size:"small",disabled:e.isProcessing()||e.loadingModel||e.aiFailed},model:{value:e.tileHeight,callback:function(t){e.tileHeight=t},expression:"tileHeight"}}),t("span",{staticClass:"setting-hint"},[e._v("ÂÉèÁ¥† (ÈªòËÆ§100√ó100ÔºåË∂äÂ∞èÂ§ÑÁêÜË∂äÊÖ¢‰ΩÜÂÜÖÂ≠òÂç†Áî®Ë∂äÂ∞ë,ÊòæÂç°Â•ΩÁöÑÂ∞±Ë∞ÉÂ§ß‰∫õ)")])],1),t("div",{staticClass:"setting-row"},[t("span",{staticClass:"setting-label"},[e._v("üîÑ ÈáçËØïËÆæÁΩÆÔºö")]),t("el-input-number",{staticStyle:{width:"120px","margin-right":"8px"},attrs:{min:1,max:5,size:"small",disabled:e.isProcessing()||e.loadingModel||e.aiFailed},model:{value:e.maxRetries,callback:function(t){e.maxRetries=t},expression:"maxRetries"}}),t("span",{staticClass:"setting-hint"},[e._v("Ê¨° (ÂàÜÁâáÂ§±Ë¥•Êó∂ÁöÑÊúÄÂ§ßÈáçËØïÊ¨°Êï∞)")])],1)]),t("div",{staticClass:"upload-row"},[e.webglNotSupported?e._e():[t("el-upload",{ref:"uploadRef",attrs:{action:"#","auto-upload":!1,multiple:!0,"show-file-list":!1,accept:"image/*",disabled:e.isProcessing()||e.loadingModel||e.aiFailed,"on-change":e.handleUploadChange}},[t("el-button",{attrs:{type:"primary",round:"",disabled:e.isProcessing()||e.loadingModel||e.aiFailed}},[e._v("ÈÄâÊã©ÂõæÁâá")])],1),t("el-button",{attrs:{type:"success",round:"",disabled:e.isProcessing()||0===e.imgs.length||e.loadingModel||e.aiFailed},on:{click:e.upscaleMany}},[e._v("È´òÊ∏ÖÂåñ")]),t("el-button",{attrs:{size:"mini",disabled:e.aiFailed},on:{click:function(t){return e.$refs.imgTable.clearSelection()}}},[e._v("ÂÖ®‰∏çÈÄâ")]),t("el-button",{attrs:{type:"danger",size:"mini",disabled:0===e.multipleSelection.length||e.aiFailed},on:{click:e.handleBatchDelete}},[e._v("ÊâπÈáèÂà†Èô§")]),t("el-button",{attrs:{type:"warning",size:"mini",disabled:0===e.imgs.filter((e=>e.upscaleImgFile)).length||e.aiFailed},on:{click:e.handleDownloadZip}},[e._v("ÊâìÂåÖ‰∏ãËΩΩ")])]],2),t("div",{staticStyle:{"margin-top":"24px"}},[t("el-table",{ref:"imgTable",staticStyle:{width:"100%","max-width":"900px",margin:"0 auto"},attrs:{data:e.imgs,border:""}},[t("el-table-column",{attrs:{type:"selection",width:"50"}}),t("el-table-column",{attrs:{label:"ÂéüÂõæ",align:"center"},scopedSlots:e._u([{key:"default",fn:function(n){return[n.row.img?t("el-image",{staticStyle:{width:"120px","border-radius":"10px","box-shadow":"0 2px 8px rgba(0,0,0,0.08)"},attrs:{src:n.row.img,alt:n.row.imgFile.name,"preview-src-list":e.imgs.map((e=>e.img))},on:{error:function(e){n.row.imgError=!0,n.row.msg="ÂõæÁâáÊñá‰ª∂ÊúâËØØ;"}}}):e._e(),n.row.imgFile?t("p",{staticClass:"img-info"},[e._v("Â§ßÂ∞è:"+e._s(e.formatFileSize(n.row.imgFile.size)))]):e._e()]}}])}),t("el-table-column",{attrs:{label:"È´òÊ∏ÖÁªìÊûú",align:"center"},scopedSlots:e._u([{key:"default",fn:function(n){return[n.row.upscaleImg?t("div",[t("el-image",{staticStyle:{width:"120px","border-radius":"10px","box-shadow":"0 2px 8px rgba(0,0,0,0.08)",background:"#f0f9eb"},attrs:{alt:"È´òÊ∏ÖÂêéÁöÑ"+n.row.imgFile.name,src:n.row.upscaleImg,"preview-src-list":e.imgs.map((e=>e.upscaleImg)).filter(Boolean)}}),n.row.processing?t("div",{staticStyle:{"font-size":"11px",color:"#E6A23C",margin:"3px 0"}},[e._v(" üé® ÂÆûÊó∂ÁîüÊàê‰∏≠... ")]):e._e(),!n.row.processing&&n.row.upscaleImgFile?t("el-button",{staticStyle:{"margin-top":"5px"},attrs:{type:"primary",size:"mini"},on:{click:function(t){return e.downloadImg(n.row)}}},[t("i",{staticClass:"el-icon-download"}),e._v(" ‰∏ãËΩΩ ")]):e._e(),n.row.upscaleImgFile?t("p",{staticClass:"img-info"},[e._v("Â§ßÂ∞è:"+e._s(e.formatFileSize(n.row.upscaleImgFile.size)))]):e._e()],1):n.row.processing?t("div",{staticStyle:{color:"#E6A23C","font-size":"12px"}},[e._v(" üîÑ ÂáÜÂ§áÁîüÊàê... ")]):t("div",{staticStyle:{color:"#999","font-size":"12px"}},[e._v(" Á≠âÂæÖÂ§ÑÁêÜ... ")])]}}])}),t("el-table-column",{attrs:{label:"ËØ¥Êòé",align:"center",width:"300"},scopedSlots:e._u([{key:"default",fn:function(n){return[t("div",{staticStyle:{"text-align":"center"}},[t("h3",{staticStyle:{color:"#409EFF",margin:"5px 0","font-size":"14px"}},[e._v(e._s(n.row.msg))]),n.row.processing&&n.row.totalTiles>1?t("div",{staticStyle:{"font-size":"12px",color:"#E6A23C",margin:"5px 0"}},[e._v(" üì¶ ÂàÜÁâá‰ø°ÊÅØ: ÊÄªÂÖ±"+e._s(n.row.totalTiles)+"ÁâáÔºåÂΩìÂâçÁ¨¨"+e._s(n.row.currentTile)+"Áâá "),t("br"),e._v(" üéØ ÂΩìÂâçÂàÜÁâá: ["+e._s(n.row.currentTileX)+","+e._s(n.row.currentTileY)+"] ")]):e._e(),n.row.processing&&n.row.progress>=0?t("div",[t("el-progress",{staticStyle:{margin:"8px 0"},attrs:{percentage:n.row.progress,"stroke-width":12,"text-inside":!0,status:100===n.row.progress?"success":null,color:100===n.row.progress?"#67C23A":"#409EFF"}}),t("div",{staticStyle:{"font-size":"12px",color:"#666","margin-top":"5px"}},[n.row.startTime?t("span",[e._v(" Â∑≤Áî®Êó∂: "+e._s(Math.floor(((new Date).getTime()-n.row.startTime)/1e3))+"Áßí ")]):e._e()])],1):e._e(),n.row.upscaleImg&&n.row.endTime&&n.row.startTime?t("div",{staticStyle:{"font-size":"12px",color:"#67C23A","margin-top":"5px"}},[e._v(" ‚úÖ ÊÄªÁî®Êó∂: "+e._s(Math.floor((n.row.endTime-n.row.startTime)/1e3))+"Áßí ")]):n.row.processing&&n.row.startTime?t("div",{staticStyle:{"font-size":"12px",color:"#E6A23C","margin-top":"5px"}},[e._v(" ‚è±Ô∏è Â§ÑÁêÜ‰∏≠: "+e._s(Math.floor(((new Date).getTime()-n.row.startTime)/1e3))+"Áßí ")]):e._e()])]}}])}),t("el-table-column",{attrs:{label:"Êìç‰Ωú",align:"center",width:"90"},scopedSlots:e._u([{key:"default",fn:function(n){return[t("el-button",{attrs:{type:"danger",size:"mini"},on:{click:function(t){return e.handleDeleteRow(n.$index)}}},[e._v("Âà†Èô§")])]}}])})],1)],1)])],1)],1),t("el-row",{attrs:{gutter:0,justify:"center"}},[t("el-col",{attrs:{xs:{span:24,offset:0},sm:{span:22,offset:1},md:{span:18,offset:3},lg:{span:14,offset:5},xl:{span:12,offset:6}}},[t("el-card",{staticClass:"modern-card",attrs:{shadow:"hover"}},[t("h3",{staticClass:"modern-title"},[e._v("Ê®°ÂûãÂä†ËΩΩËøõÂ∫¶("+e._s(e.modelLoaded?"Â∑≤Âä†ËΩΩ":"Âä†ËΩΩ‰∏≠")+")")]),t("el-divider"),t("el-table",{staticStyle:{width:"100%","max-width":"900px",margin:"0 auto"},attrs:{data:[e.modelProgress],border:""}},[t("el-table-column",{attrs:{label:"Ê®°Âûã",prop:"key",align:"center"}}),t("el-table-column",{attrs:{label:"Áä∂ÊÄÅ",prop:"current",align:"center"}}),t("el-table-column",{attrs:{label:"ËøõÂ∫¶",prop:"progress",align:"center"}})],1)],1)],1)],1)],1)},J=[],Z=(n(44114),n(14603),n(47566),n(98721),n(91114));const Q=e=>Array.isArray(e),ee=e=>Q(e)?e[0]:e,te=({scale:e,name:t,version:n,meta:{architecture:r,...s},path:a})=>{const i=a||`models/x${e}/model.json`;if("rdn"===r)return{scale:e,modelType:"layers",_internals:{path:i,name:t,version:n},meta:{architecture:r,...s},inputRange:[0,255],outputRange:[0,255]};const o=t=>{const n=t.layers.Layer,r=.2;class s extends n{constructor(){super({}),(0,Z.A)(this,"beta",void 0),this.beta=r}call(e){return t.mul(ee(e),this.beta)}}(0,Z.A)(s,"className","MultiplyBeta");const a=r=>{class s extends n{constructor(){super({}),(0,Z.A)(this,"scale",r)}computeOutputShape(e){return[e[0],e[1],e[2],3]}call(e){return t.depthToSpace(ee(e),this.scale,"NHWC")}}return(0,Z.A)(s,"className",`PixelShuffle${e}x`),s};[s,a(e)].forEach((e=>{t.serialization.registerClass(e)}))};return{setup:o,scale:e,modelType:"layers",_internals:{path:i,name:t,version:n},meta:{architecture:r,...s},inputRange:[0,1],outputRange:[0,1]}},ne="@upscalerjs/default-model",re="1.0.0-beta.17",se=2,ae=te({scale:se,name:ne,version:re,path:"models/model.json",meta:{C:1,D:2,G:4,G0:64,T:10,architecture:"rdn",patchSize:128,size:"slim",artifactReducing:!1,sharpening:!1,dataset:"div2k",modelFileName:"rdn-C1-D2-G4-G064-T10-x2-patchsize128-compress100-sharpen0-datadiv2k-vary_cFalse_best-val_loss_epoch494"}});var ie=ae;n(16280),n(72712),n(17642),n(58004),n(33853),n(45876),n(32475),n(15024),n(31698);
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const oe=1e-7,ue=1e-4;class le{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class ce{refCount(e){return he("refCount")}incRef(e){return he("incRef")}timerAvailable(){return!0}time(e){return he("time")}read(e){return he("read")}readSync(e){return he("readSync")}readToGPU(e,t){return he("readToGPU")}numDataIds(){return he("numDataIds")}disposeData(e,t){return he("disposeData")}write(e,t,n){return he("write")}move(e,t,n,r,s){return he("move")}createTensorFromGPUData(e,t,n){return he("createTensorFromGPUData")}memory(){return he("memory")}floatPrecision(){return he("floatPrecision")}epsilon(){return 32===this.floatPrecision()?oe:ue}dispose(){return he("dispose")}}function he(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}n(69479),n(16573),n(78100),n(77936),n(48140),n(21903),n(91134),n(28845),n(37467),n(44732),n(79577);
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function pe(e){let t=e.length,n=0;while(t>0)n=Math.random()*t|0,t--,ge(e,t,n)}function de(e,t){if(e.length!==t.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${e.length}Second array length was ${t.length}`);let n=e.length,r=0;while(n>0)r=Math.random()*n|0,n--,ge(e,n,r),ge(t,n,r)}function fe(e,t,n){return Math.max(e,Math.min(t,n))}function me(e){return e%2===0?e:e+1}function ge(e,t,n){const r=e[t];e[t]=e[n],e[n]=r}function ye(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}function be(e,t){const n=Math.random();return t*n+(1-n)*e}function xe(e,t){let n=0;for(let r=0;r<e.length;r++){const s=Number(e[r])-Number(t[r]);n+=s*s}return n}function we(e,t){if(!e)throw new Error("string"===typeof t?t:t())}function ve(e,t,n=""){we(Te(e,t),(()=>n+` Shapes ${e} and ${t} must match`))}function ke(e){we(null!=e,(()=>"The input to the tensor constructor must be a non-null value."))}function Ie(e){if(0===e.length)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function Ne(e){return 0===e.length}function Se(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(null!==e[n]&&null!==t[n]&&e[n]!==t[n])return!1;return!0}function Te(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function $e(e){return e%1===0}function Ce(e){if(null!=Math.tanh)return Math.tanh(e);if(e===1/0)return 1;if(e===-1/0)return-1;{const t=Math.exp(2*e);return(t-1)/(t+1)}}function Ee(e){const t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function Re(e){const t=new Uint32Array(e);for(let n=0;n<e;++n)t[n]=n;return pe(t),t}function Ae(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function Fe(e,t=e=>0,n,r){return new Promise(((s,a)=>{let i=0;const o=()=>{if(e())return void s();i++;const u=t(i);null!=n&&i>=n?a():null!=r?r(o,u):setTimeout(o,u)};o()}))}function _e(e,t){let n=1,r=-1;for(let a=0;a<e.length;++a)if(e[a]>=0)n*=e[a];else if(-1===e[a]){if(-1!==r)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${a}`);r=a}else if(e[a]<0)throw Error(`Shapes can not be < 0. Found ${e[a]} at dim ${a}`);if(-1===r){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(0===n)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!==0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);const s=e.slice();return s[r]=t/n,s}function De(e,t){const n=t.length;return e=null==e?t.map(((e,t)=>t)):[].concat(e),we(e.every((e=>e>=-n&&e<n)),(()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`)),we(e.every((e=>$e(e))),(()=>`All values in axis param must be integers but got axis ${e}`)),e.map((e=>e<0?n+e:e))}function Oe(e,t){const n=[],r=[],s=null!=t&&Array.isArray(t)&&0===t.length,a=null==t||s?null:De(t,e).sort();let i=0;for(let o=0;o<e.length;++o){if(null!=a){if(a[i]===o&&1!==e[o])throw new Error(`Can't squeeze axis ${o} since its dim '${e[o]}' is not 1`);(null==a[i]||a[i]>o)&&1===e[o]&&(n.push(e[o]),r.push(o)),a[i]<=o&&i++}1!==e[o]&&(n.push(e[o]),r.push(o))}return{newShape:n,keptDims:r}}function Me(e,t){return Le(e,t)}function Le(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else if("bool"===e)n=new Uint8Array(t);else{if("string"!==e)throw new Error(`Unknown data type ${e}`);n=new Array(t)}return n}function ze(e,t){for(let n=0;n<e.length;n++){const r=e[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${t} being uploaded contains ${r}.`)}}function Pe(e){return"bool"===e||"complex64"===e||"float32"===e||"int32"===e||"string"===e}function Be(e,t){return"complex64"!==t&&(("float32"!==t||"complex64"===e)&&(("int32"!==t||"float32"===e||"complex64"===e)&&("bool"!==t||"bool"!==e)))}function We(e){if("float32"===e||"int32"===e)return 4;if("complex64"===e)return 8;if("bool"===e)return 1;throw new Error(`Unknown dtype ${e}`)}function Ve(e){if(null==e)return 0;let t=0;return e.forEach((e=>t+=e.length)),t}function Ue(e){return"string"===typeof e||e instanceof String}function Ge(e){return"boolean"===typeof e}function He(e){return"number"===typeof e}function je(e){return Array.isArray(e)?je(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":He(e)?"float32":Ue(e)?"string":Ge(e)?"bool":"float32"}function qe(e){return!!(e&&e.constructor&&e.call&&e.apply)}function Ke(e,t){for(let n=t;n<e;++n)if(e%n===0)return n;return e}function Xe(e){const t=e.length;if(t<2)return[];const n=new Array(t-1);n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}function Ye(e,t,n,r=!1){const s=new Array;if(1===t.length){const a=t[0]*(r?2:1);for(let t=0;t<a;t++)s[t]=n[e+t]}else{const a=t[0],i=t.slice(1),o=i.reduce(((e,t)=>e*t))*(r?2:1);for(let t=0;t<a;t++)s[t]=Ye(e+t*o,i,n,r)}return s}function Je(e,t,n=!1){if(0===e.length)return t[0];const r=e.reduce(((e,t)=>e*t))*(n?2:1);if(0===r)return[];if(r!==t.length)throw new Error(`[${e}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`);return Ye(0,e,t,n)}function Ze(e,t){if(Array.isArray(e))return e;if("float32"===t)return e instanceof Float32Array?e:new Float32Array(e);if("int32"===t)return e instanceof Int32Array?e:new Int32Array(e);if("bool"===t||"string"===t)return Uint8Array.from(new Int32Array(e));throw new Error(`Unknown dtype ${t}`)}function Qe(e,t){const n=et(e,t);for(let r=0;r<n.length;r++)n[r]=1;return n}function et(e,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t)return new Uint8Array(e);throw new Error(`Unknown data type ${t}`)}function tt(e,t){const n=e.reduce(((e,t)=>e*t),1);if(null==t||"float32"===t)return Je(e,new Float32Array(n));if("int32"===t)return Je(e,new Int32Array(n));if("bool"===t)return Je(e,new Uint8Array(n));throw new Error(`Unknown data type ${t}`)}function nt(e){e.forEach((t=>{we(Number.isInteger(t)&&t>=0,(()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`))}))}function rt(e,t,n){if(0===t)return 0;if(1===t)return e[0];let r=e[e.length-1];for(let s=0;s<e.length-1;++s)r+=n[s]*e[s];return r}function st(e,t,n){if(0===t)return[];if(1===t)return[e];const r=new Array(t);for(let s=0;s<r.length-1;++s)r[s]=Math.floor(e/n[s]),e-=r[s]*n[s];return r[r.length-1]=e,r}function at(e){return e&&e.then&&"function"===typeof e.then}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const it="tfjsflags";class ot{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=ut,this.populateURLFlags()}setPlatform(e,t){null!=this.platform&&(ht().getBool("IS_TEST")||ht().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},null!=this.urlFlags[e]){const t=this.urlFlags[e];ht().getBool("IS_TEST")||ht().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${t}.`),this.set(e,t)}}async getAsync(e){return e in this.flags||(this.flags[e]=await this.evaluateFlag(e)),this.flags[e]}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(at(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(null==this.flagRegistry[e])throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,null!=this.flagRegistry[e].setHook&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(null==this.flagRegistry[e])throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if("undefined"===typeof this.global||"undefined"===typeof this.global.location||"undefined"===typeof this.global.location.search)return;const e=this.getQueryParams(this.global.location.search);if(it in e){const t=e[it].split(",");t.forEach((e=>{const[t,n]=e.split(":");this.urlFlags[t]=ct(t,n)}))}}}function ut(e){const t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,((e,...n)=>(lt(t,n[0],n[1]),n.join("=")))),t}function lt(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}function ct(e,t){const n=t.toLowerCase();return"true"===n||"false"===n?"true"===n:""+ +n===n?+n:t}function ht(){return pt}let pt=null;function dt(e){pt=e}n(13611);
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let ft;function mt(){if(null==ft){let e;if("undefined"!==typeof window)e=window;else if("undefined"!==typeof n.g)e=n.g;else if("undefined"!==typeof process)e=process;else{if("undefined"===typeof self)throw new Error("Could not find a global object");e=self}ft=e}return ft}function gt(){const e=mt();return null==e._tfGlobals&&(e._tfGlobals=new Map),e._tfGlobals}function yt(e,t){const n=gt();if(n.has(e))return n.get(e);{const r=t();return n.set(e,r),n.get(e)}}const bt="Abs",xt="Acos",wt="Acosh",vt="Add",kt="AddN",It="All",Nt="Any",St="ArgMax",Tt="ArgMin",$t="Asin",Ct="Asinh",Et="Atan",Rt="Atanh",At="Atan2",Ft="AvgPool",_t="AvgPoolGrad",Dt="AvgPool3D",Ot="AvgPool3DGrad",Mt="BatchMatMul",Lt="BatchToSpaceND",zt="Bincount",Pt="BitwiseAnd",Bt="BroadcastTo",Wt="BroadcastArgs",Vt="Cast",Ut="Ceil",Gt="ClipByValue",Ht="Complex",jt="ComplexAbs",qt="Concat",Kt="Conv2D",Xt="Conv2DBackpropFilter",Yt="Conv2DBackpropInput",Jt="Conv3D",Zt="Conv3DBackpropFilterV2",Qt="Conv3DBackpropInputV2",en="Cos",tn="Cosh",nn="Cumprod",rn="Cumsum",sn="CropAndResize",an="DenseBincount",on="DepthToSpace",un="DepthwiseConv2dNative",ln="DepthwiseConv2dNativeBackpropFilter",cn="DepthwiseConv2dNativeBackpropInput",hn="Diag",pn="Dilation2D",dn="Dilation2DBackpropInput",fn="Dilation2DBackpropFilter",mn="Draw",gn="RealDiv",yn="Einsum",bn="Elu",xn="EluGrad",wn="Erf",vn="Equal",kn="Exp",In="ExpandDims",Nn="Expm1",Sn="FFT",Tn="Fill",$n="FlipLeftRight",Cn="Floor",En="FloorDiv",Rn="FusedBatchNorm",An="GatherV2",Fn="GatherNd",_n="Greater",Dn="GreaterEqual",On="Identity",Mn="IFFT",Ln="Imag",zn="IsFinite",Pn="IsInf",Bn="IsNan",Wn="LeakyRelu",Vn="Less",Un="LessEqual",Gn="LinSpace",Hn="Log",jn="Log1p",qn="LogicalAnd",Kn="LogicalNot",Xn="LogicalOr",Yn="LogicalXor",Jn="LogSoftmax",Zn="LowerBound",Qn="LRN",er="LRNGrad",tr="MatrixBandPart",nr="Max",rr="Maximum",sr="MaxPool",ar="MaxPoolGrad",ir="MaxPool3D",or="MaxPool3DGrad",ur="MaxPoolWithArgmax",lr="Mean",cr="Min",hr="Minimum",pr="MirrorPad",dr="Mod",fr="Multinomial",mr="Multiply",gr="Neg",yr="NotEqual",br="NonMaxSuppressionV3",xr="NonMaxSuppressionV4",wr="NonMaxSuppressionV5",vr="OnesLike",kr="OneHot",Ir="Pack",Nr="PadV2",Sr="Pool",Tr="Pow",$r="Prelu",Cr="Prod",Er="RaggedGather",Rr="RaggedRange",Ar="RaggedTensorToTensor",Fr="Range",_r="Real",Dr="Reciprocal",Or="Relu",Mr="Reshape",Lr="ResizeNearestNeighbor",zr="ResizeNearestNeighborGrad",Pr="ResizeBilinear",Br="ResizeBilinearGrad",Wr="Relu6",Vr="Reverse",Ur="Round",Gr="Rsqrt",Hr="ScatterNd",jr="TensorScatterUpdate",qr="SearchSorted",Kr="Select",Xr="Selu",Yr="Slice",Jr="Sin",Zr="Sinh",Qr="Sign",es="Sigmoid",ts="Softplus",ns="Sqrt",rs="Sum",ss="SpaceToBatchND",as="SplitV",is="Softmax",os="SparseFillEmptyRows",us="SparseReshape",ls="SparseSegmentMean",cs="SparseSegmentSum",hs="SparseToDense",ps="SquaredDifference",ds="Square",fs="StaticRegexReplace",ms="StridedSlice",gs="StringNGrams",ys="StringSplit",bs="StringToHashBucketFast",xs="Sub",ws="Tan",vs="Tanh",ks="Tile",Is="TopK",Ns="Transform",Ss="Transpose",Ts="Unique",$s="Unpack",Cs="UnsortedSegmentSum",Es="UpperBound",Rs="ZerosLike",As="Step",Fs="FromPixels",_s="RotateWithOffset",Ds="_FusedMatMul",Os="FusedConv2D",Ms="FusedDepthwiseConv2D";
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Ls(...e){ht().getBool("IS_TEST")||ht().getBool("PROD")||console.warn(...e)}function zs(...e){ht().getBool("IS_TEST")||ht().getBool("PROD")||console.log(...e)}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Ps=yt("kernelRegistry",(()=>new Map)),Bs=yt("gradRegistry",(()=>new Map));function Ws(e,t){const n=Xs(e,t);return Ps.get(n)}function Vs(e){return Bs.get(e)}function Us(e){const t=Ps.entries(),n=[];while(1){const{done:r,value:s}=t.next();if(r)break;const[a,i]=s,[o]=a.split("_");o===e&&n.push(i)}return n}function Gs(e){const{kernelName:t,backendName:n}=e,r=Xs(t,n);Ps.has(r)&&Ls(`The kernel '${t}' for backend '${n}' is already registered`),Ps.set(r,e)}function Hs(e){const{kernelName:t}=e;Bs.has(t)&&ht().getBool("DEBUG")&&Ls(`Overriding the gradient for '${t}'`),Bs.set(t,e)}function js(e,t){const n=Xs(e,t);if(!Ps.has(n))throw new Error(`The kernel '${e}' for backend '${t}' is not registered`);Ps.delete(n)}function qs(e){if(!Bs.has(e))throw new Error(`The gradient '${e}' for backend is not registered`);Bs.delete(e)}function Ks(e,t){const n=Us(e);n.forEach((e=>{const n=Object.assign({},e,{backendName:t});Gs(n)}))}function Xs(e,t){return`${t}_${e}`}
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Ys(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}var Js=n(18860),Zs=n.n(Js);
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Qs=Zs()||Js;function ea(e){return Qs.fromString(e,!0,16)}const ta=ea("c3a5c85c97cb3127"),na=ea("b492b66fbe98f273"),ra=ea("9ae16a3b2f90404f");function sa(e){return e.xor(e.shru(47))}function aa(e,t,n){const r=e.slice(t,t+n);return Qs.fromBytes(Array.from(r),!0,!0)}function ia(e,t){return aa(e,t,8)}function oa(e,t){return aa(e,t,4)}function ua(e,t){return 0===t?e:e.shru(t).or(e.shl(64-t))}function la(e,t,n=ea("9ddfea08eb382d69")){let r=e.xor(t).mul(n);r=r.xor(r.shru(47));let s=t.xor(r).mul(n);return s=s.xor(s.shru(47)),s=s.mul(n),s}function ca(e,t,n,r,s,a){s=s.add(e),a=ua(a.add(s).add(r),21);const i=s;return s=s.add(t),s=s.add(n),a=a.add(ua(s,44)),[s.add(r),a.add(i)]}function ha(e,t,n,r){return ca(ia(e,t),ia(e,t+8),ia(e,t+16),ia(e,t+24),n,r)}function pa(e,t=e.length){if(t>=8){const n=ra.add(2*t),r=ia(e,0).add(ra),s=ia(e,t-8),a=ua(s,37).mul(n).add(r),i=ua(r,25).add(s).mul(n);return la(a,i,n)}if(t>=4){const n=ra.add(2*t),r=oa(e,0);return la(r.shl(3).add(t),oa(e,t-4),n)}if(t>0){const n=e[0],r=e[t>>1],s=e[t-1],a=n+(r<<8),i=t+(s<<2);return sa(ra.mul(a).xor(ta.mul(i))).mul(ra)}return ra}function da(e,t=e.length){const n=ra.add(2*t),r=ia(e,0).mul(na),s=ia(e,8),a=ia(e,t-8).mul(n),i=ia(e,t-16).mul(ra);return la(ua(r.add(s),43).add(ua(a,30)).add(i),r.add(ua(s.add(ra),18)).add(a),n)}function fa(e,t=e.length){const n=ra.add(2*t),r=ia(e,0).mul(ra),s=ia(e,8),a=ia(e,t-8).mul(n),i=ia(e,t-16).mul(ra),o=ua(r.add(s),43).add(ua(a,30)).add(i),u=la(o,r.add(ua(s.add(ra),18)).add(a),n),l=ia(e,16).mul(n),c=ia(e,24),h=o.add(ia(e,t-32)).mul(n),p=u.add(ia(e,t-24)).mul(n);return la(ua(l.add(c),43).add(ua(h,30)).add(p),l.add(ua(c.add(r),18)).add(h),n)}function ma(e,t=e.length){const n=Qs.fromNumber(81,!0);if(t<=32)return t<=16?pa(e,t):da(e,t);if(t<=64)return fa(e,t);let r=n,s=n.mul(na).add(113),a=sa(s.mul(ra).add(113)).mul(ra),i=[Qs.UZERO,Qs.UZERO],o=[Qs.UZERO,Qs.UZERO];r=r.mul(ra).add(ia(e,0));let u=0;const l=64*(t-1>>6),c=l+(t-1&63)-63;do{r=ua(r.add(s).add(i[0]).add(ia(e,u+8)),37).mul(na),s=ua(s.add(i[1]).add(ia(e,u+48)),42).mul(na),r=r.xor(o[1]),s=s.add(i[0]).add(ia(e,u+40)),a=ua(a.add(o[0]),33).mul(na),i=ha(e,u,i[1].mul(na),r.add(o[0])),o=ha(e,u+32,a.add(o[1]),s.add(ia(e,u+16))),[a,r]=[r,a],u+=64}while(u!==l);const h=na.add(a.and(255).shl(1));return u=c,o[0]=o[0].add(t-1&63),i[0]=i[0].add(o[0]),o[0]=o[0].add(i[0]),r=ua(r.add(s).add(i[0]).add(ia(e,u+8)),37).mul(h),s=ua(s.add(i[1]).add(ia(e,u+48)),42).mul(h),r=r.xor(o[1].mul(9)),s=s.add(i[0].mul(9).add(ia(e,u+40))),a=ua(a.add(o[0]),33).mul(h),i=ha(e,u,i[1].mul(h),r.add(o[0])),o=ha(e,u+32,a.add(o[1]),s.add(ia(e,u+16))),[a,r]=[r,a],la(la(i[0],o[0],h).add(sa(s).mul(ta)).add(a),la(i[1],o[1],h).add(r),h)}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ga(e,t){return"string"===t?va(e):ba([e],t)}function ya(e,t){return e instanceof Float32Array&&"float32"===t||e instanceof Int32Array&&"int32"===t||e instanceof Uint8Array&&"bool"===t}function ba(e,t){if("string"===t)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=Na(e)),ht().getBool("DEBUG")&&ze(e,t),ya(e,t))return e;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t){const t=new Uint8Array(e.length);for(let n=0;n<t.length;++n)0!==Math.round(e[n])&&(t[n]=1);return t}throw new Error(`Unknown data type ${t}`)}function xa(){return ht().platform.now()}function wa(e,t){return ht().platform.fetch(e,t)}function va(e,t="utf-8"){return t=t||"utf-8",ht().platform.encode(e,t)}function ka(e,t="utf-8"){return t=t||"utf-8",ht().platform.decode(e,t)}function Ia(e){return null!=ht().platform.isTypedArray?ht().platform.isTypedArray(e):Ys(e)}function Na(e,t=[],n=!1){if(null==t&&(t=[]),"boolean"===typeof e||"number"===typeof e||"string"===typeof e||at(e)||null==e||Ia(e)&&n)t.push(e);else if(Array.isArray(e)||Ia(e))for(let r=0;r<e.length;++r)Na(e[r],t,n);else{let r=-1;for(const t of Object.keys(e))/^([1-9]+[0-9]*|0)$/.test(t)&&(r=Math.max(r,Number(t)));for(let s=0;s<=r;s++)Na(e[s],t,n)}return t}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Sa{constructor(e,t){this.backendTimer=e,this.logger=t,null==t&&(this.logger=new $a)}profileKernel(e,t,n){let r;const s=()=>{r=n()};let a;const i=xa();if(this.backendTimer.timerAvailable())a=this.backendTimer.time(s);else{s();for(const e of r)e.dataSync();a=Promise.resolve({kernelMs:xa()-i})}if(ht().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let u=0;u<r.length;u++){const t=r[u];t.data().then((n=>{Ta(n,t.dtype,e)}))}const o={kernelName:e,outputs:r,inputs:t,timeMs:a.then((e=>e.kernelMs)),extraInfo:a.then((e=>null!=e.getExtraProfileInfo?e.getExtraProfileInfo():""))};return o}logKernelProfile(e){const{kernelName:t,outputs:n,timeMs:r,inputs:s,extraInfo:a}=e;n.forEach((e=>{Promise.all([e.data(),r,a]).then((n=>{this.logger.logKernelProfile(t,e,n[0],n[1],s,n[2])}))}))}}function Ta(e,t,n){if("float32"!==t)return!1;for(let r=0;r<e.length;r++){const t=e[r];if(isNaN(t)||!isFinite(t))return console.warn(`Found ${t} in the result of '${n}'`),!0}return!1}class $a{logKernelProfile(e,t,n,r,s,a){const i="number"===typeof r?Ae(`${r}ms`,9):r["error"],o=Ae(e,25),u=t.rank,l=t.size,c=Ae(t.shape.toString(),14);let h="";for(const p in s){const e=s[p];if(null!=e){const n=e.shape||t.shape,r=n.length;h+=`${p}: ${r}D ${r>0?n:""} `}}console.log(`%c${o}\t%c${i}\t%c${u}D ${c}\t%c${l}\t%c${h}\t%c${a}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Ca(e,t,n){const r={},s={};for(let u=0;u<t.length;u++)r[t[u].id]=!0;for(let u=0;u<e.length;u++){const n=e[u],a=n.inputs;for(const e in a){const i=a[e];let o=!1;for(let e=0;e<t.length;e++)if(r[i.id]){n.outputs.forEach((e=>r[e.id]=!0)),o=!0,s[n.id]=!0;break}if(o)break}}const a={};a[n.id]=!0;const i={};for(let u=e.length-1;u>=0;u--){const t=e[u],n=t.inputs;for(let e=0;e<t.outputs.length;e++)if(a[t.outputs[e].id]){for(const e in n)a[n[e].id]=!0,i[t.id]=!0;break}}const o=[];for(let u=0;u<e.length;u++){const t=e[u];if(s[t.id]&&i[t.id]){const e={};for(const s in t.inputs){const n=t.inputs[s];r[n.id]&&(e[s]=n)}const n=Object.assign({},t);n.inputs=e,n.outputs=t.outputs,o.push(n)}}return o}function Ea(e,t,n,r){for(let s=t.length-1;s>=0;s--){const a=t[s],i=[];if(a.outputs.forEach((t=>{const n=e[t.id];null!=n?i.push(n):i.push(null)})),null==a.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${a.kernelName}.`);const o=a.gradient(i);for(const t in a.inputs){if(!(t in o))throw new Error(`Cannot backprop through input ${t}. Available gradients found: ${Object.keys(o)}.`);const s=n((()=>o[t]()));if("float32"!==s.dtype)throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input ${t} must have 'float32' dtype, but has '${s.dtype}'`);const i=a.inputs[t];if(!Te(s.shape,i.shape))throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input '${t}' has shape '${s.shape}', which does not match the shape of the input '${i.shape}'`);if(null==e[i.id])e[i.id]=s;else{const t=e[i.id];e[i.id]=r(t,s),t.dispose()}}}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Ra=20,Aa=3,Fa=7;function _a(e,t,n,r){const s=Xe(t),a=Da(e,t,n,s),i=t.length,o=La(e,t,n,s,a),u=["Tensor"];return r&&(u.push(`  dtype: ${n}`),u.push(`  rank: ${i}`),u.push(`  shape: [${t}]`),u.push("  values:")),u.push(o.map((e=>"    "+e)).join("\n")),u.join("\n")}function Da(e,t,n,r){const s=Ie(t),a=r[r.length-1],i=new Array(a).fill(0),o=t.length,u="complex64"===n?za(e):e;if(o>1)for(let l=0;l<s/a;l++){const e=l*a;for(let t=0;t<a;t++)i[t]=Math.max(i[t],Oa(u[e+t],0,n).length)}return i}function Oa(e,t,n){let r;return r=Array.isArray(e)?`${parseFloat(e[0].toFixed(Fa))} + ${parseFloat(e[1].toFixed(Fa))}j`:Ue(e)?`'${e}'`:"bool"===n?Ma(e):parseFloat(e.toFixed(Fa)).toString(),Ae(r,t)}function Ma(e){return 0===e?"false":"true"}function La(e,t,n,r,s,a=!0){const i="complex64"===n?2:1,o=t[0],u=t.length;if(0===u){if("complex64"===n){const t=za(e);return[Oa(t[0],0,n)]}return"bool"===n?[Ma(e[0])]:[e[0].toString()]}if(1===u){if(o>Ra){const t=Aa*i;let r=Array.from(e.slice(0,t)),a=Array.from(e.slice((o-Aa)*i,o*i));return"complex64"===n&&(r=za(r),a=za(a)),["["+r.map(((e,t)=>Oa(e,s[t],n))).join(", ")+", ..., "+a.map(((e,t)=>Oa(e,s[o-Aa+t],n))).join(", ")+"]"]}const t="complex64"===n?za(e):Array.from(e);return["["+t.map(((e,t)=>Oa(e,s[t],n))).join(", ")+"]"]}const l=t.slice(1),c=r.slice(1),h=r[0]*i,p=[];if(o>Ra){for(let t=0;t<Aa;t++){const r=t*h,a=r+h;p.push(...La(e.slice(r,a),l,n,c,s,!1))}p.push("...");for(let t=o-Aa;t<o;t++){const r=t*h,a=r+h;p.push(...La(e.slice(r,a),l,n,c,s,t===o-1))}}else for(let m=0;m<o;m++){const t=m*h,r=t+h;p.push(...La(e.slice(t,r),l,n,c,s,m===o-1))}const d=2===u?",":"";p[0]="["+(o>0?p[0]+d:"");for(let m=1;m<p.length-1;m++)p[m]=" "+p[m]+d;let f=",\n";for(let m=2;m<u;m++)f+="\n";return p[p.length-1]=" "+p[p.length-1]+"]"+(a?"":f),p}function za(e){const t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Pa{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=Ie(e),null!=n){const e=n.length;we(e===this.size,(()=>`Length of values '${e}' does not match the size inferred by the shape '${this.size}'.`))}if("complex64"===t)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||Le(t,this.size),this.strides=Xe(e)}set(e,...t){0===t.length&&(t=[0]),we(t.length===this.rank,(()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`));const n=this.locToIndex(t);this.values[n]=e}get(...e){0===e.length&&(e=[0]);let t=0;for(const r of e){if(r<0||r>=this.shape[t]){const t=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(t)}t++}let n=e[e.length-1];for(let r=0;r<e.length-1;++r)n+=this.strides[r]*e[r];return this.values[n]}locToIndex(e){if(0===this.rank)return 0;if(1===this.rank)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(0===this.rank)return[];if(1===this.rank)return[e];const t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return Ba().makeTensor(this.values,this.shape,this.dtype)}}let Ba=null,Wa=null,Va=null;function Ua(e){Ba=e}function Ga(e){Wa=e}function Ha(e){Va=e}class ja{constructor(e,t,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=Ie(e),this.strides=Xe(e),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return Wa.buffer(this.shape,this.dtype,e)}bufferSync(){return Wa.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return Je(this.shape,e,"complex64"===this.dtype)}arraySync(){return Je(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();const e=Ba().read(this.dataId);if("string"===this.dtype){const n=await e;try{return n.map((e=>ka(e)))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),Ba().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=Ba().readSync(this.dataId);if("string"===this.dtype)try{return e.map((e=>ka(e)))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await Ba().read(this.dataId);return"string"===this.dtype?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),Ba().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return Wa.print(this,e)}clone(){return this.throwIfDisposed(),Wa.clone(this)}toString(e=!1){const t=this.dataSync();return _a(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),Wa.cast(this,e)}variable(e=!0,t,n){return this.throwIfDisposed(),Ba().makeVariable(this,e,t,n)}}function qa(){return yt("Tensor",(()=>ja))}Object.defineProperty(ja,Symbol.hasInstance,{value:e=>!!e&&null!=e.data&&null!=e.dataSync&&null!=e.throwIfDisposed}),qa();class Ka extends ja{constructor(e,t,n,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!Te(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);Ba().disposeTensor(this),this.dataId=e.dataId,Ba().incRef(this,null)}dispose(){Ba().disposeVariable(this),this.isDisposedInternal=!0}}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var Xa,Ya,Ja,Za,Qa;Object.defineProperty(Ka,Symbol.hasInstance,{value:e=>e instanceof ja&&null!=e.assign&&e.assign instanceof Function}),function(e){e["R0"]="R0",e["R1"]="R1",e["R2"]="R2",e["R3"]="R3",e["R4"]="R4",e["R5"]="R5",e["R6"]="R6"}(Xa||(Xa={})),function(e){e["float32"]="float32",e["int32"]="int32",e["bool"]="int32",e["complex64"]="complex64"}(Ya||(Ya={})),function(e){e["float32"]="float32",e["int32"]="int32",e["bool"]="bool",e["complex64"]="complex64"}(Ja||(Ja={})),function(e){e["float32"]="float32",e["int32"]="float32",e["bool"]="float32",e["complex64"]="complex64"}(Za||(Za={})),function(e){e["float32"]="complex64",e["int32"]="complex64",e["bool"]="complex64",e["complex64"]="complex64"}(Qa||(Qa={}));const ei={float32:Za,int32:Ya,bool:Ja,complex64:Qa};function ti(e,t){if("string"===e||"string"===t){if("string"===e&&"string"===t)return"string";throw new Error(`Can not upcast ${e} with ${t}`)}return ei[e][t]}function ni(e){return ti(e,"int32")}function ri(e){return null!=e&&"object"===typeof e&&"texture"in e&&e.texture instanceof WebGLTexture}function si(e){return"undefined"!==typeof GPUBuffer&&null!=e&&"object"===typeof e&&"buffer"in e&&e.buffer instanceof GPUBuffer}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ai(e,t){if(e.dtype===t.dtype)return[e,t];const n=ti(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function ii(e,t){we(e.dtype===t.dtype,(()=>`The dtypes of the first(${e.dtype}) and second(${t.dtype}) input must match`))}function oi(e,t){return t.some((t=>t.id===e.id))}function ui(e){const t=[],n=new Set;return li(e,t,n),t}function li(e,t,n){if(null==e)return;if(e instanceof ja)return void t.push(e);if(!ci(e))return;const r=e;for(const s in r){const e=r[s];n.has(e)||(n.add(e),li(e,t,n))}}function ci(e){return Array.isArray(e)||"object"===typeof e}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function hi(e){return null!=e.kernelName}class pi{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map((e=>e.name))))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class di{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new pi}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then((()=>{}));if(null!=this.backendInstance)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t],r=await this.initializeBackend(n).success;if(r)return void await this.setBackend(n)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{const{asyncInit:t}=this.initializeBackend(e);if(t)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,n=1){return e in this.registryFactory?(Ls(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}async setBackend(e){if(null==this.registryFactory[e])throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,null==this.registry[e]){this.backendInstance=null;const{success:t,asyncInit:n}=this.initializeBackend(e),r=n?await t:t;if(!r)return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new Sa(this.backendInstance),!0}setupRegisteredKernels(){const e=Us(this.backendName);e.forEach((e=>{null!=e.setupFunc&&e.setupFunc(this.backendInstance)}))}disposeRegisteredKernels(e){const t=Us(e);t.forEach((t=>{null!=t.disposeFunc&&t.disposeFunc(this.registry[e])}))}initializeBackend(e){const t=this.registryFactory[e];if(null==t)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const n=t.factory();if(!n||n instanceof ce||"function"!==typeof n.then)return this.registry[e]=n,{success:!0,asyncInit:!1};{const t=++this.pendingBackendInitId,r=n.then((n=>!(t<this.pendingBackendInitId)&&(this.registry[e]=n,this.pendingBackendInit=null,!0))).catch((n=>(t<this.pendingBackendInitId||(this.pendingBackendInit=null,Ls(`Initialization of backend ${e} failed`),Ls(n.stack||n.message)),!1)));return this.pendingBackendInit=r,{success:r,asyncInit:!0}}}catch(n){return Ls(`Initialization of backend ${e} failed`),Ls(n.stack||n.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort(((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority))}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t],{success:r,asyncInit:s}=this.initializeBackend(n);if(s||r)return{name:n,asyncInit:s}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const n=this.state.tensorInfo.get(t),r=n.backend,s=this.readSync(t),a=r.refCount(t);r.disposeData(t,!0),n.backend=e,e.move(t,s,n.shape,n.dtype,a),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n,r=null;if(null==t){if("function"!==typeof e)throw new Error("Please provide a function to tidy()");t=e}else{if("string"!==typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!==typeof t)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=e}return this.scopedRun((()=>this.startScope(r)),(()=>this.endScope(n)),(()=>(n=t(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n)))}scopedRun(e,t,n){e();try{const e=n();return t(),e}catch(r){throw t(),r}}nextTensorId(){return di.nextTensorId++}nextVariableId(){return di.nextVariableId++}clone(e){const t=gi.runKernel(On,{x:e}),n={x:e},r=e=>({x:()=>{const t="float32",n={x:e},r={dtype:t};return gi.runKernel(Vt,n,r)}}),s=[];return this.addTapeNode(this.state.activeScope.name,n,[t],r,s,{}),t}runKernel(e,t,n){null==this.backendName&&this.backend;const r=null!=Ws(e,this.backendName);if(!r)throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){const r=this.backend.numDataIds();let s=0;n.forEach((e=>{s+="complex64"===e.dtype?3:1}));const a=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],i=r-t-s-a;if(i>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${i} data ids) after running '${e}'`)}runKernelFunc(e){let t,n=[];const r=this.isTapeOn(),s=this.state.numBytes,a=this.state.numTensors;let i,o;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;const u=hi(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(hi(e)){const{kernelName:t,inputs:s,attrs:a}=e;null==this.backendName&&this.backend;const u=Ws(t,this.backendName);we(null!=u,(()=>`Cannot find registered kernel '${t}' for backend '${this.backendName}'`)),i=()=>{const e=this.backend.numDataIds();o=u.kernelFunc({inputs:s,attrs:a,backend:this.backend});const i=Array.isArray(o)?o:[o];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(t,e,i);const l=i.map((e=>null!=e.rank?e:this.makeTensorFromTensorInfo(e)));if(r){const e=this.getTensorsForGradient(t,s,l);n=this.saveTensorsForBackwardMode(e)}return l}}else{const{forwardFunc:t}=e,s=e=>{r&&(n=e.map((e=>this.keep(this.clone(e)))))};i=()=>{const e=this.backend.numDataIds();o=this.tidy((()=>t(this.backend,s)));const n=Array.isArray(o)?o:[o];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(u,e,n),n}}const{inputs:l,attrs:c}=e,h=hi(e)?null:e.backwardsFunc;let p;return this.scopedRun((()=>this.state.kernelDepth++),(()=>this.state.kernelDepth--),(()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(p=this.profiler.profileKernel(u,l,(()=>i())),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(p),t=p.outputs):t=i()})),r&&this.addTapeNode(u,l,t,h,n,c),this.state.profiling&&this.state.activeProfile.kernels.push({name:u,bytesAdded:this.state.numBytes-s,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-a,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(l).map((e=>null!=l[e]?l[e].shape:null)),outputShapes:t.map((e=>e.shape)),kernelTimeMs:p.timeMs,extraInfo:p.extraInfo}),Array.isArray(o)?t:t[0]}saveTensorsForBackwardMode(e){const t=e.map((e=>this.keep(this.clone(e))));return t}getTensorsForGradient(e,t,n){const r=Vs(e);if(null!=r){const e=r.inputsToSave||[],s=r.outputsToSave||[];let a;r.saveAllInputs?(we(Array.isArray(t),(()=>"saveAllInputs is true, expected inputs to be an array.")),a=Object.keys(t).map((e=>t[e]))):a=e.map((e=>t[e]));const i=n.filter(((e,t)=>s[t]));return a.concat(i)}return[]}makeTensor(e,t,n,r){if(null==e)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",r=r||this.backend;let s=e;"string"===n&&Ue(e[0])&&(s=e.map((e=>va(e))));const a=r.write(s,t,n),i=new ja(t,n,a,this.nextTensorId());if(this.trackTensor(i,r),"string"===n){const e=this.state.tensorInfo.get(a),t=Ve(s);this.state.numBytes+=t-e.bytes,e.bytes=t}return i}makeTensorFromDataId(e,t,n,r){n=n||"float32";const s={dataId:e,shape:t,dtype:n};return this.makeTensorFromTensorInfo(s,r)}makeTensorFromTensorInfo(e,t){const{dataId:n,shape:r,dtype:s}=e,a=new ja(r,s,n,this.nextTensorId());return this.trackTensor(a,t),a}makeVariable(e,t=!0,n,r){n=n||this.nextVariableId().toString(),null!=r&&r!==e.dtype&&(e=e.cast(r));const s=new Ka(e,t,n,this.nextTensorId());if(null!=this.state.registeredVariables[s.name])throw new Error(`Variable with name ${s.name} was already registered`);return this.state.registeredVariables[s.name]=s,this.incRef(s,this.backend),s}trackTensor(e,t){this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++;let n=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(n=e.size*We(e.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n})),e instanceof Ka||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,"string"===e.dtype&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),"complex64"!==e.dtype&&"string"!==e.dtype){const t=e.size*We(e.dtype);this.state.numBytes-=t}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map((e=>e.totalBytesSnapshot))),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-n;for(const r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,t,n,r,s,a){const i={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:s},o=Vs(e);null!=o&&(r=o.gradFunc),null!=r&&(i.gradient=e=>(e=e.map(((e,t)=>{if(null==e){const e=n[t],r=et(e.size,e.dtype);return this.makeTensor(r,e.shape,e.dtype)}return e})),r(e.length>1?e:e[0],s,a))),this.state.activeTape.push(i)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=ui(e),n=new Set(t.map((e=>e.id)));for(let s=0;s<this.state.activeScope.track.length;s++){const e=this.state.activeScope.track[s];e.kept||n.has(e.id)||e.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach((e=>{e.kept||e.scopeId!==r.id||this.track(e)}))}gradients(e,t,n,r=!1){if(we(t.length>0,(()=>"gradients() received an empty list of xs.")),null!=n&&"float32"!==n.dtype)throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);const s=this.scopedRun((()=>this.startTape()),(()=>this.endTape()),(()=>this.tidy("forward",e)));we(s instanceof ja,(()=>"The result y returned by f() must be a tensor."));const a=Ca(this.state.activeTape,t,s);if(!r&&0===a.length&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",(()=>{const e={};e[s.id]=null==n?fi(s.shape):n,Ea(e,a,(e=>this.tidy(e)),yi);const r=t.map((t=>e[t.id]));return 0===this.state.gradientDepth&&(this.state.activeTape.forEach((e=>{for(const t of e.saved)t.dispose()})),this.state.activeTape=null),{value:s,grads:r}}))}customGrad(e){return we(qe(e),(()=>"The f passed in customGrad(f) must be a function.")),(...t)=>{let n;we(t.every((e=>e instanceof ja)),(()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors"));const r={};t.forEach(((e,t)=>{r[t]=e}));const s=(r,s)=>(n=e(...t,s),we(n.value instanceof ja,(()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor")),we(qe(n.gradFunc),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.")),n.value),a=(e,r)=>{const s=n.gradFunc(e,r),a=Array.isArray(s)?s:[s];we(a.length===t.length,(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).")),we(a.every((e=>e instanceof ja)),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."));const i={};return a.forEach(((e,t)=>{i[t]=()=>e})),i};return this.runKernelFunc({forwardFunc:s,backwardsFunc:a,inputs:r})}}readSync(e){const t=this.state.tensorInfo.get(e);return t.backend.readSync(e)}read(e){const t=this.state.tensorInfo.get(e);return t.backend.read(e)}readToGPU(e,t){const n=this.state.tensorInfo.get(e);return n.backend.readToGPU(e,t)}async time(e){const t=xa(),n=await this.backend.time(e);return n.wallMs=xa()-t,n}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new pi;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function fi(e){const t=Qe(Ie(e),"float32");return gi.makeTensor(t,e,"float32")}function mi(){const e=mt();if(null==e._tfengine){const t=new ot(e);e._tfengine=new di(t)}return dt(e._tfengine.ENV),Ua((()=>e._tfengine)),e._tfengine}di.nextTensorId=0,di.nextVariableId=0;const gi=mi();function yi(e,t){const n={a:e,b:t};return gi.runKernel(vt,n)}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function bi(){return"undefined"!==typeof navigator&&null!=navigator}let xi;function wi(e){xi=e}function vi(e){if(void 0!==xi)return xi;if(e||bi()){if(e||(e=navigator),"ReactNative"===e.product)return!0;const t=e.userAgent||e.vendor||("undefined"!==typeof window?window.opera:"");if(!t){const t=e;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function ki(){return"undefined"!==typeof window&&null!=window.document||"undefined"!==typeof WorkerGlobalScope}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Ii=ht();Ii.registerFlag("DEBUG",(()=>!1),(e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")})),Ii.registerFlag("IS_BROWSER",(()=>ki())),Ii.registerFlag("IS_NODE",(()=>"undefined"!==typeof process&&"undefined"!==typeof process.versions&&"undefined"!==typeof process.versions.node)),Ii.registerFlag("IS_CHROME",(()=>"undefined"!==typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor))),Ii.registerFlag("IS_SAFARI",(()=>"undefined"!==typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor))),Ii.registerFlag("PROD",(()=>!1)),Ii.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",(()=>Ii.getBool("DEBUG"))),Ii.registerFlag("DEPRECATION_WARNINGS_ENABLED",(()=>!0)),Ii.registerFlag("IS_TEST",(()=>!1)),Ii.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",(()=>Ii.getBool("DEBUG"))),Ii.registerFlag("WRAP_TO_IMAGEBITMAP",(()=>!1)),Ii.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",(()=>!1)),Ii.registerFlag("USE_SETTIMEOUTCUSTOM",(()=>!1));n(64979);
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Ni(e,t){let n=e;if(Ia(e))return"string"===t?[]:[e.length];if(ri(e)){const t=e.channels||"RGBA";return[e.height,e.width*t.length]}if(si(e))return[e.buffer.size/(null==t?4:We(t))];if(!Array.isArray(e))return[];const r=[];while(Array.isArray(n)||Ia(n)&&"string"!==t)r.push(n.length),n=n[0];return Array.isArray(e)&&ht().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&Si(e,r,[]),r}function Si(e,t,n){if(n=n||[],!Array.isArray(e)&&!Ia(e))return void we(0===t.length,(()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`));we(t.length>0,(()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${e.length} elements`)),we(e.length===t[0],(()=>`Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`));const r=t.slice(1);for(let s=0;s<e.length;++s)Si(e[s],r,n.concat(s))}function Ti(e,t,n,r){if("string_or_numeric"!==e){if(null==e)throw new Error("Expected dtype cannot be null.");if("numeric"!==e&&e!==t||"numeric"===e&&"string"===t)throw new Error(`Argument '${n}' passed to '${r}' must be ${e} tensor, but got ${t} tensor`)}}function $i(e,t,n,r="numeric"){if(e instanceof ja)return Ti(r,e.dtype,t,n),e;let s=je(e);if("string"!==s&&["bool","int32","float32"].indexOf(r)>=0&&(s=r),Ti(r,s,t,n),null==e||!Ia(e)&&!Array.isArray(e)&&"number"!==typeof e&&"boolean"!==typeof e&&"string"!==typeof e){const r=null==e?"null":e.constructor.name;throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${r}'`)}const a=Ni(e,s);Ia(e)||Array.isArray(e)||(e=[e]);const i=!0,o="string"!==s?ba(e,s):Na(e,[],i);return gi.makeTensor(o,a,s)}function Ci(e,t,n,r="numeric"){if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);const s=e;return s.map(((e,s)=>$i(e,`${t}[${s}]`,n,r)))}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Ei="__op";function Ri(e){const t=Object.keys(e);if(1!==t.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0];const r=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+=Ei;const s=(...e)=>{gi.startScope(n);try{const t=r(...e);return at(t)&&console.error("Cannot return a Promise inside of tidy."),gi.endScope(t),t}catch(t){throw gi.endScope(null),t}};return Object.defineProperty(s,"name",{value:n,configurable:!0}),s}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Ai(e,t){const n=$i(e,"real","complex"),r=$i(t,"imag","complex");ve(n.shape,r.shape,`real and imag shapes, ${n.shape} and ${r.shape}, must match in call to tf.complex().`);const s={real:n,imag:r};return gi.runKernel(Ht,s)}const Fi=Ri({complex_:Ai});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function _i(e,t,n,r){if(null==r)r=je(e);else if("complex64"===r)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(si(e)||ri(e)){if("float32"!==r&&"int32"!==r)throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return gi.backend.createTensorFromGPUData(e,t||n,r)}if(!Ia(e)&&!Array.isArray(e)&&"number"!==typeof e&&"boolean"!==typeof e&&"string"!==typeof e)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){nt(t);const e=Ie(t),r=Ie(n);we(e===r,(()=>`Based on the provided shape, [${t}], the tensor should have ${e} values but has ${r}`));for(let s=0;s<n.length;++s){const e=n[s],r=s!==n.length-1||e!==Ie(t.slice(s));we(n[s]===t[s]||!r,(()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `))}}return Ia(e)||Array.isArray(e)||(e=[e]),t=t||n,e="string"!==r?ba(e,r):Na(e,[],!0),gi.makeTensor(e,t,r)}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Di(e,t,n){const r=Ni(e,n);return _i(e,t,r,n)}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Oi={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};class Mi{static join(e){return new Mi(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,null==e)return;if(e instanceof Array||(e=[e]),e=e.map((e=>Ia(e)?e.buffer:e)),0===e.length)return;this.bufferUniformSize=e[0].byteLength;let t=0;for(let n=0;n<e.length;n++){const r=e[n];n!==e.length-1&&r.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const s=t+r.byteLength;this.shards.push({buffer:r,start:t,end:s}),t=s}0===this.shards.length&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(e=0,t=this.byteLength){if(0===this.shards.length)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,t=isNaN(Number(t))?0:t,e=Math.max(0,e),t=Math.min(this.byteLength,t),t<=e)return new ArrayBuffer(0);const n=this.findShardForByte(e);if(-1===n)throw new Error(`Could not find start shard for byte ${e}`);const r=t-e,s=new ArrayBuffer(r),a=new Uint8Array(s);let i=0;for(let o=n;o<this.shards.length;o++){const n=this.shards[o],r=e+i,s=r-n.start,u=i,l=Math.min(t,n.end),c=l-n.start,h=new Uint8Array(n.buffer,s,c-s);if(a.set(h,u),i+=h.length,t<n.end)break}return s}findShardForByte(e){if(0===this.shards.length||e<0||e>=this.byteLength)return-1;if(null!=this.bufferUniformSize)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function t(t){return e<t.start?-1:e>=t.end?1:0}if(0===t(this.shards[this.previousShardIndex]))return this.previousShardIndex;const n=Li(this.shards,t);return-1===n?-1:(this.previousShardIndex=n,this.previousShardIndex)}}function Li(e,t){let n=0,r=e.length;while(n<=r){const s=Math.floor((r-n)/2)+n,a=t(e[s]);if(0===a)return s;a<0?r=s:n=s+1}return-1}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const zi=4;async function Pi(e,t){const n=[],r=[],s=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);for(let i=0;i<s.length;++i){const a=s[i],o=Array.isArray(e)?e[i].tensor:e[a];if("float32"!==o.dtype&&"int32"!==o.dtype&&"bool"!==o.dtype&&"string"!==o.dtype&&"complex64"!==o.dtype)throw new Error(`Unsupported dtype in weight '${a}': ${o.dtype}`);const u={name:a,shape:o.shape,dtype:o.dtype};if("string"===o.dtype){const e=new Promise((async e=>{const t=await o.bytes(),n=t.reduce(((e,t)=>e+t.length),0)+zi*t.length,r=new Uint8Array(n);let s=0;for(let a=0;a<t.length;a++){const e=t[a],n=new Uint8Array(new Uint32Array([e.length]).buffer);r.set(n,s),s+=zi,r.set(e,s),s+=e.length}e(r)}));r.push(e)}else r.push(o.data());null!=t&&(u.group=t),n.push(u)}const a=await Promise.all(r);return{data:Wi(a),specs:n}}function Bi(e,t){const n=new Mi(e),r={};let s,a=0;for(const i of t){const e=i.name,t=i.dtype,o=i.shape,u=Ie(o);let l;if("quantization"in i){const r=i.quantization;if("uint8"===r.dtype||"uint16"===r.dtype){if(!("min"in r)||!("scale"in r))throw new Error(`Weight ${i.name} with quantization ${r.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==r.dtype)throw new Error(`Weight ${i.name} has unknown quantization dtype ${r.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==t)throw new Error(`Weight ${i.name} is quantized with ${r.dtype} which only supports weights of type float32 not ${t}.`)}const o=Oi[r.dtype],c=n.slice(a,a+u*o),h="uint8"===r.dtype?new Uint8Array(c):new Uint16Array(c);if("float32"===t)if("uint8"===r.dtype||"uint16"===r.dtype){l=new Float32Array(h.length);for(let e=0;e<h.length;e++){const t=h[e];l[e]=t*r.scale+r.min}}else{if("float16"!==r.dtype)throw new Error(`Unsupported quantization type ${r.dtype} for weight type float32.`);void 0===s&&(s=no()),l=s(h)}else{if("int32"!==t)throw new Error(`Unsupported dtype in weight '${e}': ${t}`);if("uint8"!==r.dtype&&"uint16"!==r.dtype)throw new Error(`Unsupported quantization type ${r.dtype} for weight type int32.`);l=new Int32Array(h.length);for(let e=0;e<h.length;e++){const t=h[e];l[e]=Math.round(t*r.scale+r.min)}}a+=u*o}else if("string"===t){const e=Ie(i.shape);l=[];for(let t=0;t<e;t++){const e=new Uint32Array(n.slice(a,a+zi))[0];a+=zi;const t=new Uint8Array(n.slice(a,a+e));l.push(t),a+=e}}else{const s=Oi[t],i=n.slice(a,a+u*s);if("float32"===t)l=new Float32Array(i);else if("int32"===t)l=new Int32Array(i);else if("bool"===t)l=new Uint8Array(i);else{if("complex64"!==t)throw new Error(`Unsupported dtype in weight '${e}': ${t}`);{l=new Float32Array(i);const t=new Float32Array(l.length/2),n=new Float32Array(l.length/2);for(let e=0;e<t.length;e++)t[e]=l[2*e],n[e]=l[2*e+1];const s=Di(t,o,"float32"),a=Di(n,o,"float32");r[e]=Fi(s,a),s.dispose(),a.dispose()}}a+=u*s}"complex64"!==t&&(r[e]=Di(l,o,t))}return r}function Wi(e){if(null===e)throw new Error(`Invalid input value: ${JSON.stringify(e)}`);let t=0;const n=[];e.forEach((e=>{if(t+=e.byteLength,n.push(e.byteLength===e.buffer.byteLength?e:new e.constructor(e)),!(e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${e.constructor.name}`)}));const r=new Uint8Array(t);let s=0;return n.forEach((e=>{r.set(new Uint8Array(e.buffer),s),s+=e.byteLength})),r.buffer}const Vi="undefined"!==typeof Buffer&&("undefined"===typeof Blob||"undefined"===typeof atob||"undefined"===typeof btoa);function Ui(e){return Vi?Buffer.byteLength(e,"utf8"):new Blob([e]).size}function Gi(e){if(Vi)return Buffer.from(e).toString("base64");const t=new Uint8Array(e);let n="";for(let r=0,s=t.length;r<s;r++)n+=String.fromCharCode(t[r]);return btoa(n)}function Hi(e){if(Vi){const t=Buffer.from(e,"base64");return t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength)}const t=atob(e),n=new Uint8Array(t.length);for(let r=0;r<t.length;++r)n.set([t.charCodeAt(r)],r);return n.buffer}function ji(e){return Mi.join(e)}function qi(e){const t="/";e=e.trim();while(e.endsWith(t))e=e.slice(0,e.length-1);const n=e.split(t);return n[n.length-1]}function Ki(e,t){const n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return null!=e.signature&&(n.signature=e.signature),null!=e.userDefinedMetadata&&(n.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(n.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(n.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(n.trainingConfig=e.trainingConfig),n}function Xi(e,t,n){const r={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(null!=e.trainingConfig&&(r.trainingConfig=e.trainingConfig),null!=e.weightsManifest){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=t,r.weightData=n}return null!=e.signature&&(r.signature=e.signature),null!=e.userDefinedMetadata&&(r.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(r.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(r.initializerSignature=e.initializerSignature),r}async function Yi(e,t){let n,r;return null!=e.weightsManifest&&([n,r]=await t(e.weightsManifest)),Xi(e,n,r)}function Ji(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==e.modelTopology?0:Ui(JSON.stringify(e.modelTopology)),weightSpecsBytes:null==e.weightSpecs?0:Ui(JSON.stringify(e.weightSpecs)),weightDataBytes:null==e.weightData?0:new Mi(e.weightData).byteLength}}function Zi(e){const t=[];for(const n of e)t.push(...n.weights);return t}function Qi(){const e=e=>{let t=e<<13,n=0;while(0===(8388608&t))n-=8388608,t<<=1;return t&=-8388609,n+=947912704,t|n},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=e(n);for(let n=1024;n<2048;n++)t[n]=939524096+(n-1024<<13);return t}function eo(){const e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=2147483648+(t-32<<23);return e}function to(){const e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}function no(){const e=Qi(),t=eo(),n=to();return r=>{const s=new ArrayBuffer(4*r.length),a=new Uint32Array(s);for(let i=0;i<r.length;i++){const s=r[i],o=e[n[s>>10]+(1023&s)]+t[s>>10];a[i]=o}return new Float32Array(s)}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class ro{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==ro.instance&&(ro.instance=new ro),ro.instance}static registerSaveRouter(e){ro.getInstance().saveRouters.push(e)}static registerLoadRouter(e){ro.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return ro.getHandlers(e,"save")}static getLoadHandlers(e,t){return ro.getHandlers(e,"load",t)}static getHandlers(e,t,n){const r=[],s="load"===t?ro.getInstance().loadRouters:ro.getInstance().saveRouters;return s.forEach((t=>{const s=t(e,n);null!==s&&r.push(s)})),r}}const so=e=>ro.registerSaveRouter(e),ao=e=>ro.registerLoadRouter(e),io=e=>ro.getSaveHandlers(e),oo=(e,t)=>ro.getLoadHandlers(e,t),uo="tensorflowjs",lo=1,co="models_store",ho="model_info_store";function po(){if(!ht().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const e="undefined"===typeof window?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(null==t)throw new Error("The current browser does not appear to support IndexedDB.");return t}function fo(e){const t=e.result;t.createObjectStore(co,{keyPath:"modelPath"}),t.createObjectStore(ho,{keyPath:"modelPath"})}class mo{constructor(e){if(this.indexedDB=po(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise(((e,n)=>{const r=this.indexedDB.open(uo,lo);r.onupgradeneeded=()=>fo(r),r.onsuccess=()=>{const s=r.result;if(null==t){const t=s.transaction(co,"readonly"),r=t.objectStore(co),a=r.get(this.modelPath);a.onsuccess=()=>{if(null==a.result)return s.close(),n(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));e(a.result.modelArtifacts)},a.onerror=e=>(s.close(),n(a.error)),t.oncomplete=()=>s.close()}else{t.weightData=Mi.join(t.weightData);const r=Ji(t),i=s.transaction(ho,"readwrite");let o,u,l=i.objectStore(ho);try{o=l.put({modelPath:this.modelPath,modelArtifactsInfo:r})}catch(a){return n(a)}o.onsuccess=()=>{u=s.transaction(co,"readwrite");const o=u.objectStore(co);let c;try{c=o.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:r})}catch(a){return n(a)}c.onsuccess=()=>e({modelArtifactsInfo:r}),c.onerror=e=>{l=i.objectStore(ho);const t=l.delete(this.modelPath);t.onsuccess=()=>(s.close(),n(c.error)),t.onerror=e=>(s.close(),n(c.error))}},o.onerror=e=>(s.close(),n(o.error)),i.oncomplete=()=>{null==u?s.close():u.oncomplete=()=>s.close()}}},r.onerror=e=>n(r.error)}))}}mo.URL_SCHEME="indexeddb://";const go=e=>ht().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(mo.URL_SCHEME)?yo(e.slice(mo.URL_SCHEME.length)):null;function yo(e){return new mo(e)}function bo(e){return e.startsWith(mo.URL_SCHEME)?e.slice(mo.URL_SCHEME.length):e}ro.registerSaveRouter(go),ro.registerLoadRouter(go);class xo{constructor(){this.indexedDB=po()}async listModels(){return new Promise(((e,t)=>{const n=this.indexedDB.open(uo,lo);n.onupgradeneeded=()=>fo(n),n.onsuccess=()=>{const r=n.result,s=r.transaction(ho,"readonly"),a=s.objectStore(ho),i=a.getAll();i.onsuccess=()=>{const t={};for(const e of i.result)t[e.modelPath]=e.modelArtifactsInfo;e(t)},i.onerror=e=>(r.close(),t(i.error)),s.oncomplete=()=>r.close()},n.onerror=e=>t(n.error)}))}async removeModel(e){return e=bo(e),new Promise(((t,n)=>{const r=this.indexedDB.open(uo,lo);r.onupgradeneeded=()=>fo(r),r.onsuccess=()=>{const s=r.result,a=s.transaction(ho,"readwrite"),i=a.objectStore(ho),o=i.get(e);let u;o.onsuccess=()=>{if(null==o.result)return s.close(),n(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const r=i.delete(e),a=()=>{u=s.transaction(co,"readwrite");const r=u.objectStore(co),a=r.delete(e);a.onsuccess=()=>t(o.result.modelArtifactsInfo),a.onerror=e=>n(o.error)};r.onsuccess=a,r.onerror=e=>(a(),s.close(),n(o.error))}},o.onerror=e=>(s.close(),n(o.error)),a.oncomplete=()=>{null==u?s.close():u.oncomplete=()=>s.close()}},r.onerror=e=>n(r.error)}))}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const wo="/",vo="tensorflowjs_models",ko="info",Io="model_topology",No="weight_specs",So="weight_data",To="model_metadata";function $o(e){return{info:[vo,e,ko].join(wo),topology:[vo,e,Io].join(wo),weightSpecs:[vo,e,No].join(wo),weightData:[vo,e,So].join(wo),modelMetadata:[vo,e,To].join(wo)}}function Co(e){for(const t of Object.values(e))window.localStorage.removeItem(t)}function Eo(e){const t=e.split(wo);if(t.length<3)throw new Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join(wo)}function Ro(e){return e.startsWith(Ao.URL_SCHEME)?e.slice(Ao.URL_SCHEME.length):e}class Ao{constructor(e){if(!ht().getBool("IS_BROWSER")||"undefined"===typeof window||"undefined"===typeof window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=$o(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const n=JSON.stringify(e.modelTopology),r=JSON.stringify(e.weightSpecs),s=Ji(e),a=Mi.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(s)),this.LS.setItem(this.keys.topology,n),this.LS.setItem(this.keys.weightSpecs,r),this.LS.setItem(this.keys.weightData,Gi(a));const t={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:null!=e.signature?e.signature:void 0,userDefinedMetadata:null!=e.userDefinedMetadata?e.userDefinedMetadata:void 0,modelInitializer:null!=e.modelInitializer?e.modelInitializer:void 0,initializerSignature:null!=e.initializerSignature?e.initializerSignature:void 0,trainingConfig:null!=e.trainingConfig?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(t)),{modelArtifactsInfo:s}}catch(t){throw Co(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${s.modelTopologyBytes}, weightSpecsBytes=${s.weightSpecsBytes}, weightDataBytes=${s.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(null==e)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if("JSON"!==e.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(null==n)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=n;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==r)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=r;const s=this.LS.getItem(this.keys.modelMetadata);if(null!=s){const e=JSON.parse(s);t.format=e.format,t.generatedBy=e.generatedBy,t.convertedBy=e.convertedBy,null!=e.signature&&(t.signature=e.signature),null!=e.userDefinedMetadata&&(t.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(t.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(t.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(t.trainingConfig=e.trainingConfig)}const a=this.LS.getItem(this.keys.weightData);if(null==a)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=Hi(a),t}}Ao.URL_SCHEME="localstorage://";const Fo=e=>ht().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Ao.URL_SCHEME)?_o(e.slice(Ao.URL_SCHEME.length)):null;function _o(e){return new Ao(e)}ro.registerSaveRouter(Fo),ro.registerLoadRouter(Fo);class Do{constructor(){we(ht().getBool("IS_BROWSER"),(()=>"Current environment is not a web browser")),we("undefined"===typeof window||"undefined"!==typeof window.localStorage,(()=>"Current browser does not appear to support localStorage")),this.LS=window.localStorage}async listModels(){const e={},t=vo+wo,n=wo+ko;for(let r=0;r<this.LS.length;++r){const s=this.LS.key(r);if(s.startsWith(t)&&s.endsWith(n)){const t=Eo(s);e[t]=JSON.parse(this.LS.getItem(s))}}return e}async removeModel(e){e=Ro(e);const t=$o(e);if(null==this.LS.getItem(t.info))throw new Error(`Cannot find model at path '${e}'`);const n=JSON.parse(this.LS.getItem(t.info));return Co(t),n}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Oo="://";class Mo{constructor(){this.managers={}}static getInstance(){return null==Mo.instance&&(Mo.instance=new Mo),Mo.instance}static registerManager(e,t){we(null!=e,(()=>"scheme must not be undefined or null.")),e.endsWith(Oo)&&(e=e.slice(0,e.indexOf(Oo))),we(e.length>0,(()=>"scheme must not be an empty string."));const n=Mo.getInstance();we(null==n.managers[e],(()=>`A model store manager is already registered for scheme '${e}'.`)),n.managers[e]=t}static getManager(e){const t=Mo.getInstance().managers[e];if(null==t)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(Mo.getInstance().managers)}}function Lo(e){if(-1===e.indexOf(Oo))throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${Mo.getSchemes().join(",")}`);return{scheme:e.split(Oo)[0],path:e.split(Oo)[1]}}async function zo(e,t,n=!1){we(e!==t,(()=>`Old path and new path are the same: '${e}'`));const r=ro.getLoadHandlers(e);we(r.length>0,(()=>`Copying failed because no load handler is found for source URL ${e}.`)),we(r.length<2,(()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${e}.`));const s=r[0],a=ro.getSaveHandlers(t);we(a.length>0,(()=>`Copying failed because no save handler is found for destination URL ${t}.`)),we(a.length<2,(()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${t}.`));const i=a[0],o=Lo(e).scheme,u=Lo(e).path,l=o===Lo(e).scheme,c=await s.load();n&&l&&await Mo.getManager(o).removeModel(u);const h=await i.save(c);return n&&!l&&await Mo.getManager(o).removeModel(u),h.modelArtifactsInfo}async function Po(){const e=Mo.getSchemes(),t={};for(const n of e){const e=await Mo.getManager(n).listModels();for(const r in e){const s=n+Oo+r;t[s]=e[r]}}return t}async function Bo(e){const t=Lo(e),n=Mo.getManager(t.scheme);return n.removeModel(t.path)}async function Wo(e,t){const n=!1;return zo(e,t,n)}async function Vo(e,t){const n=!0;return zo(e,t,n)}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Uo{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){"undefined"!==typeof window&&ht().getBool("USE_SETTIMEOUTCUSTOM")?(this.functionRefs.push(e),setTimeout((()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")}),t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",(e=>{if(e.source===window&&e.data.name===this.messageName){e.stopPropagation();const t=this.functionRefs[e.data.index];t(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}}),!0))):setTimeout(e,t)}isTypedArray(e){return Ys(e)}}if(ht().get("IS_BROWSER")){ht().setPlatform("browser",new Uo);try{Mo.registerManager(Ao.URL_SCHEME,new Do)}catch(l7){}try{Mo.registerManager(mo.URL_SCHEME,new xo)}catch(l7){}}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Go={importFetch:()=>n(85817)};let Ho;class jo{constructor(){this.util=n(18590),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return null!=ht().global.fetch?ht().global.fetch(e,t):(null==Ho&&(Ho=Go.importFetch()),Ho(e,t))}now(){const e=process.hrtime();return 1e3*e[0]+e[1]/1e6}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return 0===e.length?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}}
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function qo(e,t="float32",n){return t=t||"float32",nt(e),new Pa(e,t,n)}
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Ko(e,t){const n=$i(e,"x","cast");if(!Pe(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if("string"===t&&"string"!==n.dtype||"string"!==t&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");const r={x:n},s={dtype:t};return gi.runKernel(Vt,r,s)}ht().get("IS_NODE")&&!ht().get("IS_BROWSER")&&ht().setPlatform("node",new jo);const Xo=Ri({cast_:Ko});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Yo(e){const t=$i(e,"x","clone","string_or_numeric"),n={x:t};return gi.runKernel(On,n)}const Jo=Ri({clone_:Yo});
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Zo(e,t=!1){console.log(e.toString(t))}
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
mi();const Qo={buffer:qo,cast:Xo,clone:Jo,print:Zo};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function eu(){ht().set("PROD",!0)}function tu(){ht().set("DEBUG",!0)}function nu(){ht().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function ru(e){ht().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function su(){gi.disposeVariables()}function au(){return gi}function iu(){return gi.memory()}function ou(e){return gi.profile(e)}function uu(e,t){return gi.tidy(e,t)}function lu(e){const t=ui(e);t.forEach((e=>e.dispose()))}function cu(e){return gi.keep(e)}function hu(e){return gi.time(e)}function pu(e){return gi.setBackend(e)}function du(){return gi.ready()}function fu(){return gi.backendName}function mu(e){gi.removeBackend(e)}function gu(e){return gi.findBackend(e)}function yu(e){return gi.findBackendFactory(e)}function bu(e,t,n=1){return gi.registerBackend(e,t,n)}function xu(){return gi.backend}function wu(e,t){ht().setPlatform(e,t)}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function vu(e,t){let n=$i(e,"a","add"),r=$i(t,"b","add");[n,r]=ai(n,r);const s={a:n,b:r};return gi.runKernel(vt,s)}Ga(Qo),Ha(ru);const ku=Ri({add_:vu});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Iu(e,t){let n=$i(e,"a","floorDiv"),r=$i(t,"b","floorDiv");[n,r]=ai(n,r);const s={a:n,b:r};return gi.runKernel(En,s)}const Nu=Ri({floorDiv_:Iu});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Su(e,t){let n=$i(e,"a","div"),r=$i(t,"b","div");if([n,r]=ai(n,r),"int32"===n.dtype&&"int32"===r.dtype)return Nu(n,r);const s={a:n,b:r},a={};return gi.runKernel(gn,s,a)}const Tu=Ri({div_:Su});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function $u(e,t){let n=$i(e,"a","mul"),r=$i(t,"b","mul");[n,r]=ai(n,r);const s={a:n,b:r};return gi.runKernel(mr,s)}const Cu=Ri({mul_:$u});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Eu(e){const t=$i(e,"x","sqrt","float32"),n={x:t};return gi.runKernel(ns,n)}const Ru=Ri({sqrt_:Eu});
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Au(e){const t=$i(e,"x","square"),n={};return gi.runKernel("Square",{x:t},n)}const Fu=Ri({square_:Au});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function _u(e){const t=$i(e,"x","zerosLike"),n={x:t};return gi.runKernel(Rs,n)}const Du=Ri({zerosLike_:_u});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Ou(e){return we(qe(e),(()=>"The f passed in grad(f) must be a function")),(t,n)=>{const r=$i(t,"x","tf.grad","string_or_numeric"),s=null!=n?$i(n,"dy","tf.grad"):null;return gi.tidy((()=>{const{value:t,grads:n}=gi.gradients((()=>e(r)),[r],s);return null!=s&&ve(t.shape,s.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),Wu(n),n[0]}))}}function Mu(e){return we(qe(e),(()=>"The f passed in grads(f) must be a function")),(t,n)=>{we(Array.isArray(t),(()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s"));const r=Ci(t,"args","tf.grads","string_or_numeric"),s=null!=n?$i(n,"dy","tf.grads"):null;return gi.tidy((()=>{const{value:t,grads:n}=gi.gradients((()=>e(...r)),r,s);return null!=s&&ve(t.shape,s.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),Wu(n),n}))}}function Lu(e){return we(qe(e),(()=>"The f passed in valueAndGrad(f) must be a function")),(t,n)=>{we(t instanceof ja,(()=>"The x passed in valueAndGrad(f)(x) must be a tensor")),we(null==n||n instanceof ja,(()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor"));const{grads:r,value:s}=gi.gradients((()=>e(t)),[t],n);return Wu(r),{grad:r[0],value:s}}}function zu(e){return we(qe(e),(()=>"The f passed in valueAndGrads(f) must be a function")),(t,n)=>{we(Array.isArray(t)&&t.every((e=>e instanceof ja)),(()=>"The args passed in valueAndGrads(f)(args) must be array of tensors")),we(null==n||n instanceof ja,(()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor"));const r=gi.gradients((()=>e(...t)),t,n);return null!=n&&ve(r.value.shape,n.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),Wu(r.grads),r}}function Pu(e,t){we(qe(e),(()=>"The f passed in variableGrads(f) must be a function")),we(null==t||Array.isArray(t)&&t.every((e=>e instanceof Ka)),(()=>"The varList passed in variableGrads(f, varList) must be an array of variables"));const n=null!=t;if(!n){t=[];for(const e in gi.registeredVariables)t.push(gi.registeredVariables[e])}const r=n?t.filter((e=>!e.trainable)):null,s=t.length;t=t.filter((e=>e.trainable)),we(t.length>0,(()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${s} variables is trainable.`));const a=!0,{value:i,grads:o}=gi.gradients(e,t,null,a);we(o.some((e=>null!=e)),(()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().")),we(0===i.rank,(()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i.rank} tensor`));const u={};return t.forEach(((e,t)=>{null!=o[t]&&(u[e.name]=o[t])})),null!=r&&r.forEach((e=>u[e.name]=null)),{value:i,grads:u}}function Bu(e){return gi.customGrad(e)}function Wu(e){const t=e.filter((e=>null==e)).length;if(t>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that\n    the f you passed encloses all operations that lead from x to y.")}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Vu(e,t){if((Ia(e)&&"string"!==t||Array.isArray(e))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&Ia(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");const n=[],r=[];return _i(e,n,r,t)}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Uu=new Map,Gu=new Map;class Hu{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class ju{constructor(){this.classNameMap={}}static getMap(){return null==ju.instance&&(ju.instance=new ju),ju.instance}static register(e){ju.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function qu(e,t,n){we(null!=e.className,(()=>"Class being registered does not have the static className property defined.")),we("string"===typeof e.className,(()=>"className is required to be a string, but got type "+typeof e.className)),we(e.className.length>0,(()=>"Class being registered has an empty-string as its className, which is disallowed.")),"undefined"===typeof t&&(t="Custom"),"undefined"===typeof n&&(n=e.className);const r=n,s=t+">"+r;return ju.register(e),Uu.set(s,e),Gu.set(e,s),e}function Ku(e){return Gu.has(e)?Gu.get(e):e.className}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Xu extends Hu{minimize(e,t=!1,n){const{value:r,grads:s}=this.computeGradients(e,n);if(null!=n){const e=n.map((e=>({name:e.name,tensor:s[e.name]})));this.applyGradients(e)}else this.applyGradients(s);return lu(s),t?r:(r.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return Pu(e,t)}dispose(){null!=this.iterations_&&lu(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:Vu(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(Xu,Symbol.hasInstance,{value:e=>null!=e.minimize&&null!=e.computeGradients&&null!=e.applyGradients});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Yu extends Xu{static get className(){return"Adadelta"}constructor(e,t,n=null){super(),this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==n&&(this.epsilon=gi.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);t.forEach(((t,n)=>{const r=gi.registeredVariables[t],s=!1;null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:`${t}/accum_grad`,variable:uu((()=>Du(r).variable(s)))}),null==this.accumulatedUpdates[n]&&(this.accumulatedUpdates[n]={originalName:`${t}/accum_var`,variable:uu((()=>Du(r).variable(s)))});const a=Array.isArray(e)?e[n].tensor:e[t];if(null==a)return;const i=this.accumulatedGrads[n].variable,o=this.accumulatedUpdates[n].variable;uu((()=>{const e=ku(Cu(i,this.rho),Cu(Fu(a),1-this.rho)),t=Cu(Tu(Ru(ku(o,this.epsilon)),Ru(ku(i,this.epsilon))),a),n=ku(Cu(o,this.rho),Cu(Fu(t),1-this.rho));i.assign(e),o.assign(n);const s=ku(Cu(t,-this.learningRate),r);r.assign(s)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(lu(this.accumulatedGrads.map((e=>e.variable))),lu(this.accumulatedUpdates.map((e=>e.variable))))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);const t=e.length/2,n=!1;this.accumulatedGrads=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedUpdates=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t["learningRate"],t["rho"],t["epsilon"])}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Ju(e,t,n){nt(e),n=n||je(t);const r={shape:e,value:t,dtype:n};return gi.runKernel(Tn,{},r)}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Zu extends Xu{static get className(){return"Adagrad"}constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);t.forEach(((t,n)=>{const r=gi.registeredVariables[t];if(null==this.accumulatedGrads[n]){const e=!1;this.accumulatedGrads[n]={originalName:`${t}/accumulator`,variable:uu((()=>Ju(r.shape,this.initialAccumulatorValue).variable(e)))}}const s=Array.isArray(e)?e[n].tensor:e[t];if(null==s)return;const a=this.accumulatedGrads[n].variable;uu((()=>{const e=ku(a,Fu(s));a.assign(e);const t=ku(Cu(Tu(s,Ru(ku(e,gi.backend.epsilon()))),-this.learningRate),r);r.assign(t)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&lu(this.accumulatedGrads.map((e=>e.variable)))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);const t=!1;this.accumulatedGrads=e.map((e=>({originalName:e.name,variable:e.tensor.variable(t)})))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t["learningRate"],t["initialAccumulatorValue"])}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Qu(e,t){let n=$i(e,"base","pow"),r=$i(t,"exp","pow");[n,r]=ai(n,r);const s={a:n,b:r};return gi.runKernel(Tr,s)}const el=Ri({pow_:Qu});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function tl(e,t){let n=$i(e,"a","sub"),r=$i(t,"b","sub");[n,r]=ai(n,r);const s={a:n,b:r};return gi.runKernel(xs,s)}const nl=Ri({sub_:tl});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class rl extends Xu{static get className(){return"Adam"}constructor(e,t,n,r=null){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],uu((()=>{this.accBeta1=Vu(t).variable(),this.accBeta2=Vu(n).variable()})),null==r&&(this.epsilon=gi.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);uu((()=>{const n=nl(1,this.accBeta1),r=nl(1,this.accBeta2);t.forEach(((t,s)=>{const a=gi.registeredVariables[t],i=!1;null==this.accumulatedFirstMoment[s]&&(this.accumulatedFirstMoment[s]={originalName:`${t}/m`,variable:uu((()=>Du(a).variable(i)))}),null==this.accumulatedSecondMoment[s]&&(this.accumulatedSecondMoment[s]={originalName:`${t}/v`,variable:uu((()=>Du(a).variable(i)))});const o=Array.isArray(e)?e[s].tensor:e[t];if(null==o)return;const u=this.accumulatedFirstMoment[s].variable,l=this.accumulatedSecondMoment[s].variable,c=ku(Cu(u,this.beta1),Cu(o,1-this.beta1)),h=ku(Cu(l,this.beta2),Cu(Fu(o),1-this.beta2)),p=Tu(c,n),d=Tu(h,r);u.assign(c),l.assign(h);const f=ku(Cu(Tu(p,ku(Ru(d),this.epsilon)),-this.learningRate),a);a.assign(f)})),this.accBeta1.assign(Cu(this.accBeta1,this.beta1)),this.accBeta2.assign(Cu(this.accBeta2,this.beta2))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&lu(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedSecondMoment&&lu(this.accumulatedSecondMoment.map((e=>e.variable)))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e),uu((()=>{this.accBeta1.assign(el(this.beta1,this.iterations_+1)),this.accBeta2.assign(el(this.beta2,this.iterations_+1))}));const t=e.length/2,n=!1;this.accumulatedFirstMoment=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedSecondMoment=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t["learningRate"],t["beta1"],t["beta2"],t["epsilon"])}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function sl(e){const t=$i(e,"x","abs");if("complex64"===t.dtype){const e={x:t};return gi.runKernel(jt,e)}{const e={x:t};return gi.runKernel(bt,e)}}const al=Ri({abs_:sl});
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function il(e,t){const n=e.length,r=[];for(let s=0;s<n;s++){const a=n-1-s,i=e[a]||1,o=t[t.length-1-s]||1;o>1&&1===i&&r.unshift(a)}return r}function ol(e,t){const n=[];for(let r=0;r<t.length;r++){const s=e[e.length-r-1],a=t.length-r-1,i=t[a];(null==s||1===s&&i>1)&&n.unshift(a)}return n}function ul(e,t){const n=Math.max(e.length,t.length),r=new Array(n);for(let s=0;s<n;s++){let a=e[e.length-s-1];null==a&&(a=1);let i=t[t.length-s-1];if(null==i&&(i=1),1===a)r[n-s-1]=i;else if(1===i)r[n-s-1]=a;else{if(a!==i){const n=`Operands could not be broadcast together with shapes ${e} and ${t}.`;throw Error(n)}r[n-s-1]=a}}return r}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ll(e,t){let n=$i(e,"a","maximum"),r=$i(t,"b","maximum");[n,r]=ai(n,r),"bool"===n.dtype&&(n=Xo(n,"int32"),r=Xo(r,"int32")),ul(n.shape,r.shape);const s={a:n,b:r};return gi.runKernel(rr,s)}const cl=Ri({maximum_:ll});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class hl extends Xu{static get className(){return"Adamax"}constructor(e,t,n,r=null,s=0){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.decay=s,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],uu((()=>{this.iteration=Vu(0).variable(),this.accBeta1=Vu(t).variable()})),null==r&&(this.epsilon=gi.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);uu((()=>{const n=nl(1,this.accBeta1),r=Tu(-this.learningRate,ku(Cu(this.iteration,this.decay),1));t.forEach(((t,s)=>{const a=gi.registeredVariables[t],i=!1;null==this.accumulatedFirstMoment[s]&&(this.accumulatedFirstMoment[s]={originalName:`${t}/m`,variable:Du(a).variable(i)}),null==this.accumulatedWeightedInfNorm[s]&&(this.accumulatedWeightedInfNorm[s]={originalName:`${t}/v`,variable:Du(a).variable(i)});const o=Array.isArray(e)?e[s].tensor:e[t];if(null==o)return;const u=this.accumulatedFirstMoment[s].variable,l=this.accumulatedWeightedInfNorm[s].variable,c=ku(Cu(u,this.beta1),Cu(o,1-this.beta1)),h=Cu(l,this.beta2),p=al(o),d=cl(h,p);u.assign(c),l.assign(d);const f=ku(Cu(Tu(r,n),Tu(c,ku(d,this.epsilon))),a);a.assign(f)})),this.iteration.assign(ku(this.iteration,1)),this.accBeta1.assign(Cu(this.accBeta1,this.beta1))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&lu(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedWeightedInfNorm&&lu(this.accumulatedWeightedInfNorm.map((e=>e.variable)))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t["learningRate"],t["beta1"],t["beta2"],t["epsilon"],t["decay"])}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class pl extends Xu{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);t.forEach(((t,n)=>{const r=Array.isArray(e)?e[n].tensor:e[t];if(null==r)return;const s=gi.registeredVariables[t];uu((()=>{const e=ku(Cu(this.c,r),s);s.assign(e)}))})),this.incrementIterations()}setLearningRate(e){this.learningRate=e,null!=this.c&&this.c.dispose(),this.c=cu(Vu(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),0!==e.length)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t["learningRate"])}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class dl extends pl{static get className(){return"Momentum"}constructor(e,t,n=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=Vu(this.momentum)}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);t.forEach(((t,n)=>{const r=gi.registeredVariables[t];if(null==this.accumulations[n]){const e=!1;this.accumulations[n]={originalName:`${t}/momentum`,variable:uu((()=>Du(r).variable(e)))}}const s=this.accumulations[n].variable,a=Array.isArray(e)?e[n].tensor:e[t];null!=a&&uu((()=>{let e;const t=ku(Cu(this.m,s),a);e=this.useNesterov?ku(Cu(this.c,ku(a,Cu(t,this.m))),r):ku(Cu(this.c,t),r),s.assign(t),r.assign(e)}))})),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&lu(this.accumulations.map((e=>e.variable)))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);const t=!1;this.accumulations=e.map((e=>({originalName:e.name,variable:e.tensor.variable(t)})))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t["learningRate"],t["momentum"],t["useNesterov"])}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class fl extends Xu{static get className(){return"RMSProp"}constructor(e,t=.9,n=0,r=null,s=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=s,null==r&&(this.epsilon=gi.backend.epsilon()),null==e)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);t.forEach(((t,n)=>{const r=gi.registeredVariables[t],s=!1;null==this.accumulatedMeanSquares[n]&&(this.accumulatedMeanSquares[n]={originalName:`${t}/rms`,variable:uu((()=>Du(r).variable(s)))}),null==this.accumulatedMoments[n]&&(this.accumulatedMoments[n]={originalName:`${t}/momentum`,variable:uu((()=>Du(r).variable(s)))}),null==this.accumulatedMeanGrads[n]&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:`${t}/mg`,variable:uu((()=>Du(r).variable(s)))});const a=Array.isArray(e)?e[n].tensor:e[t];if(null==a)return;const i=this.accumulatedMeanSquares[n].variable,o=this.accumulatedMoments[n].variable;uu((()=>{const e=ku(Cu(i,this.decay),Cu(Fu(a),1-this.decay));if(this.centered){const t=this.accumulatedMeanGrads[n].variable,s=ku(Cu(t,this.decay),Cu(a,1-this.decay)),u=Tu(Cu(a,this.learningRate),Ru(nl(e,ku(Fu(s),this.epsilon)))),l=ku(Cu(o,this.momentum),u);i.assign(e),t.assign(s),o.assign(l);const c=nl(r,l);r.assign(c)}else{const e=ku(Cu(i,this.decay),Cu(Fu(a),1-this.decay)),t=ku(Cu(o,this.momentum),Tu(Cu(a,this.learningRate),Ru(ku(e,this.epsilon))));i.assign(e),o.assign(t);const n=nl(r,t);r.assign(n)}}))})),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&lu(this.accumulatedMeanSquares.map((e=>e.variable))),null!=this.accumulatedMeanGrads&&this.centered&&lu(this.accumulatedMeanGrads.map((e=>e.variable))),null!=this.accumulatedMoments&&lu(this.accumulatedMoments.map((e=>e.variable)))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2,n=!1;this.accumulatedMeanSquares=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedMoments=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.centered&&(this.accumulatedMeanGrads=e.slice(2*t,3*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t["learningRate"],t["decay"],t["momentum"],t["epsilon"],t["centered"])}}
/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const ml=[Yu,Zu,rl,hl,dl,fl,pl];function gl(){for(const e of ml)qu(e)}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const yl="model",bl=".json",xl=".weights.bin";function wl(e){return new Promise((e=>setTimeout(e))).then(e)}class vl{constructor(e){if(!ht().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(vl.URL_SCHEME)&&(e=e.slice(vl.URL_SCHEME.length)),null!=e&&0!==e.length||(e=yl),this.modelJsonFileName=e+bl,this.weightDataFileName=e+xl}async save(e){if("undefined"===typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=Mi.join(e.weightData),n=window.URL.createObjectURL(new Blob([t],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const t=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],r=Ki(e,t),s=window.URL.createObjectURL(new Blob([JSON.stringify(r)],{type:"application/json"})),a=null==this.modelJsonAnchor?document.createElement("a"):this.modelJsonAnchor;if(a.download=this.modelJsonFileName,a.href=s,await wl((()=>a.dispatchEvent(new MouseEvent("click")))),null!=e.weightData){const e=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;e.download=this.weightDataFileName,e.href=n,await wl((()=>e.dispatchEvent(new MouseEvent("click"))))}return{modelArtifactsInfo:Ji(e)}}}}vl.URL_SCHEME="downloads://";class kl{constructor(e){if(null==e||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise(((e,t)=>{const n=new FileReader;n.onload=n=>{const r=JSON.parse(n.target.result),s=r.modelTopology;if(null==s)return void t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));const a=r.weightsManifest;if(null==a)return void t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));if(0===this.weightsFiles.length)return void e({modelTopology:s});const i=Yi(r,(e=>this.loadWeights(e)));e(i)},n.onerror=e=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),n.readAsText(this.jsonFile)}))}loadWeights(e){const t=[],n=[];for(const a of e)t.push(...a.weights),n.push(...a.paths);const r=this.checkManifestAndWeightFiles(e),s=n.map((e=>this.loadWeightsFile(e,r[e])));return Promise.all(s).then((e=>[t,e]))}loadWeightsFile(e,t){return new Promise(((n,r)=>{const s=new FileReader;s.onload=e=>{const t=e.target.result;n(t)},s.onerror=t=>r(`Failed to weights data from file of path '${e}'.`),s.readAsArrayBuffer(t)}))}checkManifestAndWeightFiles(e){const t=[],n=this.weightsFiles.map((e=>qi(e.name))),r={};for(const s of e)s.paths.forEach((e=>{const s=qi(e);if(-1!==t.indexOf(s))throw new Error(`Duplicate file basename found in weights manifest: '${s}'`);if(t.push(s),-1===n.indexOf(s))throw new Error(`Weight file with basename '${s}' is not provided.`);r[e]=this.weightsFiles[n.indexOf(s)]}));if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return r}}const Il=e=>ht().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(vl.URL_SCHEME)?Nl(e.slice(vl.URL_SCHEME.length)):null;function Nl(e="model"){return new vl(e)}function Sl(e){return new kl(e)}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Tl(e,t,n,r){i(e),n=null==n?0:n,r=null==r?1:r,o(n,r);let s=0;const a=a=>(a.then((a=>{const i=n+ ++s/e.length*(r-n);return t(i),a})),a);function i(e){we(null!=e&&Array.isArray(e)&&e.length>0,(()=>"promises must be a none empty array"))}function o(e,t){we(e>=0&&e<=1,(()=>`Progress fraction must be in range [0, 1], but got startFraction ${e}`)),we(t>=0&&t<=1,(()=>`Progress fraction must be in range [0, 1], but got endFraction ${t}`)),we(t>=e,(()=>`startFraction must be no more than endFraction, but got startFraction ${e} and endFraction ${t}`))}return Promise.all(e.map(a))}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
async function $l(e,t){null==t&&(t={});const n=null==t.fetchFunc?ht().platform.fetch:t.fetchFunc,r=e.map((e=>n(e,t.requestInit,{isBinary:!0}))),s=0,a=.5,i=null==t.onProgress?await Promise.all(r):await Tl(r,t.onProgress,s,a),o=i.map((e=>e.arrayBuffer())),u=.5,l=1,c=null==t.onProgress?await Promise.all(o):await Tl(o,t.onProgress,u,l);return c}async function Cl(e,t="",n,r){const s=e=>$l(e,{requestInit:r}),a=El(s);return a(e,t,n)}function El(e){return async(t,n="",r)=>{const s=t.map((()=>!1)),a={},i=null!=r?r.map((()=>!1)):[],o=[];if(t.forEach(((e,t)=>{let n=0;e.weights.forEach((e=>{const u="quantization"in e?e.quantization.dtype:e.dtype,l=Oi[u]*Ie(e.shape),c=()=>{s[t]=!0,null==a[t]&&(a[t]=[]),a[t].push({manifestEntry:e,groupOffset:n,sizeBytes:l})};null!=r?r.forEach(((t,n)=>{t===e.name&&(c(),i[n]=!0)})):c(),o.push(e.name),n+=l}))})),!i.every((e=>e))){const e=r.filter(((e,t)=>!i[t]));throw new Error(`Could not find weights in manifest with names: ${e.join(", ")}. \nManifest JSON has weights with names: ${o.join(", ")}.`)}const u=s.reduce(((e,t,n)=>(t&&e.push(n),e)),[]),l=[];u.forEach((e=>{t[e].paths.forEach((e=>{const t=n+(n.endsWith("/")?"":"/")+e;l.push(t)}))}));const c=await e(l),h={};let p=0;return u.forEach((e=>{const n=t[e].paths.length,r=new Mi(c.slice(p,p+n)),s=a[e];s.forEach((e=>{const t=r.slice(e.groupOffset,e.groupOffset+e.sizeBytes),n=Bi(t,[e.manifestEntry]);for(const r in n)h[r]=n[r]})),p+=n})),h}}ro.registerSaveRouter(Il);
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Rl="application/octet-stream",Al="application/json";class Fl{constructor(e,t){if(this.DEFAULT_METHOD="POST",null==t&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.onProgress=t.onProgress,this.weightUrlConverter=t.weightUrlConverter,null!=t.fetchFunc?(we("function"===typeof t.fetchFunc,(()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)")),this.fetch=t.fetchFunc):this.fetch=ht().platform.fetch,we(null!=e&&e.length>0,(()=>"URL path for http must not be null, undefined or empty.")),Array.isArray(e)&&we(2===e.length,(()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`)),this.path=e,null!=t.requestInit&&null!=t.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{}}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const n=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],r=Ki(e,n);if(t.body.append("model.json",new Blob([JSON.stringify(r)],{type:Al}),"model.json"),null!=e.weightData){const n=Mi.join(e.weightData);t.body.append("model.weights.bin",new Blob([n],{type:Rl}),"model.weights.bin")}const s=await this.fetch(this.path,t);if(s.ok)return{modelArtifactsInfo:Ji(e),responses:[s]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${s.status}.`)}async load(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch(s){let e=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?e+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":e+=" Please make sure the server is serving valid JSON for this request.",new Error(e)}const n=t.modelTopology,r=t.weightsManifest;if(null==n&&null==r)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return Yi(t,(e=>this.loadWeights(e)))}async loadWeights(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[n,r]=_l(t),s=this.weightPathPrefix||n,a=Zi(e),i=[],o=[];for(const l of e)for(const e of l.paths)null!=this.weightUrlConverter?o.push(this.weightUrlConverter(e)):i.push(s+e+r);this.weightUrlConverter&&i.push(...await Promise.all(o));const u=await $l(i,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress});return[a,u]}}function _l(e){const t=e.lastIndexOf("/"),n=e.lastIndexOf("?"),r=e.substring(0,t),s=n>t?e.substring(n):"";return[r+"/",s]}function Dl(e){return null!=e.match(Fl.URL_SCHEME_REGEX)}Fl.URL_SCHEME_REGEX=/^https?:\/\//;const Ol=(e,t)=>{if("undefined"===typeof fetch&&(null==t||null==t.fetchFunc))return null;{let n=!0;if(n=Array.isArray(e)?e.every((e=>Dl(e))):Dl(e),n)return Ml(e,t)}return null};function Ml(e,t){return new Fl(e,t)}function Ll(e,t){return Ml(e,t)}ro.registerSaveRouter(Ol),ro.registerLoadRouter(Ol);
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class zl{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}}class Pl{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}}class Bl{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}}function Wl(e,t,n,r){const s=arguments;return new Bl(Vl(...s))}function Vl(e,t,n,r){if(1===arguments.length){const t=null!=e.modelTopology||null!=e.weightSpecs;return t?new zl(e):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new zl({modelTopology:e}))}return console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new zl({modelTopology:e,weightSpecs:t,weightData:n,trainingConfig:r})}function Ul(e){return new Pl(e)}function Gl(e){return new Pl(e)}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Hl(e,t,n=!1,r=!1){let s=$i(e,"a","matMul"),a=$i(t,"b","matMul");[s,a]=ai(s,a);const i={a:s,b:a},o={transposeA:n,transposeB:r};return gi.runKernel(Mt,i,o)}const jl=Ri({matMul_:Hl});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ql(e,t,n=1,r=0,s="int32"){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);const a=$i(e,"indices","oneHot","int32"),i={indices:a},o={dtype:s,depth:t,onValue:n,offValue:r};return gi.runKernel(kr,i,o)}const Kl=Ri({oneHot_:ql});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Xl(e){const t=$i(e,"input","imag"),n={input:t};return gi.runKernel(Ln,n)}const Yl=Ri({imag_:Xl});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Jl(e){const t=$i(e,"x","neg"),n={x:t};return gi.runKernel(gr,n)}const Zl=Ri({neg_:Jl});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Ql(e){const t=$i(e,"input","real"),n={input:t};return gi.runKernel(_r,n)}const ec=Ri({real_:Ql});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function tc(e,t,n){const r=$i(e,"x","transpose");if(null==t&&(t=r.shape.map(((e,t)=>t)).reverse()),we(r.rank===t.length,(()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${t}.`)),t.forEach((e=>{we(e>=0&&e<r.rank,(()=>"All entries in 'perm' must be between 0 and "+(r.rank-1)+` but got ${t}`))})),r.rank<=1)return r.clone();const s={x:r},a={perm:t};return"complex64"===r.dtype?uu((()=>{let e=ec(r),t=Yl(r);return e=gi.runKernel(Ss,{x:e},a),t=gi.runKernel(Ss,{x:t},a),n&&(t=Zl(t)),Fi(e,t)})):gi.runKernel(Ss,s,a)}const nc=Ri({transpose_:tc});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function rc(e,t,n){const r=$i(e,"labels","confusionMatrix"),s=$i(t,"predictions","confusionMatrix");we(null==n||n>0&&Number.isInteger(n),(()=>`If provided, numClasses must be a positive integer, but got ${n}`)),we(1===r.rank,(()=>`Expected the rank of labels to be 1, but got ${r.rank}`)),we(1===s.rank,(()=>`Expected the rank of predictions to be 1, but got ${s.rank}`)),we(r.shape[0]===s.shape[0],(()=>`Mismatch in the number of examples: ${r.shape[0]} vs. ${s.shape[0]}. Labels and predictions should have the same number of elements.`)),we(n>0&&Number.isInteger(n),(()=>`numClasses is required to be a positive integer, but got ${n}`));const a=Kl(Xo(r,"int32"),n),i=Kl(Xo(s,"int32"),n),o=nc(a),u=jl(o,i);return Xo(u,"int32")}const sc=Ri({confusionMatrix_:rc});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ac(e,t,n){if(ke(e),null!=t&&3!==t.length)throw new Error("tensor3d() requires shape to have three numbers");const r=Ni(e,n);if(3!==r.length&&1!==r.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return _i(e,t,r,n)}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let ic,oc=!1;function uc(e,t=3){if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==e)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,r=!1,s=!1,a=!1,i=!1,o=!1;if(e.data instanceof Uint8Array)n=!0;else if("undefined"!==typeof ImageData&&e instanceof ImageData)r=!0;else if("undefined"!==typeof HTMLVideoElement&&e instanceof HTMLVideoElement)s=!0;else if("undefined"!==typeof HTMLImageElement&&e instanceof HTMLImageElement)a=!0;else if(null!=e.getContext)i=!0;else{if(!("undefined"!==typeof ImageBitmap&&e instanceof ImageBitmap))throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${e.constructor.name}`);o=!0}const u=Ws(Fs,gi.backendName);if(null!=u){const n={pixels:e},r={numChannels:t};return gi.runKernel(Fs,n,r)}const[l,c]=s?[e.videoWidth,e.videoHeight]:[e.width,e.height];let h,p;if(i)h=e.getContext("2d").getImageData(0,0,l,c).data;else if(r||n)h=e.data;else if(a||s||o){if(null==ic)if("undefined"===typeof document){if("undefined"===typeof OffscreenCanvas||"undefined"===typeof OffscreenCanvasRenderingContext2D)throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");ic=new OffscreenCanvas(1,1).getContext("2d")}else ic=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});ic.canvas.width=l,ic.canvas.height=c,ic.drawImage(e,0,0,l,c),h=ic.getImageData(0,0,l,c).data}if(4===t)p=new Int32Array(h);else{const e=l*c;p=new Int32Array(e*t);for(let n=0;n<e;n++)for(let e=0;e<t;++e)p[n*t+e]=h[4*n+e]}const d=[c,l,t];return ac(p,d,"int32")}function lc(e){return null!=e&&e.data instanceof Uint8Array}function cc(){return"undefined"!==typeof window&&"undefined"!==typeof ImageBitmap&&window.hasOwnProperty("createImageBitmap")}function hc(e){return null!=e&&0!==e.width&&0!==e.height}function pc(e){return cc()&&!(e instanceof ImageBitmap)&&hc(e)&&!lc(e)}async function dc(e,t=3){let n=null;if(ht().getBool("WRAP_TO_IMAGEBITMAP")&&pc(e)){let t;try{t=await createImageBitmap(e,{premultiplyAlpha:"none"})}catch(r){t=null}n=null!=t&&t.width===e.width&&t.height===e.height?t:e}else n=e;return uc(n,t)}function fc(e){if(2!==e.rank&&3!==e.rank)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${e.rank}.`);const t=2===e.rank?1:e.shape[2];if(t>4||2===t)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${t}`);if("float32"!==e.dtype&&"int32"!==e.dtype)throw new Error(`Unsupported type for toPixels: ${e.dtype}. Please use float32 or int32 tensors.`)}function mc(e){const t=(null===e||void 0===e?void 0:e.alpha)||1;if(t>1||t<0)throw new Error(`Alpha value ${t} is suppoed to be in range [0 - 1].`)}async function gc(e,t){let n=$i(e,"img","toPixels");if(!(e instanceof ja)){const e=n;n=Xo(e,"int32"),e.dispose()}fc(n);const[r,s]=n.shape.slice(0,2),a=2===n.rank?1:n.shape[2],i=await n.data(),o="float32"===n.dtype?255:1,u=new Uint8ClampedArray(s*r*4);for(let l=0;l<r*s;++l){const e=[0,0,0,255];for(let r=0;r<a;r++){const t=i[l*a+r];if("float32"===n.dtype){if(t<0||t>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${t}.`)}else if("int32"===n.dtype&&(t<0||t>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${t}.`);1===a?(e[0]=t*o,e[1]=t*o,e[2]=t*o):e[r]=t*o}const t=4*l;u[t+0]=Math.round(e[0]),u[t+1]=Math.round(e[1]),u[t+2]=Math.round(e[2]),u[t+3]=Math.round(e[3])}if(null!=t){if(!oc){const e=Ws(mn,gi.backendName);null!=e&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),oc=!0)}t.width=s,t.height=r;const e=t.getContext("2d"),n=new ImageData(u,s,r);e.putImageData(n,0,0)}return n!==e&&n.dispose(),u}function yc(e,t,n){let r=$i(e,"img","draw");if(!(e instanceof ja)){const e=r;r=Xo(e,"int32"),e.dispose()}fc(r),mc(null===n||void 0===n?void 0:n.imageOptions);const s={image:r},a={canvas:t,options:n};gi.runKernel(mn,s,a)}const bc=Ri({fromPixels_:uc});function xc(e,t){const n=e.shape.length,r=t.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if("int32"!==t.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[r-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[r-1]} vs. ${n}`);if(0===Ie(e.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);const s=t.shape,a=s[s.length-1];let i=1;for(let h=0;h<s.length-1;++h)i*=s[h];const o=e.shape,u=s.slice();u.pop();let l=1;for(let h=a;h<n;++h)l*=o[h],u.push(o[h]);const c=[...Xe(e.shape).map((e=>e/l)),1].slice(0,a);return[u,i,l,c]}function wc(e,t,n){const r=t.rank>1?t.shape[t.rank-1]:1,s=t.rank>1?t.rank-1:1,a=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${r}, and batchDim: ${s}.`;if(n.rank<s)throw new Error(a+` update.rank < ${s}. `);if(e.length<r+(n.rank-s))throw new Error(a+` Output shape length < ${r+(n.rank-s)}`);if(n.rank!==s+e.length-r)throw new Error(a+" update.rank != "+(s+e.length-r));for(let i=0;i<s;++i)if(n.shape[i]!==t.shape[i])throw new Error(a+` updates.shape[${i}] (${n.shape[i]}) != indices.shape[${i}] (${t.shape[i]}).`);for(let i=0;i<n.rank-s;++i)if(n.shape[i+s]!==e[i+r])throw new Error(a+` updates.shape[${i+s}] (${n.shape[i+s]}) != shape[${i+s}] (${e[i+s]})`)}function vc(e,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if("int32"!==t.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(0===n.length){if(0===t.size)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(0===e.size)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}wc(n,t,e)}function kc(e,t,n){const r=t.shape.length,s=r>1?t.shape[r-1]:1,a=n.length;let i=1;for(let h=s;h<a;++h)i*=n[h];const o=s<1?1:s,u=Ie(t.shape)/o,l=[...Xe(n.slice(0,s)),1],c=Ie(n);return{sliceRank:s,numUpdates:u,sliceSize:i,strides:l,outputSize:c}}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Ic=-2,Nc=-1;function Sc(e,t,n){const r=e.shape.length;we(r===t.length,(()=>`Error in slice${r}D: Length of begin ${t} must match the rank of the array (${r}).`)),we(r===n.length,(()=>`Error in slice${r}D: Length of size ${n} must match the rank of the array (${r}).`));for(let s=0;s<r;++s)we(t[s]+n[s]<=e.shape[s],(()=>`Error in slice${r}D: begin[${s}] + size[${s}] (${t[s]+n[s]}) would overflow input.shape[${s}] (${e.shape[s]})`))}function Tc(e){const t=[];let n=0;while(e>0)1&e&&t.push(n),e/=2,n++;return t}function $c(e,t,n){const r=[];for(let s=0;s<e.length;s++)r[s]=Math.ceil((t[s]-e[s])/n[s]);return r}function Cc(e,t,n,r){const s=[...e];for(let a=s.length;a<r.length;a++)s.push(1);for(let a=0;a<n;a++)0===a?s[t]=1:(s.splice(t,0,1),s.pop());return s}function Ec(e,t,n){return n<=e?n:n-(t-1)}function Rc(e,t){const n=[];for(let r=0;r<e;r++)n.push(t+r);return n}function Ac(e,t,n,r,s,a,i,o,u){const l=e.length;let c=new Array(l),h=new Array(l),p=new Array(l);if(t.length&&n>0){const u=t[0],l=n+1;c=Fc(i,u,l,r,e),h=_c(o,u,l,s,e),p=Cc(a,u,l,e)}else for(let d=0;d<l;d++)c[d]=Oc(i,r,a,e,d,u),h[d]=Mc(o,s,a,e,d,u),p[d]=Dc(a,d,u);return{begin:c,end:h,strides:p}}function Fc(e,t,n,r,s){const a=[...s],i=Rc(n,t);for(let o=0;o<a.length;o++)if(i.indexOf(o)>-1)a[o]=0;else{const s=Ec(t,n,o);let i=r[s];e&1<<s&&(i=0),a[o]=i}return a}function _c(e,t,n,r,s){const a=[...s],i=Rc(n,t);for(let o=0;o<a.length;o++)if(i.indexOf(o)>-1)a[o]=Number.MAX_SAFE_INTEGER;else{const s=Ec(t,n,o);let i=r[s];e&1<<s&&(i=Number.MAX_SAFE_INTEGER),a[o]=i}for(let o=0;o<a.length;o++){const e=s[o];a[o]<0&&(a[o]+=e),a[o]=fe(0,a[o],s[o])}return a}function Dc(e,t,n){let r=e[t];return(n&1<<t||null==r)&&(r=1),r}function Oc(e,t,n,r,s,a){let i=t[s];const o=n[s]||1;(e&1<<s||a&1<<s||null==i)&&(i=o>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const u=r[s];return i<0&&(i+=u),i=fe(0,i,u-1),i}function Mc(e,t,n,r,s,a){let i=t[s];const o=n[s]||1;(e&1<<s||a&1<<s||null==i)&&(i=o>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const u=r[s];return i<0&&(i+=u),i=o>0?fe(0,i,u):fe(-1,i,u-1),i}function Lc(e,t,n){let r=n.length;for(let s=0;s<n.length;s++)if(n[s]>1){r=s;break}for(let s=r+1;s<n.length;s++)if(t[s]>0||n[s]!==e[s])return!1;return!0}function zc(e,t){let n=e.length>0?e[e.length-1]:1;for(let r=0;r<e.length-1;r++)n+=e[r]*t[r];return n}function Pc(e,t,n){let r;const s=e.shape.length;let a;return r="number"===typeof t?[t,...new Array(s-1).fill(0)]:t.length<s?t.concat(new Array(s-t.length).fill(0)):t.slice(),r.forEach((e=>{we(-1!==e,(()=>"slice() does not support negative begin indexing."))})),a=null==n?new Array(s).fill(-1):"number"===typeof n?[n,...new Array(s-1).fill(-1)]:n.length<s?n.concat(new Array(s-n.length).fill(-1)):n,a=a.map(((t,n)=>t>=0?t:(we(-1===t,(()=>`Negative size values should be exactly -1 but got ${t} for the slice() size at index ${n}.`)),e.shape[n]-r[n]))),[r,a]}function Bc(e,t,n,r,s,a,i,o,u){let l;if(null==r?(l=new Array(t.length),l.fill(1)):l=r,null!=i&&0!==(i&i-1))throw new Error("Multiple ellipses in slice is not allowed.");let c=!1;const h={dims:l.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:l.slice(),beginMask:s,endMask:a,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:u};for(let x=0;x<h.dims;x++)c&&0!==(1<<x&o)&&h.numAddAxisAfterEllipsis++,1<<x&i&&(c=!0);c||(h.ellipsisMask|=1<<h.dims,h.dims++);const p={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};Wc(h,p);let d=!0,f=!0,m=!0;const g=[],y=[];for(let x=0;x<e.length;++x){if(0===p.strides[x])throw Error(`strides[${x}] must be non-zero`);const t=!!(p.shrinkAxisMask&1<<x),n=e[x];if(-1===n){g.push(t?1:-1);continue}const r=[p.beginMask&1<<x,p.endMask&1<<x],s=[p.strides[x]>0?0:-1,p.strides[x]>0?n:n-1];if(t&&p.strides[x]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&1===p.strides[x];const a=!!(p.beginMask&1<<x&&p.endMask&1<<x);if(p.beginValid&&p.endValid){if(t){const e=p.begin[x]<0?n+p.begin[x]:p.begin[x];if(p.begin[x]=e,p.end[x]=p.begin[x]+1,e<0||e>=n)throw Error(`slice index ${p.begin[x]} of dimension ${x} out of bounds.`)}else p.begin[x]=Vc(p.begin[x],0,p.strides[x],n,r,s),p.end[x]=Vc(p.end[x],1,p.strides[x],n,r,s);const e=1===p.strides[x]&&0===p.begin[x]&&p.end[x]===n;d=d&&e,f=f&&(0===x&&1===p.strides[x]||e)}else d=d&&1===p.strides[x]&&a,f=f&&(0===x&&1===p.strides[x]||a);let i,o=!1;if(p.beginValid&&p.endValid?(i=p.end[x]-p.begin[x],o=!0):t?(i=1,o=!0):a&&n>=0&&(i=p.strides[x]<0?-n:n,o=!0),o){let e;e=0===i||i<0!==p.strides[x]<0?0:Math.trunc(i/p.strides[x])+(i%p.strides[x]!==0?1:0),g.push(e)}else g.push(-1)}for(let x=0;x<p.finalShapeGatherIndices.length;++x){const e=p.finalShapeGatherIndices[x];e>=0?y.push(g[e]):e===Ic&&y.push(1)}const b=y.filter(((e,t)=>p.finalShapeGatherIndices[t]!==Ic));return{finalShapeSparse:b,finalShape:y,isIdentity:d,sliceDim0:f,isSimpleSlice:m,begin:p.begin,end:p.end,strides:p.strides}}function Wc(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=null!=e.begin,t.endValid=null!=e.end,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let r=0;r<e.dims;r++)if(1<<r&e.ellipsisMask){const s=Math.min(t.dims-(e.dims-r)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<s;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=r}else if(1<<r&e.newAxisMask)t.finalShapeGatherIndices.push(Ic),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${t.dims} dims, ${t.begin.length}.`);null!=e.begin&&(t.begin[n]=e.begin[r]),null!=e.end&&(t.end[n]=e.end[r]),t.strides[n]=e.strides[r],e.beginMask&1<<r&&(t.beginMask|=1<<n),e.endMask&1<<r&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<r?(t.finalShapeGatherIndices.push(Nc),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(r)),t.inputShapeGatherIndicesSparse[n]=r,n++}}function Vc(e,t,n,r,s,a){if(s[t])return n>0?a[t]:a[t+1&1];{const t=e<0?r+e:e;return t<a[0]?a[0]:t>a[1]?a[1]:t}}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Uc=.001,Gc=.1;function Hc(e,t,n){return null==n&&(n=jc()),qc(e,t,((e,t)=>Jc(e,t,n)))}function jc(){return 32===gi.backend.floatPrecision()?Uc:Gc}function qc(e,t,n){let r=!0;if((Ia(e)||Ia(t))&&(r=!1),Ia(e)&&Ia(t)&&(r=!0),r){const n=e.constructor.name,r=t.constructor.name;if(n!==r)throw new Error(`Arrays are of different type. Actual: ${n}. Expected: ${r}`)}if(Array.isArray(e)&&Array.isArray(t)){const n=Ni(e),r=Ni(t);if(!Te(n,r))throw new Error(`Arrays have different shapes. Actual: [${n}]. Expected: [${r}]`)}const s=Ia(e)?e:Na(e),a=Ia(t)?t:Na(t);if(s.length!==a.length)throw new Error(`Arrays have different lengths actual: ${s.length} vs expected: ${a.length}.\nActual:   ${s}.\nExpected: ${a}.`);for(let i=0;i<a.length;++i){const e=s[i],t=a[i];if(!n(e,t))throw new Error(`Arrays differ: actual[${i}] = ${e}, expected[${i}] = ${t}.\nActual:   ${s}.\nExpected: ${a}.`)}"undefined"!==typeof expect&&expect().nothing()}function Kc(e,t){e().then((()=>t.fail()),(()=>t())),"undefined"!==typeof expect&&expect().nothing()}function Xc(e,t){const n="string"===typeof t||"number"===typeof t||"boolean"===typeof t?[t]:t;return Ue(e)||Ue(e[0])||Ue(t)||Ue(t[0])?qc(e,n,((e,t)=>e==t)):qc(e,t,((e,t)=>Jc(e,t,0)))}function Yc(e,t,n){if(null==n&&(n=jc()),!Jc(e,t,n))throw new Error(`Numbers differ: actual === ${e}, expected === ${t}`);"undefined"!==typeof expect&&expect().nothing()}function Jc(e,t,n){return!isFinite(e)&&!isFinite(t)||!(isNaN(e)||isNaN(t)||Math.abs(e-t)>n)}function Zc(e,t,n){for(let r=0;r<e.length;r++)if(e[r]<t||e[r]>n)throw new Error(`Value out of range:${e[r]} low: ${t}, high: ${n}`)}function Qc(e,t){const n=new Float32Array(e),r=new Float32Array(t);if(n.length!==r.length)throw new Error(`Expected ArrayBuffer to be of length ${r.length}, but it was ${n.length}`);for(let s=0;s<r.length;s++)if(n[s]!==r[s])throw new Error(`Expected ArrayBuffer value at ${s} to be ${r[s]} but got ${n[s]} instead`)}function eh(e){for(let t=0;t<e.length;t++){const n=e[t];Array.isArray(n)?eh(n):e[t]=va(n)}return e}function th(e){const t=document.createElement("video");return"playsInline"in t&&(t.playsInline=!0),t.muted=!0,t.loop=!0,t.style.position="fixed",t.style.left="0px",t.style.top="0px",t.preload="auto",t.appendChild(e),new Promise((e=>{t.addEventListener("loadeddata",(n=>e(t))),t.load()}))}async function nh(e){await e.play(),"requestVideoFrameCallback"in e&&await new Promise((t=>{e.requestVideoFrameCallback(t)}))}
/** @license See the LICENSE file. */
const rh="4.11.0";
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class sh{static sgd(e){return new pl(e)}static momentum(e,t,n=!1){return new dl(e,t,n)}static rmsprop(e,t=.9,n=0,r=null,s=!1){return new fl(e,t,n,r,s)}static adam(e=.001,t=.9,n=.999,r=null){return new rl(e,t,n,r)}static adadelta(e=.001,t=.95,n=null){return new Yu(e,t,n)}static adamax(e=.002,t=.9,n=.999,r=null,s=0){return new hl(e,t,n,r,s)}static adagrad(e,t=.1){return new Zu(e,t)}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ah(e){const t=$i(e,"x","acos"),n={x:t};return gi.runKernel(xt,n)}const ih=Ri({acos_:ah});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function oh(e){const t=$i(e,"x","acosh"),n={x:t};return gi.runKernel(wt,n)}const uh=Ri({acosh_:oh});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function lh(e){we(Array.isArray(e),(()=>"The argument passed to tf.addN() must be a list of tensors")),we(e.length>=1,(()=>`Must pass at least one tensor to tf.addN(), but got ${e.length}`));const t=e.map(((e,t)=>$i(e,`tensors${t}`,"addN"))),n=t[0];t.forEach((e=>{if(e.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")})),t.forEach((e=>{if(!Te(e.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")}));const r=t;return gi.runKernel(kt,r)}const ch=Ri({addN_:lh});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function hh(e,t=null,n=!1){const r=$i(e,"x","all","bool"),s={x:r},a={axis:t,keepDims:n};return gi.runKernel(It,s,a)}const ph=Ri({all_:hh});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function dh(e,t=null,n=!1){const r=$i(e,"x","any","bool"),s={x:r},a={axis:t,keepDims:n};return gi.runKernel(Nt,s,a)}const fh=Ri({any_:dh});
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function mh(e,t=0){const n=$i(e,"x","argMax"),r={x:n},s={axis:t};return gi.runKernel(St,r,s)}const gh=Ri({argMax_:mh});
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function yh(e,t=0){const n=$i(e,"x","argMin"),r={x:n},s={axis:t};return gi.runKernel(Tt,r,s)}const bh=Ri({argMin_:yh});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function xh(e){const t=$i(e,"x","asin"),n={x:t};return gi.runKernel($t,n)}const wh=Ri({asin_:xh});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function vh(e){const t=$i(e,"x","asinh"),n={x:t};return gi.runKernel(Ct,n)}const kh=Ri({asinh_:vh});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Ih(e){const t=$i(e,"x","atan"),n={x:t};return gi.runKernel(Et,n)}const Nh=Ri({atan_:Ih});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Sh(e,t){let n=$i(e,"a","atan2"),r=$i(t,"b","atan2");[n,r]=ai(n,r);const s={a:n,b:r};return gi.runKernel(At,s)}const Th=Ri({atan2_:Sh});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function $h(e){const t=$i(e,"x","atanh"),n={x:t};return gi.runKernel(Rt,n)}const Ch=Ri({atanh_:$h});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Eh(e,t,n,r,s="NHWC",a){const i=e[3],o=[...t,i],u=jh(s);return Fh(e,o,n,a,r,null,null,u)}function Rh(e,t,n,r,s,a,i="channelsLast"){const[o,u]=Lh(t);let l;if("channelsLast"===i)l=[o,u,e[3],e[3]];else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);l=[o,u,e[1],e[1]]}return Fh(e,l,n,r,s,a,!1,i)}function Ah(e,t,n,r,s,a,i="NDHWC"){const[o,u,l]=zh(t);let c,h;if("NDHWC"===i)h="channelsLast",c=[o,u,l,e[4],e[4]];else{if("NCDHW"!==i)throw new Error(`Unknown dataFormat ${i}`);h="channelsFirst",c=[o,u,l,e[1],e[1]]}return _h(e,c,n,r,s,!1,h,a)}function Fh(e,t,n,r,s,a,i=!1,o="channelsLast"){let[u,l,c,h]=[-1,-1,-1,-1];if("channelsLast"===o)[u,l,c,h]=e;else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);[u,h,l,c]=e}const[p,d,,f]=t,[m,g]=Lh(n),[y,b]=Lh(r),x=Ph(p,y),w=Ph(d,b),{padInfo:v,outHeight:k,outWidth:I}=Bh(s,l,c,m,g,x,w,a,o),N=i?f*h:f;let S;return"channelsFirst"===o?S=[u,N,k,I]:"channelsLast"===o&&(S=[u,k,I,N]),{batchSize:u,dataFormat:o,inHeight:l,inWidth:c,inChannels:h,outHeight:k,outWidth:I,outChannels:N,padInfo:v,strideHeight:m,strideWidth:g,filterHeight:p,filterWidth:d,effectiveFilterHeight:x,effectiveFilterWidth:w,dilationHeight:y,dilationWidth:b,inShape:e,outShape:S,filterShape:t}}function _h(e,t,n,r,s,a=!1,i="channelsLast",o){let[u,l,c,h,p]=[-1,-1,-1,-1,-1];if("channelsLast"===i)[u,l,c,h,p]=e;else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);[u,p,l,c,h]=e}const[d,f,m,,g]=t,[y,b,x]=zh(n),[w,v,k]=zh(r),I=Ph(d,w),N=Ph(f,v),S=Ph(m,k),{padInfo:T,outDepth:$,outHeight:C,outWidth:E}=Wh(s,l,c,h,y,b,x,I,N,S,o),R=a?g*p:g;let A;return"channelsFirst"===i?A=[u,R,$,C,E]:"channelsLast"===i&&(A=[u,$,C,E,R]),{batchSize:u,dataFormat:i,inDepth:l,inHeight:c,inWidth:h,inChannels:p,outDepth:$,outHeight:C,outWidth:E,outChannels:R,padInfo:T,strideDepth:y,strideHeight:b,strideWidth:x,filterDepth:d,filterHeight:f,filterWidth:m,effectiveFilterDepth:I,effectiveFilterHeight:N,effectiveFilterWidth:S,dilationDepth:w,dilationHeight:v,dilationWidth:k,inShape:e,outShape:A,filterShape:t}}function Dh(e,t,n,r,s){null==r&&(r=Mh(e,t,n));const a=e[0],i=e[1],o=Vh((a-t+2*r)/n+1,s),u=Vh((i-t+2*r)/n+1,s);return[o,u]}function Oh(e,t,n,r,s,a){null==s&&(s=Mh(e,t[0],r[0]));const i=[0,0,0,n];for(let o=0;o<3;o++)e[o]+2*s>=t[o]&&(i[o]=Vh((e[o]-t[o]+2*s)/r[o]+1,a));return i}function Mh(e,t,n,r=1){const s=Ph(t,r);return Math.floor((e[0]*(n-1)-n+s)/2)}function Lh(e){return"number"===typeof e?[e,e,e]:2===e.length?[e[0],e[1],1]:e}function zh(e){return"number"===typeof e?[e,e,e]:e}function Ph(e,t){return t<=1?e:e+(e-1)*(t-1)}function Bh(e,t,n,r,s,a,i,o,u){let l,c,h;if("number"===typeof e){const s=0===e?"VALID":"NUMBER";l={top:e,bottom:e,left:e,right:e,type:s};const i=Dh([t,n],a,r,e,o);c=i[0],h=i[1]}else if("same"===e){c=Math.ceil(t/r),h=Math.ceil(n/s);const e=Math.max(0,(c-1)*r+a-t),o=Math.max(0,(h-1)*s+i-n),u=Math.floor(e/2),p=e-u,d=Math.floor(o/2),f=o-d;l={top:u,bottom:p,left:d,right:f,type:"SAME"}}else if("valid"===e)l={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((t-a+1)/r),h=Math.ceil((n-i+1)/s);else{if("object"!==typeof e)throw Error(`Unknown padding parameter: ${e}`);{const p="channelsLast"===u?e[1][0]:e[2][0],d="channelsLast"===u?e[1][1]:e[2][1],f="channelsLast"===u?e[2][0]:e[3][0],m="channelsLast"===u?e[2][1]:e[3][1],g=0===p&&0===d&&0===f&&0===m?"VALID":"EXPLICIT";l={top:p,bottom:d,left:f,right:m,type:g},c=Vh((t-a+p+d)/r+1,o),h=Vh((n-i+f+m)/s+1,o)}}return{padInfo:l,outHeight:c,outWidth:h}}function Wh(e,t,n,r,s,a,i,o,u,l,c){let h,p,d,f;if("valid"===e&&(e=0),"number"===typeof e){const m=0===e?"VALID":"NUMBER";h={top:e,bottom:e,left:e,right:e,front:e,back:e,type:m};const g=Oh([t,n,r,1],[o,u,l],1,[s,a,i],e,c);p=g[0],d=g[1],f=g[2]}else{if("same"!==e)throw Error(`Unknown padding parameter: ${e}`);{p=Math.ceil(t/s),d=Math.ceil(n/a),f=Math.ceil(r/i);const e=(p-1)*s+o-t,c=(d-1)*a+u-n,m=(f-1)*i+l-r,g=Math.floor(e/2),y=e-g,b=Math.floor(c/2),x=c-b,w=Math.floor(m/2),v=m-w;h={top:b,bottom:x,left:w,right:v,front:g,back:y,type:"SAME"}}}return{padInfo:h,outDepth:p,outHeight:d,outWidth:f}}function Vh(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error(`Unknown roundingMode ${t}`)}}function Uh(e){const[t,n,r]=Lh(e);return 1===t&&1===n&&1===r}function Gh(e,t){return Uh(e)||Uh(t)}function Hh(e){return Lh(e).every((e=>e>0))}function jh(e){if("NHWC"===e)return"channelsLast";if("NCHW"===e)return"channelsFirst";throw new Error(`Unknown dataFormat ${e}`)}function qh(e,t,n){if(null!=n){if("string"===typeof t)throw Error(`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);if("number"===typeof t)we($e(t),(()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`));else{if("object"!==typeof t)throw Error(`Error in ${e}: Unknown padding parameter: ${t}`);t.forEach((t=>{t.forEach((t=>{we($e(t),(()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`))}))}))}}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Kh(e,t){const n=$i(e,"x","reshape","string_or_numeric"),r={x:n},s={shape:t};return gi.runKernel(Mr,r,s)}const Xh=Ri({reshape_:Kh});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Yh(e,t,n,r,s){const a=$i(e,"x","avgPool","float32"),i=1;we(Gh(n,i),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`));let o=a,u=!1;3===a.rank&&(u=!0,o=Xh(a,[1,a.shape[0],a.shape[1],a.shape[2]])),we(4===o.rank,(()=>`Error in avgPool: x must be rank 4 but got rank ${o.rank}.`)),qh("avgPool",r,s);const l={x:o},c={filterSize:t,strides:n,pad:r,dimRoundingMode:s};let h=gi.runKernel(Ft,l,c);return h=Xo(h,a.dtype),u?Xh(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const Jh=Ri({avgPool_:Yh});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Zh(e,t,n,r,s,a="NDHWC"){const i=$i(e,"x","avgPool3d","float32");let o=i,u=!1;4===i.rank&&(u=!0,o=Xh(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),we(5===o.rank,(()=>`Error in avgPool3d: x must be rank 5 but got rank ${o.rank}.`)),we("NDHWC"===a,(()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`)),we("number"===typeof n&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,(()=>`Error in avgPool3d: Stride must be > 0, but got '${n}'`)),qh("avgPool3d",r,s);const l={x:o},c={filterSize:t,strides:n,pad:r,dimRoundingMode:s,dataFormat:a};let h=gi.runKernel(Dt,l,c);return h=Xo(h,o.dtype),u?Xh(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const Qh=Ri({avgPool3d_:Zh});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ep(e,t=0){we(e.length>=1,(()=>"Pass at least one tensor to concat"));const n=Ci(e,"tensors","concat","string_or_numeric");if("complex64"===n[0].dtype&&n.forEach((e=>{if("complex64"!==e.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${e.dtype}. `)})),1===n.length)return Jo(n[0]);const r=n,s={axis:t};return gi.runKernel(qt,r,s)}const tp=Ri({concat_:ep});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function np(e){const t=$i(e,"x","sigmoid","float32"),n={x:t};return gi.runKernel(es,n)}const rp=Ri({sigmoid_:np});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function sp(e,t,n){const r=$i(e,"x","slice","string_or_numeric");if(0===r.rank)throw new Error("Slicing scalar is not possible");const s={x:r},a={begin:t,size:n};return gi.runKernel(Yr,s,a)}const ap=Ri({slice_:sp});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ip(e){const t=$i(e,"x","tanh","float32"),n={x:t};return gi.runKernel(vs,n)}const op=Ri({tanh_:ip});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function up(e,t,n,r,s,a){const i=$i(e,"forgetBias","basicLSTMCell"),o=$i(t,"lstmKernel","basicLSTMCell"),u=$i(n,"lstmBias","basicLSTMCell"),l=$i(r,"data","basicLSTMCell"),c=$i(s,"c","basicLSTMCell"),h=$i(a,"h","basicLSTMCell"),p=tp([l,h],1),d=jl(p,o),f=ku(d,u),m=f.shape[0],g=f.shape[1]/4,y=[m,g],b=ap(f,[0,0],y),x=ap(f,[0,g],y),w=ap(f,[0,2*g],y),v=ap(f,[0,3*g],y),k=ku(Cu(rp(b),op(x)),Cu(c,rp(ku(i,w)))),I=Cu(op(k),rp(v));return[k,I]}const lp=Ri({basicLSTMCell_:up});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function cp(e,t,n){const r=$i(e,"x","batchToSpaceND"),s=t.reduce(((e,t)=>e*t));we(r.rank>=1+t.length,(()=>`input rank is ${r.rank} but should be > than blockShape.length ${t.length}`)),we(n.length===t.length,(()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`)),we(r.shape[0]%s===0,(()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${s}`));const a={x:r},i={blockShape:t,crops:n};return gi.runKernel(Lt,a,i)}const hp=Ri({batchToSpaceND_:cp});function pp(e){let t;return t=0===e.rank||1===e.rank?Xh(e,[1,1,1,e.size]):2===e.rank?Xh(e,[1,1,e.shape[0],e.shape[1]]):3===e.rank?Xh(e,[1,e.shape[0],e.shape[1],e.shape[2]]):e,t}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function dp(e,t,n,r,s,a){null==a&&(a=.001);const i=$i(e,"x","batchNorm"),o=$i(t,"mean","batchNorm"),u=$i(n,"variance","batchNorm");let l,c;null!=s&&(l=$i(s,"scale","batchNorm")),null!=r&&(c=$i(r,"offset","batchNorm")),we(o.rank===u.rank,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),we(null==c||o.rank===c.rank,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),we(null==l||o.rank===l.rank,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));const h=pp(i),p={x:h,scale:l,offset:c,mean:o,variance:u},d={varianceEpsilon:a},f=gi.runKernel(Rn,p,d);return Xh(f,i.shape)}const fp=Ri({batchNorm_:dp});function mp(e,t,n,r,s,a){const i=$i(e,"x","batchNorm"),o=$i(t,"mean","batchNorm"),u=$i(n,"variance","batchNorm");let l,c;return null!=s&&(l=$i(s,"scale","batchNorm")),null!=r&&(c=$i(r,"offset","batchNorm")),we(2===i.rank,(()=>`Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`)),we(2===o.rank||1===o.rank,(()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${o.rank}.`)),we(2===u.rank||1===u.rank,(()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${u.rank}.`)),null!=l&&we(2===l.rank||1===l.rank,(()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${l.rank}.`)),null!=c&&we(2===c.rank||1===c.rank,(()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`)),fp(i,o,u,c,l,a)}const gp=Ri({batchNorm2d_:mp});function yp(e,t,n,r,s,a){const i=$i(e,"x","batchNorm"),o=$i(t,"mean","batchNorm"),u=$i(n,"variance","batchNorm");let l,c;return null!=s&&(l=$i(s,"scale","batchNorm")),null!=r&&(c=$i(r,"offset","batchNorm")),we(3===i.rank,(()=>`Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`)),we(3===o.rank||1===o.rank,(()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${o.rank}.`)),we(3===u.rank||1===u.rank,(()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${u.rank}.`)),null!=l&&we(3===l.rank||1===l.rank,(()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${l.rank}.`)),null!=c&&we(3===c.rank||1===c.rank,(()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`)),fp(i,o,u,c,l,a)}const bp=Ri({batchNorm3d_:yp});function xp(e,t,n,r,s,a){const i=$i(e,"x","batchNorm"),o=$i(t,"mean","batchNorm"),u=$i(n,"variance","batchNorm");let l,c;return null!=s&&(l=$i(s,"scale","batchNorm")),null!=r&&(c=$i(r,"offset","batchNorm")),we(4===i.rank,(()=>`Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`)),we(4===o.rank||1===o.rank,(()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${o.rank}.`)),we(4===u.rank||1===u.rank,(()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${u.rank}.`)),null!=l&&we(4===l.rank||1===l.rank,(()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${l.rank}.`)),null!=c&&we(4===c.rank||1===c.rank,(()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`)),fp(i,o,u,c,l,a)}const wp=Ri({batchNorm4d_:xp});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function vp(e,t,n){const r=$i(e,"x","bincount"),s=$i(t,"weights","bincount");we("int32"===r.dtype,(()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`)),we(n>=0,(()=>`size must be non-negative, but got ${n}.`)),we(s.size===r.size||0===s.size,(()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${s.shape}.`));const a={x:r,weights:s},i={size:n};return gi.runKernel(zt,a,i)}const kp=Ri({bincount_:vp});
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Ip(e,t){const n=$i(e,"x","bitwiseAnd"),r=$i(t,"y","bitwiseAnd");if(!Te(n.shape,r.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${n.shape}, y: ${r.shape}`);if("int32"!==n.dtype||"int32"!==r.dtype)throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${n.dtype} and type of y: ${r.dtype}`);const s={a:n,b:r};return gi.runKernel(Pt,s)}const Np=Ri({bitwiseAnd_:Ip});
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Sp(e,t){const n=$i(e,"s0","broadcastArgs","int32"),r=$i(t,"s1","broadcastArgs","int32");if(1!==n.rank)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);if(1!==r.rank)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);const s={s0:n,s1:r};return gi.runKernel(Wt,s)}const Tp=Ri({broadcastArgs_:Sp});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function $p(e,t){let n=$i(e,"broadcastTo","x");const r=n.shape;if(nt(t),t.length<n.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);if(t.length>n.rank){const e=n.shape.slice();while(e.length<t.length)e.unshift(1);n=Xh(n,e)}const s=n.shape,a=Array.from(t);for(let l=t.length-1;l>=0;l--)if(s[l]===t[l])a[l]=1;else if(1!==n.shape[l])throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${t}].`);const i=a.map(((e,t)=>e>1?t:-1)).filter((e=>e>=0));if(0===i.length)return Jo(n);const o={x:n},u={reps:a};return gi.runKernel(ks,o,u)}const Cp=Ri({broadcastTo_:$p});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Ep(e){const t=$i(e,"x","ceil","float32"),n={x:t};return gi.runKernel(Ut,n)}const Rp=Ri({ceil_:Ep});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Ap(e,t,n){const r=$i(e,"x","clipByValue");if(we(t<=n,(()=>`Error in clip: min (${t}) must be less than or equal to max (${n}).`)),t===n)return Ju(r.shape,t,r.dtype);const s={x:r},a={clipValueMin:t,clipValueMax:n};return gi.runKernel(Gt,s,a)}const Fp=Ri({clipByValue_:Ap});function _p(e){return tp(e,0)}const Dp=Ri({concat1d_:_p});function Op(e,t){return tp(e,t)}const Mp=Ri({concat2d_:Op});function Lp(e,t){return tp(e,t)}const zp=Ri({concat3d_:Lp});function Pp(e,t){return tp(e,t)}const Bp=Ri({concat4d_:Pp});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Wp(e,t,n,r,s="NHWC",a=[1,1],i){const o=$i(e,"x","conv2d","float32"),u=$i(t,"filter","conv2d","float32");let l=o,c=!1;3===o.rank&&(c=!0,l=Xh(o,[1,o.shape[0],o.shape[1],o.shape[2]])),we(4===l.rank,(()=>`Error in conv2d: input must be rank 4, but got rank ${l.rank}.`)),we(4===u.rank,(()=>`Error in conv2d: filter must be rank 4, but got rank ${u.rank}.`)),qh("conv2d",r,i);const h="NHWC"===s?l.shape[3]:l.shape[1];we(h===u.shape[2],(()=>`Error in conv2d: depth of input (${h}) must match input depth for filter ${u.shape[2]}.`)),we(Gh(n,a),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`)),we(Hh(a),(()=>"Error in conv2D: Dilated rates should be larger than 0.")),we(Hh(n),(()=>"Error in conv2D: Strides should be larger than 0."));const p={x:l,filter:u},d={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:i},f=gi.runKernel(Kt,p,d);return c?Xh(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const Vp=Ri({conv2d_:Wp});function Up(e,t,n,r,s="NWC",a=1,i){const o=$i(e,"x","conv1d"),u=$i(t,"filter","conv1d");let l=o,c=!1;2===o.rank&&(c=!0,l=Xh(o,[1,o.shape[0],o.shape[1]])),we(3===l.rank,(()=>`Error in conv1d: input must be rank 3, but got rank ${l.rank}.`)),we(3===u.rank,(()=>`Error in conv1d: filter must be rank 3, but got rank ${u.rank}.`)),qh("conv1d",r,i),we(l.shape[2]===u.shape[1],(()=>`Error in conv1d: depth of input (${l.shape[2]}) must match input depth for filter ${u.shape[1]}.`)),we(Gh(n,a),(()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${a}'`)),we(Hh(a),(()=>"Error in conv1D: Dilated rates should be larger than 0.")),we(Hh(n),(()=>"Error in conv1D: Stride should be larger than 0.")),we("NWC"===s,(()=>`Error in conv1d: got dataFormat of ${s} but only NWC is currently supported.`));const h=Xh(u,[1,u.shape[0],u.shape[1],u.shape[2]]),p=Xh(l,[l.shape[0],1,l.shape[1],l.shape[2]]),d=[1,n],f=[1,a],m="NHWC",g=Vp(p,h,d,r,m,f,i);return Xh(g,c?[g.shape[2],g.shape[3]]:[g.shape[0],g.shape[2],g.shape[3]])}const Gp=Ri({conv1d_:Up});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Hp(e,t,n,r,s,a="NHWC",i){we(e.length===t.rank,(()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`));let o=e,u=t,l=!1;3===t.rank&&(l=!0,u=Xh(t,[1,t.shape[0],t.shape[1],t.shape[2]]),o=[1,e[0],e[1],e[2]]),we(4===o.length,(()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${o.length}.`)),we(4===u.rank,(()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${u.rank}`)),we(4===n.rank,(()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`));const c="NHWC"===a?o[3]:o[1],h="NHWC"===a?u.shape[3]:u.shape[1];we(c===n.shape[2],(()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${n.shape[2]}.`)),we(h===n.shape[3],(()=>`Error in conv2dDerInput: depth of output (${h}) must match output depth for filter ${n.shape[3]}.`)),qh("conv2dDerInput",s,i);const p={dy:u,filter:n},d={strides:r,pad:s,dataFormat:a,dimRoundingMode:i,inputShape:o},f=gi.runKernel(Yt,p,d);return l?Xh(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const jp=Ri({conv2DBackpropInput_:Hp});function qp(e,t,n,r,s,a){const i=$i(e,"x","conv2dTranspose"),o=$i(t,"filter","conv2dTranspose");return jp(n,i,o,r,s,"NHWC",a)}const Kp=Ri({conv2dTranspose_:qp});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Xp(e,t,n,r,s="NDHWC",a=[1,1,1]){const i=$i(e,"x","conv3d"),o=$i(t,"filter","conv3d");let u=i,l=!1;4===i.rank&&(l=!0,u=Xh(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),we(5===u.rank,(()=>`Error in conv3d: input must be rank 5, but got rank ${u.rank}.`)),we(5===o.rank,(()=>`Error in conv3d: filter must be rank 5, but got rank ${o.rank}.`)),we(u.shape[4]===o.shape[3],(()=>`Error in conv3d: depth of input (${u.shape[4]}) must match input depth for filter ${o.shape[3]}.`)),we(Gh(n,a),(()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`)),we("NDHWC"===s,(()=>`Error in conv3d: got dataFormat of ${s} but only NDHWC is currently supported.`)),we(Hh(a),(()=>"Error in conv3D: Dilated rates should be larger than 0.")),we(Hh(n),(()=>"Error in conv3D: Strides should be larger than 0."));const c={x:u,filter:o},h={strides:n,pad:r,dataFormat:s,dilations:a},p=gi.runKernel(Jt,c,h);return l?Xh(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const Yp=Ri({conv3d_:Xp});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Jp(e,t,n,r,s){we(e.length===t.rank,(()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`));let a=e,i=t,o=!1;4===t.rank&&(o=!0,i=Xh(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),a=[1,e[0],e[1],e[2],e[3]]);const u=a[4],l=i.shape[4];we(5===a.length,(()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${a.length}.`)),we(5===i.rank,(()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`)),we(5===n.rank,(()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`)),we(u===n.shape[3],(()=>`Error in conv3dDerInput: depth of input (${u}) must match input depth for filter ${n.shape[3]}.`)),we(l===n.shape[4],(()=>`Error in conv3dDerInput: depth of output (${l}) must match output depth for filter ${n.shape[4]}.`));const c={dy:i,filter:n},h={pad:s,strides:r,inputShape:a},p=gi.runKernel(Qt,c,h);return o?Xh(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const Zp=Ri({conv3DBackpropInput_:Jp});function Qp(e,t,n,r,s){const a=$i(e,"x","conv3dTranspose"),i=$i(t,"filter","conv3dTranspose");return Zp(n,a,i,r,s)}const ed=Ri({conv3dTranspose_:Qp});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function td(e){const t=$i(e,"x","cos","float32"),n={x:t};return gi.runKernel(en,n)}const nd=Ri({cos_:td});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function rd(e){const t=$i(e,"x","cosh","float32"),n={x:t};return gi.runKernel(tn,n)}const sd=Ri({cosh_:rd});
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ad(e,t=0,n=!1,r=!1){const s=$i(e,"x","cumprod"),a={x:s},i={axis:t,exclusive:n,reverse:r};return gi.runKernel(nn,a,i)}const id=Ri({cumprod_:ad});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function od(e,t=0,n=!1,r=!1){const s=$i(e,"x","cumsum"),a={x:s},i={axis:t,exclusive:n,reverse:r};return gi.runKernel(rn,a,i)}const ud=Ri({cumsum_:od});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ld(e,t,n,r=!1){const s=$i(e,"x","denseBincount"),a=$i(t,"weights","denseBincount");we("int32"===s.dtype,(()=>`Error in denseBincount: input dtype must be int32, but got ${s.dtype}`)),we(s.rank<=2,(()=>`Error in denseBincount: input must be at most rank 2, but got rank ${s.rank}.`)),we(n>=0,(()=>`size must be non-negative, but got ${n}.`)),we(a.size===s.size||0===a.size,(()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${s.shape}, weights shape: ${a.shape}.`));const i={x:s,weights:a},o={size:n,binaryOutput:r};return gi.runKernel(an,i,o)}const cd=Ri({denseBincount_:ld});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function hd(e,t,n="NHWC"){const r=$i(e,"x","depthToSpace","float32"),s="NHWC"===n?r.shape[1]:r.shape[2],a="NHWC"===n?r.shape[2]:r.shape[3],i="NHWC"===n?r.shape[3]:r.shape[1];we(t>1,(()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`)),we(s*t>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${s} and ${t}  for depthToSpace with input shape\n    ${r.shape}`)),we(a*t>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${a} and ${t} for depthToSpace with input shape\n        ${r.shape}`)),we(i%(t*t)===0,(()=>`Dimension size must be evenly divisible by ${t*t} but is ${i} for depthToSpace with input shape ${r.shape}`));const o={x:r},u={blockSize:t,dataFormat:n};return gi.runKernel(on,o,u)}const pd=Ri({depthToSpace_:hd});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function dd(e,t,n,r,s="NHWC",a=[1,1],i){const o=$i(e,"x","depthwiseConv2d","float32"),u=$i(t,"filter","depthwiseConv2d","float32");let l=o,c=!1;3===o.rank&&(c=!0,l=Xh(o,[1,o.shape[0],o.shape[1],o.shape[2]])),we(4===l.rank,(()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${l.rank}.`)),we(4===u.rank,(()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${u.rank}.`));const h="NHWC"===s?l.shape[3]:l.shape[1];we(h===u.shape[2],(()=>`Error in depthwiseConv2d: number of input channels (${h}) must match the inChannels dimension in filter ${u.shape[2]}.`)),qh("depthwiseConv2d",r,i);const p={x:l,filter:u},d={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:i},f=gi.runKernel(un,p,d);return c?Xh(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const fd=Ri({depthwiseConv2d_:dd});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function md(e){const t=$i(e,"x","diag"),n={x:t};return gi.runKernel(hn,n)}const gd=Ri({diag_:md});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function yd(e,t,n,r,s=[1,1],a="NHWC"){const i=$i(e,"x","dilation2d"),o=$i(t,"filter","dilation2d");we(3===i.rank||4===i.rank,(()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`)),we(3===o.rank,(()=>`Error in dilation2d: filter must be rank 3, but got rank ${o.rank}.`)),we("NHWC"===a,(()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${a}`));let u=i,l=!1;3===i.rank&&(u=Xh(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=!0),we(u.shape[3]===o.shape[2],(()=>`Error in dilation2d:  input and filter must have the same depth: ${u.shape[3]} vs ${o.shape[2]}`));const c={x:u,filter:o},h={strides:n,pad:r,dilations:s},p=gi.runKernel(pn,c,h);return l?Xh(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const bd=Ri({dilation2d_:yd});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function xd(e,t){let n=$i(e,"a","equal","string_or_numeric"),r=$i(t,"b","equal","string_or_numeric");[n,r]=ai(n,r),ul(n.shape,r.shape);const s={a:n,b:r};return gi.runKernel(vn,s)}const wd=Ri({equal_:xd});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function vd(e,t,n){const r=$i(t,"a","where"),s=$i(n,"b","where"),a=$i(e,"condition","where","bool"),i=ul(ul(a.shape,r.shape),s.shape),o=Cp(a,i),u=Cp(r,i),l=Cp(s,i),c={condition:o,t:u,e:l};return gi.runKernel(Kr,c)}const kd=Ri({where_:vd});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Id(e,t){let n=$i(e,"a","div"),r=$i(t,"b","div");[n,r]=ai(n,r);const s=Tu(n,r),a=Du(s),i=wd(r,a);return kd(i,a,s)}const Nd=Ri({divNoNan_:Id});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Sd(e,t){const n=$i(e,"t1","dot"),r=$i(t,"t2","dot");we((1===n.rank||2===n.rank)&&(1===r.rank||2===r.rank),(()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${r.rank}.`));const s=1===n.rank?n.size:n.shape[1],a=1===r.rank?r.size:r.shape[0];if(we(s===a,(()=>`Error in dot: inner dimensions of inputs must match, but got ${s} and ${a}.`)),1===n.rank&&1===r.rank){const e=Xh(n,[1,-1]),t=Xh(r,[-1,1]),s=jl(e,t);return Xh(s,[])}if(1===n.rank&&2===r.rank){const e=Xh(n,[1,-1]),t=Xh(r,[r.shape[0],r.shape[1]]),s=jl(e,t);return Xh(s,[s.size])}if(2===n.rank&&1===r.rank){const e=Xh(r,[-1,1]),t=jl(n,e);return Xh(t,[t.size])}{const e=Xh(r,[r.shape[0],r.shape[1]]),t=jl(n,e);return t}}const Td=Ri({dot_:Sd});
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function $d(e,...t){const n=t.map(((e,t)=>$i(e,`tensors${t}`,"einsum"))),r={equation:e};return gi.runKernel(yn,n,r)}const Cd=Ri({einsum_:$d});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Ed(e){const t=$i(e,"x","elu","float32"),n={x:t};return gi.runKernel(bn,n)}const Rd=Ri({elu_:Ed});
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Ad(e,t){const n=$i(e,"x","ensureShape","string_or_numeric");if(!Se(n.shape,t))throw new Error(`EnsureShape: Shape of tensor ${n.shape} is not compatible with expected shape ${t}`);return e}const Fd=Ri({ensureShape_:Ad});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function _d(e){let t=$i(e,"x","erf");we("int32"===t.dtype||"float32"===t.dtype,(()=>"Input dtype must be `int32` or `float32`.")),"int32"===t.dtype&&(t=Xo(t,"float32"));const n={x:t};return gi.runKernel(wn,n)}const Dd=Ri({erf_:_d});
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Od(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function Md(e,t,n){const r=e.length+t.length,s=[];let a=0,i=0;for(let o=0;o<r;o++)-1===n.indexOf(o)?s.push(e[a++]):s.push(t[i++]);return s}function Ld(e,t){const n=[],r=e.length;for(let a=0;a<r;a++)-1===t.indexOf(a)&&n.push(e[a]);const s=t.map((t=>e[t]));return[n,s]}function zd(e,t){const n=t.map((e=>1));return Md(e,n,t)}function Pd(e,t,n){we(Od(t,n),(()=>`${e} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`))}function Bd(e,t){if(Od(e,t))return null;const n=[];for(let r=0;r<t;++r)-1===e.indexOf(r)&&n.push(r);return e.forEach((e=>n.push(e))),n}function Wd(e){return e.map(((e,t)=>[t,e])).sort(((e,t)=>e[1]-t[1])).map((e=>e[0]))}function Vd(e,t){const n=[];for(let r=t-e;r<t;++r)n.push(r);return n}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Ud(e,t=null,n=!1){const r=$i(e,"x","max"),s={x:r},a={reductionIndices:t,keepDims:n};return gi.runKernel(nr,s,a)}const Gd=Ri({max_:Ud});
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Hd(e,t=null,n=!1){const r=$i(e,"x","min"),s={x:r},a={axis:t,keepDims:n};return gi.runKernel(cr,s,a)}const jd=Ri({min_:Hd});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function qd(e,t=null,n=!1){let r=$i(e,"x","sum");"bool"===r.dtype&&(r=Xo(r,"int32"));const s={x:r},a={axis:t,keepDims:n};return gi.runKernel(rs,s,a)}const Kd=Ri({sum_:qd});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Xd(e,t="euclidean",n=null,r=!1){e=$i(e,"x","norm");const s=Yd(e,t,n);let a=s.shape;if(r){const t=De(n,e.shape);a=zd(s.shape,t)}return Xh(s,a)}function Yd(e,t,n=null){if(0===e.rank)return al(e);if(1!==e.rank&&null===n)return Yd(Xh(e,[-1]),t,n);if(1===e.rank||"number"===typeof n||Array.isArray(n)&&1===n.length){if(1===t)return Kd(al(e),n);if(t===1/0)return Gd(al(e),n);if(t===-1/0)return jd(al(e),n);if("euclidean"===t||2===t)return Ru(Kd(el(al(e),Vu(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(n)&&2===n.length){if(1===t)return Gd(Kd(al(e),n[0]),n[1]-1);if(t===1/0)return Gd(Kd(al(e),n[1]),n[0]);if(t===-1/0)return jd(Kd(al(e),n[1]),n[0]);if("fro"===t||"euclidean"===t)return Ru(Kd(Fu(e),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}const Jd=Ri({norm_:Xd});
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Zd(e,t=null,n=!1){return Jd(e,"euclidean",t,n)}const Qd=Ri({euclideanNorm_:Zd});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ef(e){const t=$i(e,"x","exp"),n={x:t};return gi.runKernel(kn,n)}const tf=Ri({exp_:ef});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function nf(e,t=0){const n=$i(e,"x","expandDims","string_or_numeric");we(t<=n.rank,(()=>"Axis must be <= rank of the tensor"));const r={input:n},s={dim:t};return gi.runKernel(In,r,s)}const rf=Ri({expandDims_:nf});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function sf(e){const t=$i(e,"x","expm1"),n={x:t};return gi.runKernel(Nn,n)}const af=Ri({expm1_:sf});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function of(e,t){const n=$i(e,"x","tile","string_or_numeric");we(n.rank===t.length,(()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`));const r={x:n},s={reps:t};return gi.runKernel(ks,r,s)}const uf=Ri({tile_:of});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function lf(e,t,n,r="float32"){null==t&&(t=e);const s=qo([e,t],r),a=e<=t?e:t;for(let o=0;o<a;++o)s.set(1,o,o);const i=Xh(s.toTensor(),[e,t]);if(null==n)return i;if(1===n.length)return uf(rf(i,0),[n[0],1,1]);if(2===n.length)return uf(rf(rf(i,0),0),[n[0],n[1],1,1]);if(3===n.length)return uf(rf(rf(rf(i,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}const cf=Ri({eye_:lf});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function hf(e){const t=$i(e,"x","floor","float32"),n={x:t};return gi.runKernel(Cn,n)}const pf=Ri({floor_:hf});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function df(e,t,n=0,r=0){const s=$i(e,"x","gather"),a=$i(t,"indices","gather","int32"),i={x:s,indices:a},o={axis:n,batchDims:r};return gi.runKernel(An,i,o)}const ff=Ri({gather_:df});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function mf(e,t){let n=$i(e,"a","greater","string_or_numeric"),r=$i(t,"b","greater","string_or_numeric");[n,r]=ai(n,r),ul(n.shape,r.shape);const s={a:n,b:r};return gi.runKernel(_n,s)}const gf=Ri({greater_:mf});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function yf(e,t){let n=$i(e,"a","greaterEqual","string_or_numeric"),r=$i(t,"b","greaterEqual","string_or_numeric");[n,r]=ai(n,r),ul(n.shape,r.shape);const s={a:n,b:r};return gi.runKernel(Dn,s)}const bf=Ri({greaterEqual_:yf});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function xf(e){const t=$i(e,"x","isFinite"),n={x:t};return gi.runKernel(zn,n)}const wf=Ri({isFinite_:xf});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function vf(e){const t=$i(e,"x","isInf"),n={x:t};return gi.runKernel(Pn,n)}const kf=Ri({isInf_:vf});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function If(e){const t=$i(e,"x","isNaN"),n={x:t};return gi.runKernel(Bn,n)}const Nf=Ri({isNaN_:If});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Sf(e,t=.2){const n=$i(e,"x","leakyRelu"),r={x:n},s={alpha:t};return gi.runKernel(Wn,r,s)}const Tf=Ri({leakyRelu_:Sf});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function $f(e,t){let n=$i(e,"a","less","string_or_numeric"),r=$i(t,"b","less","string_or_numeric");[n,r]=ai(n,r),ul(n.shape,r.shape);const s={a:n,b:r};return gi.runKernel(Vn,s)}const Cf=Ri({less_:$f});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Ef(e,t){let n=$i(e,"a","lessEqual","string_or_numeric"),r=$i(t,"b","lessEqual","string_or_numeric");[n,r]=ai(n,r),ul(n.shape,r.shape);const s={a:n,b:r};return gi.runKernel(Un,s)}const Rf=Ri({lessEqual_:Ef});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Af(e,t,n){if(n<=0)throw new Error("The number of values should be positive.");const r={start:e,stop:t,num:n};return gi.runKernel(Gn,{},r)}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Ff(e,t=5,n=1,r=1,s=.5){const a=$i(e,"x","localResponseNormalization");we(4===a.rank||3===a.rank,(()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${a.rank}.`)),we($e(t),(()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`));let i=a,o=!1;3===a.rank&&(o=!0,i=Xh(a,[1,a.shape[0],a.shape[1],a.shape[2]]));const u={x:i},l={depthRadius:t,bias:n,alpha:r,beta:s},c=gi.runKernel(Qn,u,l);return o?Xh(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const _f=Ri({localResponseNormalization_:Ff});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Df(e){const t=$i(e,"x","log","float32"),n={x:t};return gi.runKernel(Hn,n)}const Of=Ri({log_:Df});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Mf(e){const t=$i(e,"x","log1p"),n={x:t};return gi.runKernel(jn,n)}const Lf=Ri({log1p_:Mf});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function zf(e){const t=$i(e,"x","softplus"),n={x:t};return gi.runKernel(ts,n)}const Pf=Ri({softplus_:zf});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Bf(e){const t=$i(e,"x","logSigmoid"),n=Bu((e=>{const t=Zl(Pf(Zl(e))),n=t=>{const n=Cu(t,rp(Zl(e)));return n};return{value:t,gradFunc:n}}));return n(t)}const Wf=Ri({logSigmoid_:Bf});
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Vf(e,t=-1){const n=$i(e,"logits","logSoftmax");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`);const r=Bu(((e,n)=>{const r=!0,s=Gd(e,t,!0),a=nl(e,s),i=nl(Xo(a,"float32"),Of(Kd(tf(a),t,r)));n([i]);const o=(e,n)=>{const[r]=n,s=!0,a=tf(r);return nl(e,Cu(Kd(e,t,s),a))};return{value:i,gradFunc:o}}));return r(n)}const Uf=Ri({logSoftmax_:Vf});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Gf(e,t=null,n=!1){const r=$i(e,"x","logSumExp"),s=De(t,r.shape),a=Gd(r,s,!0),i=nl(r,a),o=tf(i),u=Kd(o,s),l=Of(u),c=ku(Xh(a,l.shape),l);if(n){const e=zd(c.shape,s);return Xh(c,e)}return c}const Hf=Ri({logSumExp_:Gf});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function jf(e,t){const n=$i(e,"a","logicalAnd","bool"),r=$i(t,"b","logicalAnd","bool");ul(n.shape,r.shape);const s={a:n,b:r};return gi.runKernel(qn,s)}const qf=Ri({logicalAnd_:jf});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Kf(e){const t=$i(e,"x","logicalNot","bool"),n={x:t};return gi.runKernel(Kn,n)}const Xf=Ri({logicalNot_:Kf});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Yf(e,t){const n=$i(e,"a","logicalOr","bool"),r=$i(t,"b","logicalOr","bool");ul(n.shape,r.shape);const s={a:n,b:r};return gi.runKernel(Xn,s)}const Jf=Ri({logicalOr_:Yf});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Zf(e,t){const n=$i(e,"a","logicalXor","bool"),r=$i(t,"b","logicalXor","bool");return ul(n.shape,r.shape),qf(Jf(e,t),Xf(qf(e,t)))}const Qf=Ri({logicalXor_:Zf}),em=2147483648;function tm(e,t,n="left"){const r=$i(e,"sortedSequence","searchSorted"),s=$i(t,"values","searchSorted"),a=r.shape[r.shape.length-1],i=s.shape[s.shape.length-1],o=Xh(r,[-1,a]),u=Xh(s,[-1,i]);if(o.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(o.shape[0]!==u.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(Ie(u.shape)>=em)throw new Error(`values tensor size must less than ${em}`);if(o.shape[1]>=em)throw new Error(`trailing dim_size must less than ${em} for int32 output type, was ${o.shape[1]}`);const l={sortedSequence:o,values:u},c={side:n};return gi.runKernel(qr,l,c)}const nm=Ri({searchSorted_:tm});
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function rm(e,t){return nm(e,t,"left")}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function sm(e,t,n,r,s){const a=$i(e,"x","maxPool"),i=1;let o=a,u=!1;3===a.rank&&(u=!0,o=Xh(a,[1,a.shape[0],a.shape[1],a.shape[2]])),we(4===o.rank,(()=>`Error in maxPool: input must be rank 4 but got rank ${o.rank}.`)),we(Gh(n,i),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`)),qh("maxPool",r,s);const l={x:o},c={filterSize:t,strides:n,pad:r,dimRoundingMode:s},h=gi.runKernel(sr,l,c);return u?Xh(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const am=Ri({maxPool_:sm});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function im(e,t=[1,1,1],n,r,s,a="NDHWC"){const i=$i(e,"x","maxPool3d");let o=i,u=!1;4===i.rank&&(u=!0,o=Xh(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),we(5===o.rank,(()=>`Error in maxPool3d: x must be rank 5 but got rank ${o.rank}.`)),we("NDHWC"===a,(()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`)),qh("maxPool3d",r,s);const l={x:o},c={filterSize:t,strides:n,pad:r,dimRoundingMode:s,dataFormat:a},h=gi.runKernel(ir,l,c);return u?Xh(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const om=Ri({maxPool3d_:im});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function um(e,t,n,r,s=!1){const a=$i(e,"x","maxPoolWithArgmax"),i={x:a},o={filterSize:t,strides:n,pad:r,includeBatchInIndex:s},u=gi.runKernel(ur,i,o);return{result:u[0],indexes:u[1]}}const lm=Ri({maxPoolWithArgmax_:um});
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function cm(e,t=null,n=!1){const r=$i(e,"x","mean"),s={x:r},a={axis:t,keepDims:n};return gi.runKernel(lr,s,a)}const hm=Ri({mean_:cm});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function pm(e,t="float32"){if(nt(e),"complex64"===t){const t=pm(e,"float32"),n=pm(e,"float32");return Fi(t,n)}const n=et(Ie(e),t);return gi.makeTensor(n,e,t)}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function dm(e,t="float32"){if(nt(e),"complex64"===t){const t=dm(e,"float32"),n=pm(e,"float32");return Fi(t,n)}const n=Qe(Ie(e),t);return gi.makeTensor(n,e,t)}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function fm(e,t,{indexing:n="xy"}={}){if("xy"!==n&&"ij"!==n)throw new TypeError(`${n} is not a valid third argument to meshgrid`);if(void 0===e)return[];let r=$i(e,"x","meshgrid",e instanceof ja?e.dtype:"float32");if(void 0===t)return[r];let s=$i(t,"y","meshgrid",t instanceof ja?t.dtype:"float32");const a=Ie(r.shape),i=Ie(s.shape);return"xy"===n?(r=Xh(r,[1,-1]),s=Xh(s,[-1,1]),[jl(dm([i,1],r.dtype),r),jl(s,dm([1,a],s.dtype))]):(r=Xh(r,[-1,1]),s=Xh(s,[1,-1]),[jl(r,dm([1,i],r.dtype)),jl(dm([a,1],s.dtype),s)])}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function mm(e,t){let n=$i(e,"a","minimum"),r=$i(t,"b","minimum");[n,r]=ai(n,r),"bool"===n.dtype&&(n=Xo(n,"int32"),r=Xo(r,"int32")),ul(n.shape,r.shape);const s={a:n,b:r};return gi.runKernel(hr,s)}const gm=Ri({minimum_:mm});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ym(e,t,n){we("reflect"===n||"symmetric"===n,(()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`));const r=$i(e,"x","mirrorPad");if(0===r.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");we(t.length===r.rank,(()=>`Padding doesn't match input. Must be ${r.rank}. Got ${t.length}.`));const s="reflect"===n?1:0;for(let o=0;o<r.rank;o++)we(2===t[o].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),we(t[o][0]>=0&&t[o][0]<=r.shape[o]-s&&t[o][1]>=0&&t[o][1]<=r.shape[o]-s,(()=>`Padding in dimension ${o} cannot be greater than or equal to ${r.shape[o]-s} or less than 0 for input of shape ${r.shape}`));const a={paddings:t,mode:n},i={x:r};return gi.runKernel(pr,i,a)}const bm=Ri({mirrorPad_:ym});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function xm(e,t){let n=$i(e,"a","mod"),r=$i(t,"b","mod");[n,r]=ai(n,r);const s={a:n,b:r};return gi.runKernel(dr,s)}const wm=Ri({mod_:xm});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function vm(e,t=null,n=!1){e=$i(e,"x","moments");const r=De(t,e.shape),s=hm(e,r,n);let a=s.shape;n||(a=zd(s.shape,r));const i=Fu(nl(Xo(e,"float32"),Xh(s,a))),o=hm(i,r,n);return{mean:s,variance:o}}const km=Ri({moments_:vm});function Im(e,t,n,r){const s=$i(t,"data","multiRNNCell"),a=Ci(n,"c","multiRNNCell"),i=Ci(r,"h","multiRNNCell");let o=s;const u=[];for(let h=0;h<e.length;h++){const t=e[h](o,a[h],i[h]);u.push(t[0]),u.push(t[1]),o=t[1]}const l=[],c=[];for(let h=0;h<u.length;h+=2)l.push(u[h]),c.push(u[h+1]);return[l,c]}const Nm=Ri({multiRNNCell_:Im});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Sm(e,t,n,r=!1){const s=$i(e,"logits","multinomial"),a=s.size,i=s.rank;if(a<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${a}.`);if(i>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${i}`);n=n||Math.random();const o=1===i?Xh(s,[1,-1]):s,u={logits:o},l={numSamples:t,seed:n,normalized:r},c=gi.runKernel(fr,u,l);return 1===i?Xh(c,[c.size]):c}const Tm=Ri({multinomial_:Sm});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function $m(e,t){let n=$i(e,"a","notEqual","string_or_numeric"),r=$i(t,"b","notEqual","string_or_numeric");[n,r]=ai(n,r),ul(n.shape,r.shape);const s={a:n,b:r};return gi.runKernel(yr,s)}const Cm=Ri({notEqual_:$m});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Em(e){const t=$i(e,"x","onesLike"),n={x:t};return gi.runKernel(vr,n)}const Rm=Ri({onesLike_:Em});function Am(e,t){const n=$i(e,"v1","outerProduct"),r=$i(t,"v2","outerProduct");we(1===n.rank&&1===r.rank,(()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${r.rank}.`));const s=Xh(n,[-1,1]),a=Xh(r,[1,-1]);return jl(s,a)}const Fm=Ri({outerProduct_:Am});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function _m(e,t,n=0){const r=$i(e,"x","pad");if(0===r.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const s={paddings:t,constantValue:n},a={x:r};return gi.runKernel(Nr,a,s)}const Dm=Ri({pad_:_m});function Om(e,t,n=0){return we(2===t.length,(()=>"Invalid number of paddings. Must be length of 2.")),Dm(e,[t],n)}const Mm=Ri({pad1d_:Om});function Lm(e,t,n=0){return we(2===t.length&&2===t[0].length&&2===t[1].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),Dm(e,t,n)}const zm=Ri({pad2d_:Lm});function Pm(e,t,n=0){return we(3===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),Dm(e,t,n)}const Bm=Ri({pad3d_:Pm});function Wm(e,t,n=0){return we(4===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length&&2===t[3].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),Dm(e,t,n)}const Vm=Ri({pad4d_:Wm});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Um(e,t,n){const r=$i(e,"x","spaceToBatchND");we(r.rank>=1+t.length,(()=>`input rank ${r.rank} should be > than [blockShape] ${t.length}`)),we(n.length===t.length,(()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`)),we(r.shape.reduce(((e,r,s)=>s>0&&s<=t.length?e&&(r+n[s-1][0]+n[s-1][1])%t[s-1]===0:e),!0),(()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`));const s={x:r},a={blockShape:t,paddings:n};return gi.runKernel(ss,s,a)}const Gm=Ri({spaceToBatchND_:Um});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Hm(e,t,n,r,s,a,i){null==s&&(s=[1,1]),null==a&&(a=1),0===r&&(r="valid");const o=$i(e,"x","maxPool");let u=o,l=!1;3===o.rank&&(l=!0,u=Xh(o,[1,o.shape[0],o.shape[1],o.shape[2]])),we(Gh(a,s),(()=>`Error in pool: Either strides or dilations must be 1. Got strides ${a} and dilations '${s}'`));const c=Rh(u.shape,t,a,s,r),h=[c.dilationHeight,c.dilationWidth];let p;p="same"===r?qm([c.filterHeight,c.filterWidth],h):[[0,0],[0,0]];const d=1===h[0]&&1===h[1],[f,m]=jm([c.inHeight,c.inWidth],h,p),g=d?r:"valid",y=d?u:Gm(u,h,f),b="avg"===n?()=>Jh(y,t,a,g,i):()=>am(y,t,a,g,i),x=b(),w=d?x:hp(x,h,m);return l?Xh(w,[w.shape[1],w.shape[2],w.shape[3]]):w}function jm(e,t,n){const r=n.map((e=>e[0])),s=n.map((e=>e[1])),a=e.concat(r,s),i=t.map(((e,t)=>(e-a[t]%e)%e)),o=s.map(((e,t)=>e+i[t])),u=t.map(((e,t)=>[r[t],o[t]])),l=t.map(((e,t)=>[0,i[t]]));return[u,l]}function qm(e,t){const n=e.map(((e,n)=>e+(e-1)*(t[n]-1))),r=n.map((e=>e-1)),s=r.map((e=>Math.floor(e/2))),a=r.map(((e,t)=>e-s[t]));return r.map(((e,t)=>[s[t],a[t]]))}const Km=Ri({pool_:Hm});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Xm(e,t){const n=$i(e,"x","prelu"),r=$i(t,"alpha","prelu"),s={x:n,alpha:r};return gi.runKernel($r,s)}const Ym=Ri({prelu_:Xm});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Jm(e,t=null,n=!1){let r=$i(e,"x","prod");"bool"===r.dtype&&(r=Xo(r,"int32"));const s={x:r},a={axis:t,keepDims:n};return gi.runKernel(Cr,s,a)}const Zm=Ri({prod_:Jm});
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Qm(e,t,n,r){const s=e.map(((e,t)=>$i(e,`tensors${t}`,"raggedGather","int32"))),a=$i(t,"paramsDenseValues","raggedGather"),i=$i(n,"indices","raggedGather","int32"),o={paramsNestedSplits:s,paramsDenseValues:a,indices:i},u={outputRaggedRank:r},l=gi.runKernel(Er,o,u);return{outputNestedSplits:l.slice(0,l.length-1),outputDenseValues:l[l.length-1]}}const eg=Ri({raggedGather_:Qm});
/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function tg(e,t,n){const r=$i(e,"starts","raggedRange"),s=$i(t,"limits","raggedRange",r.dtype),a=$i(n,"deltas","raggedRange",r.dtype),i={starts:r,limits:s,deltas:a},o=gi.runKernel(Rr,i);return{rtNestedSplits:o[0],rtDenseValues:o[1]}}const ng=Ri({raggedRange_:tg});
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function rg(e,t,n,r,s){const a=$i(e,"shape","raggedTensorToTensor","int32"),i=$i(t,"values","raggedTensorToTensor"),o=$i(n,"defaultValue","raggedTensorToTensor",i.dtype),u=r.map(((e,t)=>$i(e,`tensors${t}`,"raggedTensorToTensor","int32"))),l={shape:a,values:i,defaultValue:o,rowPartitionTensors:u},c={rowPartitionTypes:s};return gi.runKernel(Ar,l,c)}const sg=Ri({raggedTensorToTensor_:rg});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ag(e,t,n){nt(e);const r=Ie(e);let s=null;if(null==n||"float32"===n)s=new Float32Array(r);else if("int32"===n)s=new Int32Array(r);else{if("bool"!==n)throw new Error(`Unknown data type ${n}`);s=new Uint8Array(r)}for(let a=0;a<r;a++)s[a]=t();return gi.makeTensor(s,e,n)}const ig=Ri({rand_:ag});var og=n(70928);
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class ug{constructor(e,t,n,r,s){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const a=s||Math.random();this.random=og.alea(a.toString())}nextValue(){if(!isNaN(this.nextVal)){const e=this.nextVal;return this.nextVal=NaN,e}let e,t,n=!1;while(!n){let r,s,a;do{r=2*this.random()-1,s=2*this.random()-1,a=r*r+s*s}while(a>=1||0===a);const i=Math.sqrt(-2*Math.log(a)/a);e=this.mean+this.stdDev*r*i,t=this.mean+this.stdDev*s*i,this.truncated&&!this.isValidTruncated(e)||(n=!0)}return this.truncated&&!this.isValidTruncated(t)||(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return null==this.dtype||"float32"===this.dtype?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class lg{constructor(e,t,n,r){this.alpha=e,this.beta=1/t,this.dtype=n;const s=r||Math.random();this.randu=og.alea(s.toString()),this.randn=new ug(0,1,n,!1,this.randu()),this.d=e<1?e+2/3:e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,n,r,s,a;while(1){do{r=this.randn.nextValue(),a=1+this.c*r}while(a<=0);if(a*=a*a,e=r*r,t=1-.331*e*e,n=.5*e+this.d*(1-a+Math.log(a)),s=this.randu(),s<t||Math.log(s)<n)break}return a=1/this.beta*this.d*a,this.alpha<1&&(a*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(a)}convertValue(e){return"float32"===this.dtype?e:Math.round(e)}}class cg{constructor(e=0,t=1,n,r){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=e,this.range=t-e,this.dtype=n,null==r&&(r=Math.random()),"number"===typeof r&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=og.alea(r)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function hg(e,t,n=1,r="float32",s){if(nt(e),null==n&&(n=1),null==r&&(r="float32"),"float32"!==r&&"int32"!==r)throw new Error(`Unsupported data type ${r}`);const a=new lg(t,n,r,s),i=qo(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=a.nextValue();return i.toTensor()}const pg=Ri({randomGamma_:hg});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function dg(e,t=0,n=1,r,s){if(nt(e),null!=r&&"bool"===r)throw new Error(`Unsupported data type ${r}`);const a=new ug(t,n,r,!1,s),i=qo(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=a.nextValue();return i.toTensor()}const fg=Ri({randomNormal_:dg});
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function mg(e,t,n){if(null!=t&&"bool"===t)throw new Error(`Unsupported data type ${t}`);return fg(e,0,1,t,n)}const gg=Ri({randomStandardNormal_:mg});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function yg(e,t=0,n=1,r="float32",s){nt(e);const a=qo(e,r),i=new cg(t,n,null,s);for(let o=0;o<a.values.length;o++)a.values[o]=i.nextValue();return a.toTensor()}const bg=Ri({randomUniform_:yg});
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function xg(e,t,n,r){return bg(e,t,n,"int32",r)}const wg=Ri({randomUniformInt_:xg});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function vg(e,t,n=1,r="float32"){if(0===n)throw new Error("Cannot have a step of zero");const s={start:e,stop:t,step:n,dtype:r};return gi.runKernel(Fr,{},s)}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function kg(e){const t=$i(e,"x","reciprocal"),n={x:t};return gi.runKernel(Dr,n)}const Ig=Ri({reciprocal_:kg});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Ng(e){const t=$i(e,"x","relu"),n={x:t};return gi.runKernel(Or,n)}const Sg=Ri({relu_:Ng});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Tg(e){const t=$i(e,"x","relu6"),n={x:t};return gi.runKernel(Wr,n)}const $g=Ri({relu6_:Tg});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Cg(e,t){const n=$i(e,"x","reverse"),r={x:n},s={dims:t};return gi.runKernel(Vr,r,s)}const Eg=Ri({reverse_:Cg});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Rg(e){const t=$i(e,"x","reverse");return we(1===t.rank,(()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`)),Eg(t,0)}const Ag=Ri({reverse1d_:Rg});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Fg(e,t){const n=$i(e,"x","reverse");return we(2===n.rank,(()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`)),Eg(n,t)}const _g=Ri({reverse2d_:Fg});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Dg(e,t){const n=$i(e,"x","reverse");return we(3===n.rank,(()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`)),Eg(n,t)}const Og=Ri({reverse3d_:Dg});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Mg(e,t){const n=$i(e,"x","reverse");return we(4===n.rank,(()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`)),Eg(n,t)}const Lg=Ri({reverse4d_:Mg});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function zg(e){const t=$i(e,"x","round"),n={x:t};return gi.runKernel(Ur,n)}const Pg=Ri({round_:zg});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Bg(e){const t=$i(e,"x","rsqrt","float32"),n={x:t};return gi.runKernel(Gr,n)}const Wg=Ri({rsqrt_:Bg});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Vg(e){const t=$i(e,"x","selu"),n={x:t};return gi.runKernel(Xr,n)}const Ug=Ri({selu_:Vg});function Gg(e,t,n,r,s,a=[1,1],i="NHWC"){const o=$i(e,"x","separableConv2d"),u=$i(t,"depthwiseFilter","separableConv2d"),l=$i(n,"pointwiseFilter","separableConv2d");let c=o,h=!1;if(3===o.rank&&(h=!0,c=Xh(o,[1,o.shape[0],o.shape[1],o.shape[2]])),"NCHW"===i)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");we(4===c.rank,(()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`)),we(4===u.rank,(()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${u.rank}.`)),we(4===l.rank,(()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${u.rank}.`)),we(1===l.shape[0],(()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${l.shape[0]}.`)),we(1===l.shape[1],(()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${l.shape[1]}.`));const p=u.shape[2],d=u.shape[3];we(l.shape[2]===p*d,(()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${p*d}, but got ${l.shape[2]}.`));const f=fd(c,u,r,s,i,a),m=1,g=Vp(f,l,m,"valid",i);return h?Xh(g,[g.shape[1],g.shape[2],g.shape[3]]):g}const Hg=Ri({separableConv2d_:Gg});
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
async function jg(e,t){const n=$i(e,"x","setdiff1d"),r=$i(t,"y","setdiff1d");we(n.dtype===r.dtype,(()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${r.dtype}).`)),we(1===n.rank,(()=>`x should be 1D tensor, but got x (${n.shape}).`)),we(1===r.rank,(()=>`y should be 1D tensor, but got y (${r.shape}).`));const s=await n.data(),a=await r.data(),i=new Set(a);let o=0;for(let c=0;c<s.length;c++)i.has(s[c])||o++;const u=new Pa([o],n.dtype),l=new Pa([o],"int32");for(let c=0,h=0;c<s.length;c++)i.has(s[c])||(u.values[h]=s[c],l.values[h]=c,h++);return[u.toTensor(),l.toTensor()]}const qg=jg;
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Kg(e){const t=$i(e,"x","sign"),n={x:t};return gi.runKernel(Qr,n)}const Xg=Ri({sign_:Kg});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Yg(e){const t=$i(e,"x","sin","float32"),n={x:t};return gi.runKernel(Jr,n)}const Jg=Ri({sin_:Yg});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Zg(e){const t=$i(e,"x","sinh"),n={x:t};return gi.runKernel(Zr,n)}const Qg=Ri({sinh_:Zg});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ey(e,t,n){const r=$i(e,"x","slice1d");return we(1===r.rank,(()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`)),ap(r,[t],[n])}const ty=Ri({slice1d_:ey});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ny(e,t,n){const r=$i(e,"x","slice2d");return we(2===r.rank,(()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`)),ap(r,t,n)}const ry=Ri({slice2d_:ny});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function sy(e,t,n){const r=$i(e,"x","slice3d");return we(3===r.rank,(()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`)),ap(r,t,n)}const ay=Ri({slice3d_:sy});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function iy(e,t,n){const r=$i(e,"x","slice4d");return we(4===r.rank,(()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`)),ap(r,t,n)}const oy=Ri({slice4d_:iy});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function uy(e,t=-1){const n=$i(e,"logits","softmax","float32");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);const r={logits:n},s={dim:t};return gi.runKernel(is,r,s)}const ly=Ri({softmax_:uy});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function cy(e){we("complex64"===e.dtype,(()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`));const t={input:e};return gi.runKernel(Sn,t)}const hy=Ri({fft_:cy});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function py(e){we("complex64"===e.dtype,(()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`));const t={input:e};return gi.runKernel(Mn,t)}const dy=Ri({ifft_:py});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function fy(e){const t=e.shape[e.shape.length-1],n=e.size/t;let r;if(t<=2){const s=Xh(e,[n,t]);r=dy(s)}else{const s=[n,2*(t-1)],a=Xh(ec(e),[n,t]),i=Xh(Yl(e),[n,t]),o=Eg(ap(a,[0,1],[n,t-2]),1),u=Cu(Eg(ap(i,[0,1],[n,t-2]),1),Vu(-1)),l=tp([a,o],1),c=tp([i,u],1),h=Xh(Fi(l,c),[s[0],s[1]]);r=dy(h)}if(r=ec(r),3===e.rank&&0!==e.shape[0]){const t=r,n=e.shape[0];r=Xh(r,[n,r.shape[0]/n,r.shape[1]]),t.dispose()}return r}const my=Ri({irfft_:fy});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function gy(e,t,n=0){const r=$i(e,"x","split"),s={x:r},a={numOrSizeSplits:t,axis:n};return gi.runKernel(as,s,a)}const yy=Ri({split_:gy});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function by(e,t){we("float32"===e.dtype,(()=>`The dtype for rfft() must be real value but got ${e.dtype}`));let n=e.shape[e.shape.length-1];const r=e.size/n;let s;if(null!=t&&t<n){const r=e.shape.map((e=>0)),a=e.shape.map((e=>e));a[e.shape.length-1]=t,s=ap(e,r,a),n=t}else if(null!=t&&t>n){const r=e.shape.map((e=>e));r[e.shape.length-1]=t-n,s=tp([e,pm(r)],e.shape.length-1),n=t}else s=e;const a=Du(s),i=Xh(Fi(s,a),[r,n]),o=hy(i),u=Math.floor(n/2)+1,l=ec(o),c=Yl(o),h=yy(l,[u,n-u],l.shape.length-1),p=yy(c,[u,n-u],c.shape.length-1),d=s.shape.slice();return d[s.shape.length-1]=u,Xh(Fi(h[0],p[0]),d)}const xy=Ri({rfft_:by});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function wy(e,t){let n=$i(e,"a","squaredDifference"),r=$i(t,"b","squaredDifference");[n,r]=ai(n,r),ul(n.shape,r.shape);const s={a:n,b:r},a={};return gi.runKernel(ps,s,a)}const vy=Ri({squaredDifference_:wy});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ky(e,t){const n=$i(e,"x","squeeze","string_or_numeric");return Xh(n,Oe(n.shape,t).newShape)}const Iy=Ri({squeeze_:ky});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Ny(e,t=0){const n=Ci(e,"tensors","stack","string_or_numeric");we(n.length>=1,(()=>"Pass at least one tensor to tf.stack")),n.length>0&&we(t<=n[0].rank,(()=>"Axis must be <= rank of the tensor"));const r=n,s={axis:t};return gi.runKernel(Ir,r,s)}const Sy=Ri({stack_:Ny});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Ty(e,t=0){const n=$i(e,"x","step"),r={x:n},s={alpha:t};return gi.runKernel(As,r,s)}const $y=Ri({step_:Ty});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Cy(e,t,n,r,s=0,a=0,i=0,o=0,u=0){const l=$i(e,"x","stridedSlice","string_or_numeric"),c={x:l},h={begin:t,end:n,strides:r,beginMask:s,endMask:a,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:u};return gi.runKernel(ms,c,h)}const Ey=Ri({stridedSlice_:Cy});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Ry(e){const t=$i(e,"x","tan","float32"),n={x:t};return gi.runKernel(ws,n)}const Ay=Ri({tan_:Ry});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Fy(e,t){ke(e);const n=Ni(e,t);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");const r=null;return _i(e,r,n,t)}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function _y(e,t,n){if(ke(e),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");const r=Ni(e,n);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return _i(e,t,r,n)}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Dy(e,t,n){if(ke(e),null!=t&&4!==t.length)throw new Error("tensor4d() requires shape to have four numbers");const r=Ni(e,n);if(4!==r.length&&1!==r.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return _i(e,t,r,n)}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Oy(e,t,n){if(ke(e),null!=t&&5!==t.length)throw new Error("tensor5d() requires shape to have five numbers");const r=Ni(e,n);if(5!==r.length&&1!==r.length)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return _i(e,t,r,n)}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function My(e,t,n){if(ke(e),null!=t&&6!==t.length)throw new Error("tensor6d() requires shape to have six numbers");const r=Ni(e,n);if(6!==r.length&&1!==r.length)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return t=t||r,_i(e,t,r,n)}
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Ly(e,t,n){const r=$i(e,"tensor","tensorScatterupdate"),s=$i(t,"indices","tensorScatterupdate","int32"),a=$i(n,"updates","tensorScatterupdate");if(vc(a,s,r.shape),r.dtype!==a.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${r.dtype} and ${a.dtype}.`);const i={tensor:r,indices:s,updates:a},o={};return gi.runKernel(jr,i,o)}const zy=Ri({tensorScatterUpdate_:Ly});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Py(e,t=1,n=!0){const r=$i(e,"x","topk");if(0===r.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const s=r.shape[r.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>s)throw new Error(`'k' passed to topk() must be <= the last dimension (${s}) but got ${t}`);const a={x:r},i={k:t,sorted:n},[o,u]=gi.runKernel(Is,a,i);return{values:o,indices:u}}const By=Ri({topk_:Py});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Wy(e,t=0,n=1,r,s){if(nt(e),null!=r&&"bool"===r)throw new Error("Unsupported data type $ { dtype }");const a=new ug(t,n,r,!0,s),i=qo(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=a.nextValue();return i.toTensor()}const Vy=Ri({truncatedNormal_:Wy});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Uy(e,t=0){const n=$i(e,"x","unique","string_or_numeric");we(n.rank>0,(()=>"The input tensor must be at least 1D"));const r={x:n},s={axis:t},[a,i]=gi.runKernel(Ts,r,s);return{values:a,indices:i}}const Gy=Ri({unique_:Uy});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Hy(e,t,n){const r=$i(e,"x","unsortedSegmentSum"),s=$i(t,"segmentIds","unsortedSegmentSum","int32");we($e(n),(()=>"numSegments must be of dtype int"));const a={x:r,segmentIds:s},i={numSegments:n};return gi.runKernel(Cs,a,i)}const jy=Ri({unsortedSegmentSum_:Hy});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function qy(e,t=0){const n=$i(e,"x","unstack","string_or_numeric");we(t>=-n.shape.length&&t<n.shape.length,(()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`));const r={value:n},s={axis:t};return gi.runKernel($s,r,s)}const Ky=Ri({unstack_:qy});
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Xy(e,t){return nm(e,t,"right")}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Yy(e,t=!0,n,r){return gi.makeVariable(e,t,n,r)}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Jy(e,t){const n=[];for(let a=0;a<t.length;a++)t[a]&&n.push(a);const r=qo(e,"int32"),s=qo([n.length,e.length],"int32");for(let a=0;a<n.length;a++){const t=r.indexToLoc(n[a]),i=a*e.length;s.values.set(t,i)}return s.toTensor()}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
async function Zy(e){const t=$i(e,"condition","whereAsync","bool"),n=await t.data(),r=Jy(t.shape,n);return e!==t&&t.dispose(),r}const Qy=Zy;
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
async function eb(e,t,n){const r=$i(e,"tensor","boolMask"),s=$i(t,"mask","boolMask","bool"),a=null==n?0:n,i=s.rank,o=r.shape;we(i>0,(()=>"mask cannot be scalar")),ve(o.slice(a,a+i),s.shape,"mask's shape must match the first K dimensions of tensor's shape,");let u=1;for(let m=a;m<a+i;m++)u*=o[m];const l=o.slice(0,a).concat([u],o.slice(a+i)),c=Xh(r,l),h=Xh(s,[-1]),p=await Qy(h),d=Iy(p,[1]),f=ff(c,d,a);return e!==r&&r.dispose(),t!==s&&s.dispose(),d.dispose(),c.dispose(),h.dispose(),p.dispose(),f}const tb=eb;
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function nb(e,t,n,r,s=!0){const a=$i(e,"v","movingAverage"),i=$i(t,"x","movingAverage"),o=$i(n,"decay","movingAverage");ii(a,i),we(Te(a.shape,i.shape),(()=>"Shape mismatch in v and x"));const u=Vu(1),l=nl(u,o);let c=Cu(nl(i,a),l);if(s){we(null!=r,(()=>"When using zeroDebias: true, step is required."));const e=$i(r,"step","movingAverage");c=Tu(c,nl(u,el(o,e)))}return ku(a,c)}const rb=Ri({movingAverage_:nb});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function sb(e,t,n){nt(n);const r=$i(e,"indices","scatterND","int32"),s=$i(t,"updates","scatterND");vc(s,r,n);const a={indices:r,updates:s},i={shape:n};return gi.runKernel(Hr,a,i)}const ab=Ri({scatterND_:sb});function ib(e,t,n,r){if("int32"!==e.dtype)throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${e.shape}.`);const s=e.rank>0?e.shape[0]:1,a=e.rank>1?e.shape[1]:1;if(n.length!==a)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${a}.`);const i=t.size;if(0!==t.rank&&(1!==t.rank||i!==s))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${s}]`);if(t.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ob(e,t,n,r=0){nt(n);const s=$i(e,"sparseIndices","sparseToDense","int32"),a=$i(t,"sparseValues","sparseToDense","string_or_numeric"),i=$i(r,"defaultValue","sparseToDense",a.dtype);ib(s,a,n,i);const o={sparseIndices:s,sparseValues:a,defaultValue:i},u={outputShape:n};return gi.runKernel(hs,o,u)}const ub=Ri({sparseToDense_:ob});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function lb(e,t){const n=$i(t,"indices","gatherND","int32"),r=$i(e,"x","gatherND","string_or_numeric"),s={params:r,indices:n};return gi.runKernel(Fn,s)}const cb=Ri({gatherND_:lb});
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function hb(e,t){if(null==t)return e.shape.slice();if(Te(e.shape,t))return t;if(e.shape.length===t.length){const n=[];for(let r=0;r<e.shape.length;r++)null==t[r]&&null!=e.shape[r]?n.push(e.shape[r]):n.push(t[r]);return n}return t}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function pb(e,t,n,r){const s=$i(e,"x","dropout");if(we("float32"===s.dtype,(()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${s.dtype} tensor instead.`)),we(t>=0&&t<1,(()=>`rate must be a float in the range [0, 1), but got ${t}.`)),0===t)return e instanceof ja?s.clone():s;const a=hb(s,n),i=1-t,o=Tu(pf(ku(bg(a,0,1,"float32",r),i)),i);return Cu(s,o)}const db=Ri({dropout_:pb});
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function fb(e){return Math.floor(Math.pow(2,Math.ceil(Math.log(e)/Math.log(2))))}function mb(e,t,n){const r=1-e%2,s=new Float32Array(e);for(let a=0;a<e;++a){const i=2*Math.PI*a/(e+r-1);s[a]=t-n*Math.cos(i)}return Fy(s,"float32")}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
async function gb(e,t,n=1){const r=$i(e,"predictions","inTopK"),s=$i(t,"targets","inTopK");we(r.rank>1,(()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`)),we(r.rank-1===s.rank,(()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${s.rank}`)),ve(r.shape.slice(0,r.shape.length-1),s.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const a=r.shape[r.shape.length-1];we(n>0&&n<=a,(()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${a}), but got ${n}`));const i=await r.data(),o=await s.data(),[u,l]=[i.length/a,a],c=Me("bool",u);for(let h=0;h<u;h++){const e=h*l,t=i.subarray(e,e+l),r=[];for(let n=0;n<t.length;n++)r.push({value:t[n],index:n});r.sort(((e,t)=>t.value-e.value)),c[h]=0;for(let s=0;s<n;s++)if(r[s].index===o[h]){c[h]=1;break}}return e!==r&&r.dispose(),t!==s&&s.dispose(),Di(c,s.shape,"bool")}const yb=gb;
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function bb(e,t,n,r,s,a="NHWC",i){let o=e;3===e.rank&&(o=Xh(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let u=t;3===u.rank&&(u=Xh(t,[1,t.shape[0],t.shape[1],t.shape[2]])),we(4===o.rank,(()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${o.shape}.`)),we(4===u.rank,(()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${u.shape}.`)),we(4===n.length,(()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`));const l="NHWC"===a?o.shape[3]:o.shape[1],c="NHWC"===a?u.shape[3]:u.shape[1];we(l===n[2],(()=>`Error in conv2dDerFilter: depth of input ${l}) must match input depth in filter (${n[2]}.`)),we(c===n[3],(()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${n[3]}).`)),qh("conv2dDerFilter",s,i);const h={x:o,dy:u},p={strides:r,pad:s,dataFormat:a,dimRoundingMode:i,filterShape:n};return gi.runKernel(Xt,h,p)}const xb=Ri({conv2DBackpropFilter_:bb});
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function wb(e,t,n){if(null==n||"linear"===n)return e;if("relu"===n)return Cu(e,$y(t));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function vb(e,t){let n=t;const r=ol(e.shape,t.shape);return r.length>0&&(n=Kd(n,r)),Xh(n,e.shape)}function kb(e,t,n,r){if("linear"===t)return e;if("relu"===t)return Sg(e);if("elu"===t)return Rd(e);if("relu6"===t)return $g(e);if("prelu"===t)return Ym(e,n);if("leakyrelu"===t)return Tf(e,r);if("sigmoid"===t)return rp(e);throw new Error(`Unknown fused activation ${t}.`)}const Ib=(e,t)=>{const n=e>0;return!n||"linear"===t};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Nb({x:e,filter:t,strides:n,pad:r,dataFormat:s="NHWC",dilations:a=[1,1],dimRoundingMode:i,bias:o,activation:u="linear",preluActivationWeights:l,leakyreluAlpha:c}){if(u=u||"linear",!1===Ib(gi.state.gradientDepth,u)){we("NHWC"===s,(()=>`Error in fused conv2d: got dataFormat of ${s} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`));let h=Vp(e,t,n,r,s,a,i);return null!=o&&(h=ku(h,o)),kb(h,u,l,c)}const h=$i(e,"x","conv2d","float32"),p=$i(t,"filter","conv2d","float32");let d=h,f=!1;3===h.rank&&(f=!0,d=Xh(h,[1,h.shape[0],h.shape[1],h.shape[2]])),we(4===d.rank,(()=>`Error in fused conv2d: input must be rank 4, but got rank ${d.rank}.`)),we(4===p.rank,(()=>`Error in fused conv2d: filter must be rank 4, but got rank ${p.rank}.`)),qh("fused conv2d",r,i);const m="NHWC"===s?d.shape[3]:d.shape[1];we(p.shape[2]===m,(()=>`Error in conv2d: depth of input (${m}) must match input depth for filter ${p.shape[2]}.`)),we(Gh(n,a),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`));const g=Fh(d.shape,p.shape,n,a,r,i);let y,b;if(null!=o&&(y=$i(o,"bias","fused conv2d"),[y]=ai(y,h),"NHWC"===s?ul(g.outShape,y.shape):(we(y.shape.length<=1,(()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${y.shape.length}.`)),we(0===y.shape.length||y.shape[0]===g.outChannels||1===y.shape[0],(()=>`Error in fused conv2d: bias shape (${y.shape}) is not compatible with the number of output channels (${g.outChannels})`)))),null!=l){const e=l.shape;if(we(e.length<=1||3===e.length,(()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${e.length}.`)),1===e.length)we(1===e[0]||e[0]===g.outChannels,(()=>`Error in fused conv2d: PReLU activation weights (${e}) is not compatible with the number of output channels (${g.outChannels}).`));else if(3===e.length)try{ul(e,g.outShape)}catch(k){const t=`Error in fused conv2d: PReLU activation weights (${e}) is not compatible with the output shape of the conv2d (${g.outShape}).`;throw Error(t)}b=$i(l,"prelu weights","fused conv2d")}const x=(e,t)=>{we("NHWC"===s,(()=>`Error in gradient of fused conv2D: got dataFormat of ${s} but only NHWC is currently supported.`));const[i,o,l,c]=t,h=wb(e,l,u);we(Uh(a),(()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`));const p=jp(o.shape,h,i,n,r),d=xb(o,h,i.shape,n,r),f=[p,d];if(null!=c){const e=vb(c,h);f.push(e)}return f},w={x:d,filter:p,bias:y,preluActivationWeights:b},v={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:i,activation:u,leakyreluAlpha:c};if(null==o){const e=Bu(((e,t,n)=>{let r=gi.runKernel(Os,w,v);return n([t,e,r]),f&&(r=Xh(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:x}}));return e(d,p)}{const e=Bu(((e,t,n,r)=>{let s=gi.runKernel(Os,w,v);return r([t,e,s,n]),f&&(s=Xh(s,[s.shape[1],s.shape[2],s.shape[3]])),{value:s,gradFunc:x}}));return e(d,p,y)}}const Sb=Ri({fusedConv2d_:Nb});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Tb(e,t,n,r,s,a=[1,1],i){let o=e;3===e.rank&&(o=Xh(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let u=t;3===u.rank&&(u=Xh(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const l={x:o,dy:u},c={strides:r,pad:s,dimRoundingMode:i,dilations:a,filterShape:n};return gi.runKernel(ln,l,c)}const $b=Ri({depthwiseConv2dNativeBackpropFilter_:Tb});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Cb(e,t,n,r,s,a=[1,1],i){let o=t,u=!1;3===t.rank&&(u=!0,o=Xh(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const l={dy:o,filter:n},c={strides:r,pad:s,dimRoundingMode:i,dilations:a,inputShape:e},h=gi.runKernel(cn,l,c);return u?Xh(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const Eb=Ri({depthwiseConv2dNativeBackpropInput_:Cb});
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Rb({x:e,filter:t,strides:n,pad:r,dataFormat:s="NHWC",dilations:a=[1,1],dimRoundingMode:i,bias:o,activation:u="linear",preluActivationWeights:l,leakyreluAlpha:c}){if(!1===Ib(gi.state.gradientDepth,u)){let h=fd(e,t,n,r,s,a,i);return null!=o&&(h=ku(h,o)),kb(h,u,l,c)}const h=$i(e,"x","depthwiseConv2d","float32"),p=$i(t,"filter","depthwiseConv2d","float32");let d=h,f=!1;3===h.rank&&(f=!0,d=Xh(h,[1,h.shape[0],h.shape[1],h.shape[2]])),we(4===d.rank,(()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${d.rank}.`)),we(4===p.rank,(()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${p.rank}.`)),we(d.shape[3]===p.shape[2],(()=>`Error in fused depthwiseConv2d: number of input channels (${d.shape[3]}) must match the inChannels dimension in filter ${p.shape[2]}.`)),null==a&&(a=[1,1]),we(Gh(n,a),(()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`)),qh("fused depthwiseConv2d",r,i);const m=Fh(d.shape,p.shape,n,a,r,i,!0);let g,y;null!=o&&(g=$i(o,"bias","fused conv2d"),[g]=ai(g,h),ul(m.outShape,g.shape)),null!=l&&(y=$i(l,"prelu weights","fused depthwiseConv2d"));const b=(e,t)=>{we(Uh(a),(()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`));const[s,o,l,c]=t,h=wb(e,l,u),p=Eb(o.shape,h,s,n,r,a,i),d=$b(o,h,s.shape,n,r,a,i);if(null!=c){const e=vb(g,h);return[p,d,e]}return[p,d]},x={x:d,filter:p,bias:g,preluActivationWeights:y},w={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:i,activation:u,leakyreluAlpha:c};if(null==o){const e=Bu(((e,t,n)=>{let r=gi.runKernel(Ms,x,w);return n([t,e,r]),f&&(r=Xh(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:b}}));return e(d,p)}{const e=Bu(((e,t,n,r)=>{let s=gi.runKernel(Ms,x,w);return r([t,e,s,n]),f&&(s=Xh(s,[s.shape[1],s.shape[2],s.shape[3]])),{value:s,gradFunc:b}}));return e(d,p,g)}}const Ab=Ri({fusedDepthwiseConv2d_:Rb});
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Fb({a:e,b:t,transposeA:n=!1,transposeB:r=!1,bias:s,activation:a="linear",preluActivationWeights:i,leakyreluAlpha:o=.2}){if(!1===Ib(gi.state.gradientDepth,a)){let u=jl(e,t,n,r);return null!=s&&(u=ku(u,s)),kb(u,a,i,o)}let u=$i(e,"a","fused matMul"),l=$i(t,"b","fused matMul");[u,l]=ai(u,l);const c=n?u.shape[u.rank-2]:u.shape[u.rank-1],h=r?l.shape[l.rank-1]:l.shape[l.rank-2],p=n?u.shape[u.rank-1]:u.shape[u.rank-2],d=r?l.shape[l.rank-2]:l.shape[l.rank-1],f=u.shape.slice(0,-2),m=l.shape.slice(0,-2),g=Ie(f),y=Ie(m);we(c===h,(()=>`Error in fused matMul: inner shapes (${c}) and (${h}) of Tensors with shapes ${u.shape} and ${l.shape} and transposeA=${n} and transposeB=${r} must match.`));const b=ul(u.shape.slice(0,-2),l.shape.slice(0,-2)),x=b.concat([p,d]),w=Xh(u,n?[g,c,p]:[g,p,c]),v=Xh(l,r?[y,d,h]:[y,h,d]);let k,I;null!=s&&(k=$i(s,"bias","fused matMul"),[k]=ai(k,u),ul(x,k.shape)),null!=i&&(I=$i(i,"prelu weights","fused matMul"));const N=(e,t)=>{const[i,o,u,l]=t,c=wb(Xh(e,u.shape),u,a);let h,p;if(n||r?!n&&r?(h=jl(c,o,!1,!1),p=jl(c,i,!0,!1)):n&&!r?(h=jl(o,c,!1,!0),p=jl(i,c,!1,!1)):(h=jl(o,c,!0,!0),p=jl(c,i,!0,!0)):(h=jl(c,o,!1,!0),p=jl(i,c,!0,!1)),null!=s){const e=vb(l,c);return[h,p,e]}return[h,p]},S={a:w,b:v,bias:k,preluActivationWeights:I},T={transposeA:n,transposeB:r,activation:a,leakyreluAlpha:o};if(null==s){const e=Bu(((e,t,n)=>{const r=gi.runKernel(Ds,S,T);return n([e,t,r]),{value:Xh(r,x),gradFunc:N}}));return e(w,v)}{const e=Bu(((e,t,n,r)=>{const s=gi.runKernel(Ds,S,T);return r([e,t,s,n]),{value:Xh(s,x),gradFunc:N}}));return e(w,v,k)}}const _b=Ri({fusedMatMul_:Fb});
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Db(e){return mb(e,.54,.46)}const Ob=Ri({hammingWindow_:Db});
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Mb(e){return mb(e,.5,.5)}const Lb=Ri({hannWindow_:Mb});
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function zb(e,t,n,r=!1,s=0){let a=0;const i=[];while(a+t<=e.size)i.push(ap(e,a,t)),a+=n;if(r)while(a<e.size){const r=a+t-e.size,o=tp([ap(e,a,t-r),Ju([r],s)]);i.push(o),a+=n}return 0===i.length?_y([],[0,t]):Xh(tp(i),[i.length,t])}const Pb=Ri({frame_:zb});
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Bb(e,t,n,r,s=Lb){null==r&&(r=fb(t));const a=Pb(e,t,n),i=Cu(a,s(t));return xy(i,r)}const Wb=Ri({stft_:Bb});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Vb(e,t,n,r,s="bilinear",a=0){const i=$i(e,"image","cropAndResize"),o=$i(t,"boxes","cropAndResize","float32"),u=$i(n,"boxInd","cropAndResize","int32"),l=o.shape[0];we(4===i.rank,(()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`)),we(2===o.rank&&4===o.shape[1],(()=>`Error in cropAndResize: boxes must be have size [${l},4] but had shape ${o.shape}.`)),we(1===u.rank&&u.shape[0]===l,(()=>`Error in cropAndResize: boxInd must be have size [${l}] but had shape ${o.shape}.`)),we(2===r.length,(()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`)),we(r[0]>=1&&r[1]>=1,(()=>`cropSize must be atleast [1,1], but was ${r}`)),we("bilinear"===s||"nearest"===s,(()=>`method must be bilinear or nearest, but was ${s}`));const c={image:i,boxes:o,boxInd:u},h={method:s,extrapolationValue:a,cropSize:r},p=gi.runKernel(sn,c,h);return p}const Ub=Ri({cropAndResize_:Vb});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Gb(e){const t=$i(e,"image","flipLeftRight","float32");we(4===t.rank,(()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`));const n={image:t},r=gi.runKernel($n,n,{});return r}const Hb=Ri({flipLeftRight_:Gb});
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function jb(e){const t=$i(e,"image","grayscaleToRGB"),n=t.rank-1,r=t.shape[n];we(t.rank>=2,(()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`)),we(1===r,(()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`));const s=new Array(t.rank);return s.fill(1,0,n),s[n]=3,uf(t,s)}const qb=Ri({grayscaleToRGB_:jb});
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Kb(e){const t=$i(e,"image","RGBToGrayscale"),n=t.rank-1,r=t.shape[n];we(t.rank>=2,(()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${t.rank}.`)),we(3===r,(()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${r}.`));const s=t.dtype,a=Xo(t,"float32"),i=Fy([.2989,.587,.114]);let o;switch(t.rank){case 2:o=Cd("ij,j->i",a,i);break;case 3:o=Cd("ijk,k->ij",a,i);break;case 4:o=Cd("ijkl,l->ijk",a,i);break;case 5:o=Cd("ijklm,m->ijkl",a,i);break;case 6:o=Cd("ijklmn,n->ijklm",a,i);break;default:throw new Error("Not a valid tensor rank.")}return o=rf(o,-1),Xo(o,s)}const Xb=Ri({rgbToGrayscale_:Kb});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Yb(e,t,n=0,r=.5){const s=$i(e,"image","rotateWithOffset","float32");we(4===s.rank,(()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${s.rank}.`));const a={image:s},i={radians:t,fillValue:n,center:r},o=gi.runKernel(_s,a,i);return o}const Jb=Ri({rotateWithOffset_:Yb});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Zb(e,t,n,r,s,a){null==r&&(r=.5),null==s&&(s=Number.NEGATIVE_INFINITY),null==a&&(a=0);const i=e.shape[0];return n=Math.min(n,i),we(0<=r&&r<=1,(()=>`iouThreshold must be in [0, 1], but was '${r}'`)),we(2===e.rank,(()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`)),we(4===e.shape[1],(()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`)),we(1===t.rank,(()=>"scores must be a 1D tensor")),we(t.shape[0]===i,(()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${t.shape[0]}`)),we(0<=a&&a<=1,(()=>`softNmsSigma must be in [0, 1], but was '${a}'`)),{maxOutputSize:n,iouThreshold:r,scoreThreshold:s,softNmsSigma:a}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Qb(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY){const a=$i(e,"boxes","nonMaxSuppression","float32"),i=$i(t,"scores","nonMaxSuppression","float32"),o=Zb(a,i,n,r,s);n=o.maxOutputSize,r=o.iouThreshold,s=o.scoreThreshold;const u={maxOutputSize:n,iouThreshold:r,scoreThreshold:s};return gi.runKernel(br,{boxes:a,scores:i},u)}const ex=Ri({nonMaxSuppression_:Qb});
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function tx(e,t,n){const r=nx(e,t,n),s=r<0?-(r+1):r;e.splice(s,0,t)}function nx(e,t,n){return sx(e,t,n||rx)}function rx(e,t){return e>t?1:e<t?-1:0}function sx(e,t,n){let r=0,s=e.length,a=0,i=!1;while(r<s){a=r+(s-r>>>1);const o=n(t,e[a]);o>0?r=a+1:(s=a,i=!o)}return i?r:-r-1}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ax(e,t,n,r,s){return ux(e,t,n,r,s,0)}function ix(e,t,n,r,s,a){return ux(e,t,n,r,s,0,!1,a,!0)}function ox(e,t,n,r,s,a){return ux(e,t,n,r,s,a,!0)}function ux(e,t,n,r,s,a,i=!1,o=!1,u=!1){const l=[];for(let g=0;g<t.length;g++)t[g]>s&&l.push({score:t[g],boxIndex:g,suppressBeginIndex:0});l.sort(hx);const c=a>0?-.5/a:0,h=[],p=[];while(h.length<n&&l.length>0){const t=l.pop(),{score:n,boxIndex:a,suppressBeginIndex:i}=t;if(n<s)break;let o=!1;for(let u=h.length-1;u>=i;--u){const n=lx(e,a,h[u]);if(n>=r){o=!0;break}if(t.score=t.score*cx(r,c,n),t.score<=s)break}t.suppressBeginIndex=h.length,o||(t.score===n?(h.push(a),p.push(t.score)):t.score>s&&tx(l,t,hx))}const d=h.length,f=n-d;o&&f>0&&(h.push(...new Array(f).fill(0)),p.push(...new Array(f).fill(0)));const m={selectedIndices:h};return i&&(m["selectedScores"]=p),u&&(m["validOutputs"]=d),m}function lx(e,t,n){const r=e.subarray(4*t,4*t+4),s=e.subarray(4*n,4*n+4),a=Math.min(r[0],r[2]),i=Math.min(r[1],r[3]),o=Math.max(r[0],r[2]),u=Math.max(r[1],r[3]),l=Math.min(s[0],s[2]),c=Math.min(s[1],s[3]),h=Math.max(s[0],s[2]),p=Math.max(s[1],s[3]),d=(o-a)*(u-i),f=(h-l)*(p-c);if(d<=0||f<=0)return 0;const m=Math.max(a,l),g=Math.max(i,c),y=Math.min(o,h),b=Math.min(u,p),x=Math.max(y-m,0)*Math.max(b-g,0);return x/(d+f-x)}function cx(e,t,n){const r=Math.exp(t*n*n);return n<=e?r:0}function hx(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
async function px(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY){const a=$i(e,"boxes","nonMaxSuppressionAsync"),i=$i(t,"scores","nonMaxSuppressionAsync"),o=Zb(a,i,n,r,s);n=o.maxOutputSize,r=o.iouThreshold,s=o.scoreThreshold;const u=await Promise.all([a.data(),i.data()]),l=u[0],c=u[1],{selectedIndices:h}=ax(l,c,n,r,s);return a!==e&&a.dispose(),i!==t&&i.dispose(),Fy(h,"int32")}const dx=px;
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function fx(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=0){const i=$i(e,"boxes","nonMaxSuppression"),o=$i(t,"scores","nonMaxSuppression"),u=Zb(i,o,n,r,s,a);n=u.maxOutputSize,r=u.iouThreshold,s=u.scoreThreshold,a=u.softNmsSigma;const l={boxes:i,scores:o},c={maxOutputSize:n,iouThreshold:r,scoreThreshold:s,softNmsSigma:a},h=gi.runKernel(wr,l,c);return{selectedIndices:h[0],selectedScores:h[1]}}const mx=Ri({nonMaxSuppressionWithScore_:fx});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
async function gx(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=0){const i=$i(e,"boxes","nonMaxSuppressionAsync"),o=$i(t,"scores","nonMaxSuppressionAsync"),u=Zb(i,o,n,r,s,a);n=u.maxOutputSize,r=u.iouThreshold,s=u.scoreThreshold,a=u.softNmsSigma;const l=await Promise.all([i.data(),o.data()]),c=l[0],h=l[1],{selectedIndices:p,selectedScores:d}=ox(c,h,n,r,s,a);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:Fy(p,"int32"),selectedScores:Fy(d)}}const yx=gx;
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function bx(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=!1){const i=$i(e,"boxes","nonMaxSuppression"),o=$i(t,"scores","nonMaxSuppression"),u=Zb(i,o,n,r,s,null),l=u.maxOutputSize,c=u.iouThreshold,h=u.scoreThreshold,p={boxes:i,scores:o},d={maxOutputSize:l,iouThreshold:c,scoreThreshold:h,padToMaxOutputSize:a},f=gi.runKernel(xr,p,d);return{selectedIndices:f[0],validOutputs:f[1]}}const xx=Ri({nonMaxSuppressionPadded_:bx});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
async function wx(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=!1){const i=$i(e,"boxes","nonMaxSuppressionAsync"),o=$i(t,"scores","nonMaxSuppressionAsync"),u=Zb(i,o,n,r,s,null),l=u.maxOutputSize,c=u.iouThreshold,h=u.scoreThreshold,[p,d]=await Promise.all([i.data(),o.data()]),{selectedIndices:f,validOutputs:m}=ix(p,d,l,c,h,a);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:Fy(f,"int32"),validOutputs:Vu(m,"int32")}}const vx=wx;
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function kx(e,t,n=!1,r=!1){const s=$i(e,"images","resizeBilinear");we(3===s.rank||4===s.rank,(()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${s.rank}.`)),we(2===t.length,(()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`)),we(!1===r||!1===n,(()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false."));let a=s,i=!1;3===s.rank&&(i=!0,a=Xh(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const[]=t,o={images:a},u={alignCorners:n,halfPixelCenters:r,size:t},l=gi.runKernel(Pr,o,u);return i?Xh(l,[l.shape[1],l.shape[2],l.shape[3]]):l}const Ix=Ri({resizeBilinear_:kx});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Nx(e,t,n=!1,r=!1){const s=$i(e,"images","resizeNearestNeighbor");we(3===s.rank||4===s.rank,(()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${s.rank}.`)),we(2===t.length,(()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`)),we("float32"===s.dtype||"int32"===s.dtype,(()=>"`images` must have `int32` or `float32` as dtype")),we(!1===r||!1===n,(()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false."));let a=s,i=!1;3===s.rank&&(i=!0,a=Xh(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const[]=t,o={images:a},u={alignCorners:n,halfPixelCenters:r,size:t},l=gi.runKernel(Lr,o,u);return i?Xh(l,[l.shape[1],l.shape[2],l.shape[3]]):l}const Sx=Ri({resizeNearestNeighbor_:Nx});
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Tx(e,t="binary",n=!1,r=.5){const s=$i(e,"image","threshold"),a=.2989,i=.587,o=.114,u=s.shape[0]*s.shape[1];let l,c,h,p,d=Cu(Fy([r]),255);if(we(3===s.rank,(()=>`Error in threshold: image must be rank 3,but got rank ${s.rank}.`)),we(3===s.shape[2]||1===s.shape[2],(()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${s.shape[2]}.`)),we("int32"===s.dtype||"float32"===s.dtype,(()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${s.dtype}.`)),we("otsu"===t||"binary"===t,(()=>`Method must be binary or otsu, but was ${t}`)),3===s.shape[2]){[l,c,h]=yy(s,[1,1,1],-1);const e=Cu(l,a),t=Cu(c,i),n=Cu(h,o);p=ku(ku(e,t),n)}else p=e;if("otsu"===t){const e=kp(Xo(Pg(p),"int32"),Di([]),256);d=$x(e,u)}const f=n?Rf(p,d):gf(p,d),m=Xo(Cu(f,255),"int32");return m}function $x(e,t){let n,r,s,a,i,o,u=Fy([-1]),l=Fy([0]),c=Fy([0]);for(let h=0;h<e.size-1;h++){n=ap(e,0,h+1),r=ap(e,h+1),i=Tu(Kd(n),t),o=Tu(Kd(r),t);const p=Kd(Cu(n,vg(0,n.size)));s=Tu(p,Kd(n));const d=Ju(r.shape,n.size),f=ku(vg(0,r.size),d),m=Cu(r,f);a=Tu(Kd(m),Kd(r));const g=nl(s,a),y=nl(s,a),b=Cu(i,o);c=Cu(Cu(b,g),y);const x=gf(c,l);l=kd(x,c,l),u=kd(x,Fy([h]),u)}return u}const Cx=Ri({threshold_:Tx});
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Ex(e,t,n="nearest",r="constant",s=0,a){const i=$i(e,"image","transform","float32"),o=$i(t,"transforms","transform","float32");we(4===i.rank,(()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`)),we(2===o.rank&&(o.shape[0]===i.shape[0]||1===o.shape[0])&&8===o.shape[1],(()=>"Error in transform: Input transform should be batch x 8 or 1 x 8")),we(null==a||2===a.length,(()=>`Error in transform: outputShape must be [height, width] or null, but got ${a}.`));const u={image:i,transforms:o},l={interpolation:n,fillMode:r,fillValue:s,outputShape:a};return gi.runKernel(Ns,u,l)}const Rx=Ri({transform_:Ex});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Ax(e,t,n){const r=$i(e,"a","bandPart");we(r.rank>=2,(()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`));const s=r.shape,[a,i]=r.shape.slice(-2);let o,u;"number"===typeof t?(we(t%1===0,(()=>`bandPart(): numLower must be an integer, got ${t}.`)),we(t<=a,(()=>`bandPart(): numLower (${t}) must not be greater than the number of rows (${a}).`)),o=$i(t<0?a:t,"numLower","bandPart")):(we("int32"===t.dtype,(()=>"bandPart(): numLower's dtype must be an int32.")),o=kd(Cf(t,0),a,gm(t,a))),"number"===typeof n?(we(n%1===0,(()=>`bandPart(): numUpper must be an integer, got ${n}.`)),we(n<=i,(()=>`bandPart(): numUpper (${n}) must not be greater than the number of columns (${i}).`)),u=$i(n<0?i:n,"numUpper","bandPart")):(we("int32"===n.dtype,(()=>"bandPart(): numUpper's dtype must be an int32.")),u=kd(Cf(n,0),i,gm(n,i)));const l=Xh(vg(0,a,1,"int32"),[-1,1]),c=vg(0,i,1,"int32"),h=nl(l,c),p=qf(Rf(h,o),bf(h,Zl(u))),d=pm([a,i],r.dtype);return Xh(Sy(Ky(Xh(r,[-1,a,i])).map((e=>kd(p,e,d)))),s)}const Fx=Ri({bandPart_:Ax});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function _x(e){let t;if(Array.isArray(e)){t=!1,we(null!=e&&e.length>0,(()=>"Gram-Schmidt process: input must not be null, undefined, or empty"));const n=e[0].shape[0];for(let t=1;t<e.length;++t)we(e[t].shape[0]===n,(()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[t].shape[0]} vs. ${n})`))}else t=!0,e=yy(e,e.shape[0],0).map((e=>Iy(e,[0])));we(e.length<=e[0].shape[0],(()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`));const n=[],r=e;for(let s=0;s<e.length;++s)n.push(gi.tidy((()=>{let e=r[s];if(s>0)for(let t=0;t<s;++t){const r=Cu(Kd(Cu(n[t],e)),n[t]);e=nl(e,r)}return Tu(e,Jd(e,"euclidean"))})));return t?Sy(n,0):n}const Dx=Ri({gramSchmidt_:_x});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Ox(e,t=!1){if(we(e.rank>=2,(()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`)),2===e.rank)return Mx(e,t);{const n=e.shape.slice(0,e.shape.length-2).reduce(((e,t)=>e*t)),r=Ky(Xh(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),s=[],a=[];r.forEach((e=>{const[n,r]=Mx(e,t);s.push(n),a.push(r)}));const i=Xh(Sy(s,0),e.shape),o=Xh(Sy(a,0),e.shape);return[i,o]}}function Mx(e,t=!1){return gi.tidy((()=>{we(2===e.shape.length,(()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`));const n=e.shape[0],r=e.shape[1];let s=cf(n),a=Jo(e);const i=_y([[1]],[1,1]);let o=Jo(i);const u=n>=r?r:n;for(let e=0;e<u;++e){const t=a,u=o,l=s;[o,a,s]=gi.tidy((()=>{const t=ap(a,[e,e],[n-e,1]),u=Jd(t),l=ap(a,[e,e],[1,1]),c=kd(gf(l,0),_y([[-1]]),_y([[1]])),h=nl(l,Cu(c,u)),p=Tu(t,h);o=1===p.shape[0]?Jo(i):tp([i,ap(p,[1,0],[p.shape[0]-1,p.shape[1]])],0);const d=Zl(Tu(jl(c,h),u)),f=ap(a,[e,0],[n-e,r]),m=Cu(d,o),g=nc(o);if(0===e)a=nl(f,jl(m,jl(g,f)));else{const t=nl(f,jl(m,jl(g,f)));a=tp([ap(a,[0,0],[e,r]),t],0)}const y=nc(m),b=ap(s,[0,e],[n,s.shape[1]-e]);if(0===e)s=nl(b,jl(jl(b,o),y));else{const t=nl(b,jl(jl(b,o),y));s=tp([ap(s,[0,0],[n,e]),t],1)}return[o,a,s]})),lu([t,u,l])}return!t&&n>r&&(s=ap(s,[0,0],[n,r]),a=ap(a,[0,0],[r,r])),[s,a]}))}const Lx=Ri({qr_:Ox});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var zx;function Px(e,t,n=zx.SUM_BY_NONZERO_WEIGHTS){const r=$i(e,"losses","computeWeightedLoss");let s=null;null!=t&&(s=$i(t,"weights","computeWeightedLoss"));const a=null==s?r:Cu(r,s);if(n===zx.NONE)return a;if(n===zx.SUM)return Kd(a);if(n===zx.MEAN){if(null==s)return hm(a);{const e=r.size/s.size,t=Tu(Kd(a),Kd(s));return e>1?Tu(t,Vu(e)):t}}if(n===zx.SUM_BY_NONZERO_WEIGHTS){if(null==s)return Tu(Kd(a),Vu(r.size));{const e=Cu(s,dm(r.shape)),t=Xo(Kd(Cm(e,Vu(0))),"float32");return Tu(Kd(a),t)}}throw Error(`Unknown reduction: ${n}`)}(function(e){e[e["NONE"]=0]="NONE",e[e["MEAN"]=1]="MEAN",e[e["SUM"]=2]="SUM",e[e["SUM_BY_NONZERO_WEIGHTS"]=3]="SUM_BY_NONZERO_WEIGHTS"})(zx||(zx={}));const Bx=Ri({computeWeightedLoss_:Px});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Wx(e,t,n,r=zx.SUM_BY_NONZERO_WEIGHTS){const s=$i(e,"labels","absoluteDifference"),a=$i(t,"predictions","absoluteDifference");let i=null;null!=n&&(i=$i(n,"weights","absoluteDifference")),ve(s.shape,a.shape,"Error in absoluteDifference: ");const o=al(nl(s,a));return Bx(o,i,r)}const Vx=Ri({absoluteDifference_:Wx});function Ux(e,t,n,r,s=zx.SUM_BY_NONZERO_WEIGHTS){const a=$i(e,"labels","cosineDistance"),i=$i(t,"predictions","cosineDistance");let o=null;null!=r&&(o=$i(r,"weights","cosineDistance")),ve(a.shape,i.shape,"Error in cosineDistance: ");const u=Vu(1),l=nl(u,Kd(Cu(a,i),n,!0));return Bx(l,o,s)}const Gx=Ri({cosineDistance_:Ux});function Hx(e,t,n,r=zx.SUM_BY_NONZERO_WEIGHTS){let s=$i(e,"labels","hingeLoss");const a=$i(t,"predictions","hingeLoss");let i=null;null!=n&&(i=$i(n,"weights","hingeLoss")),ve(s.shape,a.shape,"Error in hingeLoss: ");const o=Vu(1);s=nl(Cu(Vu(2),s),o);const u=Sg(nl(o,Cu(s,a)));return Bx(u,i,r)}const jx=Ri({hingeLoss_:Hx});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function qx(e,t,n,r=1,s=zx.SUM_BY_NONZERO_WEIGHTS){const a=$i(e,"labels","huberLoss"),i=$i(t,"predictions","huberLoss");let o=null;null!=n&&(o=$i(n,"weights","huberLoss")),ve(a.shape,i.shape,"Error in huberLoss: ");const u=Vu(r),l=al(nl(i,a)),c=gm(l,u),h=nl(l,c),p=ku(Cu(Vu(.5),Fu(c)),Cu(u,h));return Bx(p,o,s)}const Kx=Ri({huberLoss_:qx});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Xx(e,t,n,r=1e-7,s=zx.SUM_BY_NONZERO_WEIGHTS){const a=$i(e,"labels","logLoss"),i=$i(t,"predictions","logLoss");let o=null;null!=n&&(o=$i(n,"weights","logLoss")),ve(a.shape,i.shape,"Error in logLoss: ");const u=Vu(1),l=Vu(r),c=Zl(Cu(a,Of(ku(i,l)))),h=Cu(nl(u,a),Of(ku(nl(u,i),l))),p=nl(c,h);return Bx(p,o,s)}const Yx=Ri({logLoss_:Xx});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Jx(e,t,n,r=zx.SUM_BY_NONZERO_WEIGHTS){const s=$i(e,"labels","meanSquaredError"),a=$i(t,"predictions","meanSquaredError");let i=null;null!=n&&(i=$i(n,"weights","meanSquaredError")),ve(s.shape,a.shape,"Error in meanSquaredError: ");const o=vy(s,a);return Bx(o,i,r)}const Zx=Ri({meanSquaredError_:Jx});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Qx(e,t){const n=$i(e,"labels","sigmoidCrossEntropyWithLogits"),r=$i(t,"logits","sigmoidCrossEntropyWithLogits");ve(n.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");const s=Sg(r),a=Cu(r,n),i=Lf(tf(Zl(al(r))));return ku(nl(s,a),i)}function ew(e,t,n,r=0,s=zx.SUM_BY_NONZERO_WEIGHTS){let a=$i(e,"multiClassLabels","sigmoidCrossEntropy");const i=$i(t,"logits","sigmoidCrossEntropy");let o=null;if(null!=n&&(o=$i(n,"weights","sigmoidCrossEntropy")),ve(a.shape,i.shape,"Error in sigmoidCrossEntropy: "),r>0){const e=Vu(r),t=Vu(1),n=Vu(.5);a=ku(Cu(a,nl(t,e)),Cu(n,e))}const u=Qx(a,i);return Bx(u,o,s)}const tw=Ri({sigmoidCrossEntropy_:ew});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function nw(e,t,n=-1){if(-1===n&&(n=t.rank-1),n!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${n}`);const r=Bu(((e,t,r)=>{const s=!0,a=Hf(t,[n],s),i=nl(Xo(t,"float32"),a);r([e,i]);const o=Zl(Cu(i,e)),u=Kd(o,[n]),l=(e,t)=>{const[r,s]=t,a=zd(e.shape,[n]);return[Cu(Xh(e,a),nl(Xo(r,"float32"),tf(s))),Cu(Xh(e,a),nl(tf(s),Xo(r,"float32")))]};return{value:u,gradFunc:l}}));return r(e,t)}function rw(e,t,n,r=0,s=zx.SUM_BY_NONZERO_WEIGHTS){let a=$i(e,"onehotLabels","softmaxCrossEntropy");const i=$i(t,"logits","softmaxCrossEntropy");let o=null;if(null!=n&&(o=$i(n,"weights","softmaxCrossEntropy")),ve(a.shape,i.shape,"Error in softmaxCrossEntropy: "),r>0){const e=Vu(r),t=Vu(1),n=Vu(a.shape[1]);a=ku(Cu(a,nl(t,e)),Tu(e,n))}const u=nw(a,i);return Bx(u,o,s)}const sw=Ri({softmaxCrossEntropy_:rw});
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function aw(e,t,n,r){const s=$i(e,"indices","sparseFillEmptyRows","int32"),a=$i(t,"values","sparseFillEmptyRows"),i=$i(n,"denseShape","sparseFillEmptyRows","int32"),o=$i(r,"defaultValue","sparseFillEmptyRows",a.dtype);if(2!==s.rank)throw new Error(`Indices should be Tensor2D but received shape\n        ${s.shape}`);if(1!==a.rank)throw new Error(`Values should be Tensor1D but received shape ${a.shape}`);if(1!==i.rank)throw new Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);if(0!==o.rank)throw new Error(`Default value should be a scalar but received shape ${o.shape}`);const u={indices:s,values:a,denseShape:i,defaultValue:o},l=gi.runKernel(os,u);return{outputIndices:l[0],outputValues:l[1],emptyRowIndicator:l[2],reverseIndexMap:l[3]}}const iw=Ri({sparseFillEmptyRows_:aw});
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ow(e,t,n){const r=$i(e,"inputIndices","sparseReshape","int32"),s=$i(t,"inputShape","sparseReshape","int32"),a=$i(n,"newShape","sparseReshape","int32");if(2!==r.rank)throw new Error(`Input indices should be Tensor2D but received shape\n        ${r.shape}`);if(1!==s.rank)throw new Error(`Input shape should be Tensor1D but received shape ${s.shape}`);if(1!==a.rank)throw new Error(`New shape should be Tensor1D but received shape ${a.shape}`);const i={inputIndices:r,inputShape:s,newShape:a},o=gi.runKernel(us,i);return{outputIndices:o[0],outputShape:o[1]}}const uw=Ri({sparseReshape_:ow});
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function lw(e,t,n){const r=$i(e,"data","sparseSegmentMean"),s=$i(t,"indices","sparseSegmentMean","int32"),a=$i(n,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.rank)throw new Error(`Indices should be Tensor1D but received shape\n          ${s.shape}`);if(1!==a.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n          ${a.shape}`);const i={data:r,indices:s,segmentIds:a};return gi.runKernel(ls,i)}const cw=Ri({sparseSegmentMean_:lw});
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function hw(e,t,n){const r=$i(e,"data","sparseSegmentSum"),s=$i(t,"indices","sparseSegmentSum","int32"),a=$i(n,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.rank)throw new Error(`Indices should be Tensor1D but received shape\n         ${s.shape}`);if(1!==a.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n         ${a.shape}`);const i={data:r,indices:s,segmentIds:a};return gi.runKernel(cs,i)}const pw=Ri({sparseSegmentSum_:hw});
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function dw(e,t,n,r,s,a,i,o){const u=$i(e,"data","stringNGrams","string");if("string"!==u.dtype)throw new Error("Data must be of datatype string");if(1!==u.shape.length)throw new Error(`Data must be a vector, saw: ${u.shape}`);const l=$i(t,"dataSplits","stringNGrams");if("int32"!==l.dtype)throw new Error("Data splits must be of datatype int32");const c={separator:n,nGramWidths:r,leftPad:s,rightPad:a,padWidth:i,preserveShortSequences:o},h={data:u,dataSplits:l},p=gi.runKernel(gs,h,c);return{nGrams:p[0],nGramsSplits:p[1]}}const fw=Ri({stringNGrams_:dw});
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function mw(e,t,n=!0){const r=$i(e,"input","stringSplit","string"),s=$i(t,"delimiter","stringSplit","string");if(1!==r.rank)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(0!==s.rank)throw new Error(`Delimiter should be a scalar but received shape ${s.shape}`);const a={skipEmpty:n},i={input:r,delimiter:s},o=gi.runKernel(ys,i,a);return{indices:o[0],values:o[1],shape:o[2]}}const gw=Ri({stringSplit_:mw});
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function yw(e,t){const n=$i(e,"input","stringToHashBucketFast","string"),r={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");const s={input:n};return gi.runKernel(bs,s,r)}const bw=Ri({stringToHashBucketFast_:yw});
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function xw(e,t,n,r=!0){const s=$i(e,"input","staticRegexReplace","string"),a={pattern:t,rewrite:n,replaceGlobal:r};return gi.runKernel(fs,{x:s},a)}const ww=Ri({staticRegexReplace_:xw}),vw={fft:hy,ifft:dy,rfft:xy,irfft:my},kw={hammingWindow:Ob,hannWindow:Lb,frame:Pb,stft:Wb},Iw={flipLeftRight:Hb,grayscaleToRGB:qb,resizeNearestNeighbor:Sx,resizeBilinear:Ix,rgbToGrayscale:Xb,rotateWithOffset:Jb,cropAndResize:Ub,nonMaxSuppression:ex,nonMaxSuppressionAsync:dx,nonMaxSuppressionWithScore:mx,nonMaxSuppressionWithScoreAsync:yx,nonMaxSuppressionPadded:xx,nonMaxSuppressionPaddedAsync:vx,threshold:Cx,transform:Rx},Nw={bandPart:Fx,gramSchmidt:Dx,qr:Lx},Sw={absoluteDifference:Vx,computeWeightedLoss:Bx,cosineDistance:Gx,hingeLoss:jx,huberLoss:Kx,logLoss:Yx,meanSquaredError:Zx,sigmoidCrossEntropy:tw,softmaxCrossEntropy:sw},Tw={sparseFillEmptyRows:iw,sparseReshape:uw,sparseSegmentMean:cw,sparseSegmentSum:pw},$w={stringNGrams:fw,stringSplit:gw,stringToHashBucketFast:bw,staticRegexReplace:ww},Cw=sh;n(59848);
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Ew=(()=>"undefined"!==typeof requestAnimationFrame?requestAnimationFrame:"undefined"!==typeof setImmediate?setImmediate:e=>e())();function Rw(){return new Promise((e=>Ew((()=>e()))))}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Aw(e,t){const n=e[0].length;e.forEach(((e,t)=>{we(e.length===n,(()=>`Error in concat${n}D: rank of tensors[${t}] must be the same as the rank of the rest (${n})`))})),we(t>=0&&t<n,(()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`));const r=e[0];e.forEach(((e,s)=>{for(let a=0;a<n;a++)we(a===t||e[a]===r[a],(()=>`Error in concat${n}D: Shape of tensors[${s}] (${e}) does not match the shape of the rest (${r}) along the non-concatenated axis ${s}.`))}))}function Fw(e,t){const n=e[0].slice();for(let r=1;r<e.length;r++)n[t]+=e[r][t];return n}
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var _w;function Dw(e,t,n){let r=new Array;if(null==n&&null==t)return r;if(null==t)while(r.length<e+n.length)r.push(-1);else r=t.slice();if(null==n)return r;if(e+n.length!==r.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${e+n.length}, but shape.rank = ${r.length}`);for(let s=1;s<n.length;++s){const a=n[s],i=r[r.length-n.length+s],o=r[i];if(a>=0)if(o>=0){if(o!==a)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${s+e}] = ${a} but shape[${s+e}] = ${o}`)}else r[i]=a}return r}function Ow(e){const t={FIRST_DIM_SIZE:_w.FIRST_DIM_SIZE,VALUE_ROWIDS:_w.VALUE_ROWIDS,ROW_LENGTHS:_w.ROW_LENGTHS,ROW_SPLITS:_w.ROW_SPLITS,ROW_LIMITS:_w.ROW_LIMITS,ROW_STARTS:_w.ROW_STARTS},n=[];for(const r of e){if(!(r in t))break;n.push(t[r])}return n}function Mw(e){return 0===e.length?0:e[0]===_w.FIRST_DIM_SIZE?e.length-1:e.length}function Lw(e,t){if(null==e||null==t)return;const n=e.length,r=t.length;if(n>=r)throw new Error(`defaultValue.shape=${e} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${r})`);for(let s=0;s<Math.min(n,r-1);++s){const n=e[s],r=t[s+1];if(n>=0&&r>=0&&1!==n&&n!==r)throw new Error(`defaultValue.shape=${e}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${s-e.length}] = ${n} but ragged tensor input.flatValues.shape[${s-e.length}] = ${r}`)}}(function(e){e[e["FIRST_DIM_SIZE"]=0]="FIRST_DIM_SIZE",e[e["VALUE_ROWIDS"]=1]="VALUE_ROWIDS",e[e["ROW_LENGTHS"]=2]="ROW_LENGTHS",e[e["ROW_SPLITS"]=3]="ROW_SPLITS",e[e["ROW_LIMITS"]=4]="ROW_LIMITS",e[e["ROW_STARTS"]=5]="ROW_STARTS"})(_w||(_w={}));
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const zw=30;function Pw(e){return e<=zw?e:Ke(e,Math.floor(Math.sqrt(e)))}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Bw(e,t,n){const r=n*("number"===typeof e?e:e[0]),s=t*("number"===typeof e?e:e[1]);return[r,s]}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Ww(e,t,n,r=!0){let s=[];if(r)s=s.concat(t.slice(0)),s.push(e[0]/n),s=s.concat(e.slice(1));else{s=s.concat(e[0]);const n=t.length;for(let r=0;r<n;++r)s=s.concat([e[r+1]/t[r],t[r]]);s=s.concat(e.slice(n+1))}return s}function Vw(e,t,n=!0){const r=[];if(n){r.push(t);for(let n=t+1;n<e;++n)n<=2*t?(r.push(n),r.push(n-(t+1))):r.push(n)}else{const n=[],s=[];for(let r=1;r<e;++r)r>=2*t+1||r%2===1?s.push(r):n.push(r);r.push(...n),r.push(0),r.push(...s)}return r}function Uw(e,t,n,r=!0){const s=[];r?s.push(e[0]/n):s.push(e[0]*n);for(let a=1;a<e.length;++a)a<=t.length?r?s.push(t[a-1]*e[a]):s.push(e[a]/t[a-1]):s.push(e[a]);return s}function Gw(e,t){const n=[0];for(let r=0;r<t;++r)n.push(e[r][0]);return n}function Hw(e,t,n){const r=e.slice(0,1);for(let s=0;s<n;++s)r.push(e[s+1]-t[s][0]-t[s][1]);return r}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const jw=1.7580993408473768,qw=1.0507009873554805,Kw=.3275911,Xw=.254829592,Yw=-.284496736,Jw=1.421413741,Zw=-1.453152027,Qw=1.061405429;
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ev(e,t){if(e.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);const n=new Float32Array(2*e.length);for(let r=0;r<n.length;r+=2)n[r]=e[r/2],n[r+1]=t[r/2];return n}function tv(e){const t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let r=0;r<e.length;r+=2)t[r/2]=e[r],n[r/2]=e[r+1];return{real:t,imag:n}}function nv(e){const t=Math.ceil(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let s=0;s<e.length;s+=4)n[Math.floor(s/4)]=e[s],r[Math.floor(s/4)]=e[s+1];return{real:n,imag:r}}function rv(e){const t=Math.floor(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let s=2;s<e.length;s+=4)n[Math.floor(s/4)]=e[s],r[Math.floor(s/4)]=e[s+1];return{real:n,imag:r}}function sv(e,t){const n=e[2*t],r=e[2*t+1];return{real:n,imag:r}}function av(e,t,n,r){e[2*r]=t,e[2*r+1]=n}function iv(e,t){const n=new Float32Array(e/2),r=new Float32Array(e/2);for(let s=0;s<Math.ceil(e/2);s++){const a=(t?2:-2)*Math.PI*(s/e);n[s]=Math.cos(a),r[s]=Math.sin(a)}return{real:n,imag:r}}function ov(e,t,n){const r=(n?2:-2)*Math.PI*(e/t),s=Math.cos(r),a=Math.sin(r);return{real:s,imag:a}}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const uv="->",lv=/->/g,cv=",",hv="...";function pv(e,t){e=e.replace(/\s/g,"");const n=(e.length-e.replace(lv,"").length)/uv.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${uv}").`);const[r,s]=e.split(uv);we(-1===r.indexOf(hv),(()=>`The ellipsis notation ("${hv}") is not supported yet.`));const a=r.split(cv),i=a.length;if(t!==i)throw new Error(`Expected ${i} input tensors, received ${t}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const o=[];for(let p=0;p<s.length;++p){const e=s[p];if(!a.some((t=>-1!==t.indexOf(e))))throw new Error(`Output subscripts contain the label ${e} not present in the input subscripts.`);-1===o.indexOf(e)&&o.push(e)}for(let p=0;p<r.length;++p){const e=r[p];-1===o.indexOf(e)&&e!==cv&&o.push(e)}const u=new Array(a.length);for(let p=0;p<i;++p){if(new Set(a[p].split("")).size!==a[p].length)throw new Error(`Found duplicate axes in input component ${a[p]}. Support for duplicate axes in input is not implemented yet.`);u[p]=[];for(let e=0;e<a[p].length;++e)u[p].push(o.indexOf(a[p][e]))}const l=o.length,c=s.length,h=[];for(let p=c;p<l;++p)h.push(p);return{allDims:o,summedDims:h,idDims:u}}function dv(e,t){let n=new Array(e);n.fill(-1);for(let s=0;s<t.length;++s)n[t[s]]=s;const r=[];for(let s=0;s<e;++s)-1===n[s]&&r.push(s);return n=n.filter((e=>-1!==e)),{permutationIndices:n,expandDims:r}}function fv(e,t,n){const r=new Array(e);for(let s=0;s<n.length;++s){const e=n[s].shape;for(let n=0;n<t[s].length;++n)void 0===r[t[s][n]]?r[t[s][n]]=e[n]:we(r[t[s][n]]===e[n],(()=>`Expected dimension ${r[t[s][n]]} at axis ${n} of input shaped ${JSON.stringify(e)}, but got dimension ${e[n]}`))}}function mv(e,t){const n=e,r=[];let s=0;0===e.length&&n.push(-1),s=e.length+1;for(let i=0;i<s;++i)r.push([]);const a=[];for(let i=0;i<n.length;++i){const e=n[i],s=yv(t,e);for(const t of s)-1===a.indexOf(t)&&(r[i].push(t),a.push(t))}return{path:n,steps:r}}function gv(e){return e.every(((e,t)=>e===t))}function yv(e,t){const n=[];for(let r=0;r<e.length;++r)0!==e[r].length&&-1===e[r].indexOf(t)&&-1!==t||n.push(r);return n}function bv(e,t,n=0){let r=[];if("number"===typeof t)we(e.shape[n]%t===0,(()=>"Number of splits must evenly divide the axis.")),r=new Array(t).fill(e.shape[n]/t);else{const s=t.reduce(((e,t)=>(-1===t&&(e+=1),e)),0);we(s<=1,(()=>"There should be only one negative value in split array."));const a=t.indexOf(-1);if(-1!==a){const r=t.reduce(((e,t)=>t>0?e+t:e));t[a]=e.shape[n]-r}we(e.shape[n]===t.reduce(((e,t)=>e+t)),(()=>"The sum of sizes must match the size of the axis dimension.")),r=t}return r}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function xv(e){return`Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ${e}`}function wv(e,t){return`indices(${e}, 0) is invalid: ${t} < 0`}function vv(e,t,n){return`indices(${e}, 0) is invalid: ${t} >= ${n}`}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function kv(e,t){return`only one output dimension may be -1, not both ${e} and ${t}`}function Iv(e,t){return`size ${e} must be non-negative, not ${t}`}function Nv(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function Sv(e,t){const n=Ie(e),r=Ie(t);return`Input to reshape is a SparseTensor with ${n}\n  dense values, but the requested shape requires a multiple of ${r}. inputShape=${e} outputShape= ${t}`}function Tv(e,t){const n=Ie(e),r=Ie(t);return`Input to reshape is a tensor with ${n} dense values, but the requested shape has ${r}. inputShape=${e} outputShape=${t}`}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function $v(){return"segment ids must be >= 0"}function Cv(){return"segment ids are not increasing"}function Ev(e,t){return`Segment id ${e} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function Rv(e,t,n){return`Bad: indices[${e}] == ${t} out of range [0, ${n})`}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Av(e,t){let n,r=!1;e<=zw?(n=e,r=!0):n=Ke(e,Math.floor(Math.sqrt(e)));while(!r)n>t||n===e?r=!0:n=Ke(e,n+1);return n}function Fv(e,t,n){const r=[],s=e.length;for(let a=0;a<s;a++)a!==t?r.push(e[a]):r.push(n);return r}function _v(e,t,n,r){const s=t.shape.length,a=e.shape.length;if(0!==r&&(r<-s||r>s))throw new Error(`Expect batchDims in the range of [-${s}, ${s}], but got ${r}`);if(r<0&&(r+=s),r>a)throw new Error(`batchDims (${r}) must be less than rank(x) (\n    ${a}).`);if(n<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let h=0;h<r;++h)if(e.shape[h]!==t.shape[h])throw new Error(`x.shape[${h}]: ${e.shape[h]} should be equal to indices.shape[${h}]: ${t.shape[h]}.`);const i=e.shape[n],o=[];let u=1,l=1,c=1;for(let h=0;h<r;++h)o.push(e.shape[h]),u*=e.shape[h];for(let h=r;h<n;h++)o.push(e.shape[h]),l*=e.shape[h];for(let h=r;h<s;h++)o.push(t.shape[h]);for(let h=n+1;h<a;h++)o.push(e.shape[h]),c*=e.shape[h];return{batchSize:u,sliceSize:c,outerSize:l,dimSize:i,outputShape:o}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Dv(e){try{return e.map((e=>ka(e)))}catch(l7){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${l7}`)}}function Ov(e){return e.map((e=>va(e)))}var Mv;
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
gl(),function(e){e["UNDEFINED"]="undefined",e["INVALID_MODEL_TYPE"]="invalidModelType",e["MISSING_PATH"]="missingPath"}(Mv||(Mv={}));const Lv=e=>!(!Boolean(e)||!Array.isArray(e)||4!==e.length)&&e.every((e=>null===e||"number"===typeof e)),zv=e=>Lv(e)&&null!==e[1]&&null!==e[2]&&e[1]>0&&e[2]>0;function Pv(e){function t(t){try{return t.shape.length===e}catch(l7){}return!1}return t}const Bv=Pv(4),Wv=Pv(3),Vv=e=>e instanceof ja,Uv=e=>"string"===typeof e,Gv=e=>"string"===typeof e&&["layers","graph"].includes(e);class Hv extends Error{constructor(e){super(e),(0,Z.A)(this,"type",void 0),this.type=e}}const jv=e=>{var t,n;if(void 0===e)throw new Hv(Mv.UNDEFINED);if(!Gv(null!==(t=e.modelType)&&void 0!==t?t:"layers"))throw new Hv(Mv.INVALID_MODEL_TYPE);if(!e.path&&(null===(n=e._internals)||void 0===n||!n.path))throw new Hv(Mv.MISSING_PATH);return!0},qv=e=>"number"===typeof e,Kv=e=>Array.isArray(e)&&2===e.length&&e.every(qv),Xv=e=>{console.warn(Array.isArray(e)?e.join("\n"):e)};function Yv(e){return void 0!==e&&"function"===typeof e}function Jv(e){return Yv(e)&&e.length<=1}const Zv=(e,t,n)=>!(!Yv(e)||e.length<=1)&&(void 0===n&&"tensor"===t||"tensor"===n),Qv=e=>!!e&&e.aborted;async function ek(e,t){let n;for(n=await e.next();!n.done;n=await e.next())t&&await t(n.value);return n.value}function tk(e){return null!==e&&void 0!==e}function nk(e,t,...n){const r=n.filter(tk);if(r.length){const n=e.tidy((()=>r.reduce(((e,t)=>t(e)),t)));return t.isDisposed||t===n||t.dispose(),n}return t}const rk=e=>e instanceof Hv,sk="https://upscalerjs.com/documentation/troubleshooting#deprecated-model-definition-function",ak=["Passing a model definition as a function is deprecated and will be removed in a future version.","To leverage model lifecycle methods, use the setup and teardown methods.",`For more information, see ${sk}.`].join(" "),ik="https://upscalerjs.com/documentation/troubleshooting#padding-is-undefined",ok=['"padding" is undefined, but "patchSize" is explicitly defined.',"Without padding, patches of images often have visible artifacting at the seams. Defining an explicit padding will resolve the artifacting.",`For more information, see ${ik}.`,'To hide this warning, pass an explicit padding of "0".'].join(" "),uk="https://upscalerjs.com/documentation/troubleshooting#progress-specified-without-patch-size",lk=['The "progress" callback was provided but "patchSize" was not defined.','Without a "patchSize", the "progress" callback will never be called.',`For more information, see ${uk}.`].join(" "),ck="https://upscalerjs.com/documentation/troubleshooting#invalid-predicted-tensor",hk=e=>[`The tensor returned by the model was not a valid rank-4 tensor. It's shape is ${JSON.stringify(e)}.}`,"UpscalerJS only supports models returning valid image-like data in four dimensional form.",`For more information, see ${ck}.`].join(" "),pk="https://upscalerjs.com/documentation/troubleshooting#invalid-model-prediction",dk=["The model output was not a valid tensor. UpscalerJS only supports models returning valid tensors.","This is likely an error with the model itself, not UpscalerJS.",`For more information, see ${pk}.`].join(" "),fk=new Error("No defined tensors were passed to concatTensors");class mk extends Error{constructor(...e){super(...e),(0,Z.A)(this,"message","The upscale request received an abort signal")}}const gk="https://upscalerjs.com/documentation/troubleshooting#invalid-model-type",yk="https://upscalerjs.com/documentation/troubleshooting#input-size-and-patch-size",bk="https://upscalerjs.com/documentation/troubleshooting#error-with-model-input-shape",xk=e=>[`You've provided an invalid model type: ${JSON.stringify(e)}. Accepted types are "layers" and "graph".`,`For more information, see ${gk}.`].join(" "),wk="There is a bug with the upscaler code. Please report this.",vk=["You have provided a patchSize, but the model definition already includes an input size.","Your patchSize will be ignored.",`For more information, see ${yk}.`].join(" "),kk=e=>[`Expected model to have a rank-4 compatible input shape. Instead got: ${JSON.stringify(e)}.`,`For more information, see ${bk}.`].join(" "),Ik=e=>new Error([`Invalid patch size: ${e}. Patch size must be greater than 0.`].join(" ")),Nk=(e,t)=>new Error([`Invalid patch size and padding: ${e} and ${t}. Patch size must be greater than padding * 2.`].join(" ")),Sk="https://upscalerjs.com/documentation/troubleshooting#patch-size-indivisible-by-divisibility-factor",Tk=(e,t,n)=>[`Invalid patch size: ${e}. The model has a defined divibility factor of ${t} and patch size must be a multiple of this number.`,`Patch size has been scaled up to ${n}.`,`\nFor more information, see ${Sk}.`].join(" "),$k=new Error(["Model input sizes must be square. If you are using a model with a non-square input size and would like to request support,","please file a feature request at https://github.com/thekevinscott/upscalerjs"].join(" ")),Ck="https://upscalerjs.com/documentation/troubleshooting#missing-path-and-internals",Ek=e=>['Provided model configuration is missing both a "path" and "_internals". A valid path to a model JSON file must be provided.',`For more information, see ${Ck}.`,`The model configuration provided was: ${JSON.stringify(e)}`].join(" ");function Rk(e,t){switch(e){case Mv.INVALID_MODEL_TYPE:return new Error(xk(null===t||void 0===t?void 0:t.modelType));case Mv.MISSING_PATH:return new Error(Ek(t));default:return new Error(wk)}}const Ak=(e,t,n)=>async r=>{if(n&&await e.nextFrame(),Qv(t))throw Array.isArray(r)?r.forEach((e=>null===e||void 0===e?void 0:e.dispose())):Vv(r)&&r.dispose(),new mk},Fk=e=>!(!e||"object"!==typeof e)&&("patchSize"in e&&"number"===typeof e.patchSize),_k=e=>Boolean(e)&&"number"===typeof e&&e>0,Dk="https://upscalerjs.com/documentation/troubleshooting#invalid-warmup-value",Ok=e=>["Invalid value passed to warmup in warmupSizes:",JSON.stringify(e),`For more information, see ${Dk}.`].join("\n"),Mk=e=>new Error(Ok(e)),Lk=e=>{if(Fk(e)){const{patchSize:t}=e;return t}return e};async function*zk(e,t,n){const{model:r,modelDefinition:s}=await t;for(const a of n){if(!Fk(a)&&!_k(a))throw Mk(a);const t=Lk(a);let n=e.zeros([1,t,t,3]);yield[n];const i=[s.preprocess,e=>r.predict(e),s.postprocess].filter(Boolean);for(const r of i)n=nk(e,n,r),yield[n];n.dispose(),yield}}const Pk=e=>{if(Array.isArray(e)){for(const t of e)if(!Fk(t)&&!_k(t))throw Mk(e);return e}if(Fk(e)||_k(e))return[e];throw Mk(e)},Bk=async(e,t,n,{signal:r,awaitNextFrame:s=!1}={},a)=>{const i=Ak(e,r||a.signal,s);await i(),await ek(zk(e,t,Pk(n)),i)},Wk=(e,t)=>t instanceof e.LayersModel,Vk=e=>({...e});function Uk(e){return"function"===typeof e}function Gk(e,t){return Uk(t)?(Xv(ak),t(e)):t}async function Hk(e,t){const n=Gk(e,t);return n.setup&&await n.setup(e),n}function jk(e,t,n){return"graph"===n?e.loadGraphModel(t):e.loadLayersModel(t)}const qk=(e,t)=>Wk(e,t)?t.layers[0].batchInputShape:t.inputs[0].shape,Kk=(e,{model:t})=>{const n=qk(e,t);if(!Lv(n))throw new Error(kk(n));return n},Xk=(e,t)=>Math.ceil(t/e)*e,Yk=(e,t,{patchSize:n,padding:r},s)=>{const a=Kk(e,t);if(void 0!==n){if(n<=0)throw Ik(n);if(void 0!==r&&2*r>=n)throw Nk(n,r)}if(zv(a)){if(void 0!==n&&Xv(vk),a[1]!==a[2])throw $k;return{patchSize:a[1],padding:r,modelInputShape:a}}void 0!==n&&void 0===r&&Xv(ok);const{divisibilityFactor:i}=t.modelDefinition;if(void 0!==i){if(void 0!==n){const e=Xk(i,n);return e!==n&&Xv(Tk(n,i,e)),{patchSize:e,padding:r,modelInputShape:[null,e,e,3]}}return{patchSize:void 0,padding:void 0,modelInputShape:[null,Xk(i,s[1]),Xk(i,s[2]),3]}}return{patchSize:n,padding:r,modelInputShape:void 0}},Jk=(e,t)=>n=>{const r=n.shape[1],s=n.shape[2];return zv(t)&&(t[1]>r||t[2]>s)?e.tidy((()=>{const a=Math.max(r,t[1]),i=Math.max(s,t[2]),o=e.zeros([1,r,i-s,3]),u=e.zeros([1,a-r,i,3]),l=e.concat([n,o],2),c=e.concat([l,u],1);return c})):n},Zk=(e,t,n)=>r=>{const s=t[1]*n,a=t[2]*n;return s<r.shape[1]||a<r.shape[2]?e.tidy((()=>e.slice(r,[0,0,0],[1,s,a,3]))):r},Qk=e=>t=>{const n=Kv(e)?e[1]:255;return t.clipByValue(0,n).mul(1===n?255:1)},eI=(e,t)=>n=>Kv(t)&&1===t[1]?e.mul(n,1/255):n,tI=(e,t)=>e.tidy((()=>{const[n,r]=t.shape,s=e.fill([n,r],255).expandDims(2);return t.clipByValue(0,255).concat([s],2).dataSync()}));function nI(e){return Vv(e)?e.clone():e}function rI(e,t,n=0){const r=t.filter(tk);if(0===r.length)throw fk;const s=e.concat(r,n);return t.forEach((e=>null===e||void 0===e?void 0:e.dispose())),s}const sI=(e,t,n,r)=>{let s=t;const a=0===t||n===e?0:r,i=s+n>e;let o=i?n-(e-s):0;const u=i||n===e?0:r,l=i?0:a;let c=n-(i?o:0);i&&(s=e-n),s-=l,o+=l,c-=l+u;const h=n>e?e:n-a-u;return{pre:{origin:s,size:n},post:{origin:o,size:c},increment:h}},aI=([e,t],n,r)=>{const s=[];let a=0,i=0;while(i<t){const{pre:{origin:o,size:u},post:{origin:l,size:c},increment:h}=sI(t,i,Math.min(n,t),r),p=[];while(a<e){const{pre:{origin:t,size:s},post:{origin:i,size:h},increment:d}=sI(e,a,Math.min(n,e),r);p.push({pre:{origin:[o,t],size:[u,s]},post:{origin:[l,i],size:[c,h]}}),a+=d}s.push(p),a=0,i+=h}return s},iI=(e,t,n,r)=>{const s=e*n+t+1,a=s/r;return a},oI=(e,t)=>{const n=e.predict(t);if(!Vv(n))throw new Error(dk);if(Bv(n))return n;throw new Error(hk(n.shape))};async function*uI(e,t,{output:n,progress:r,progressOutput:s},a,{originalImageSize:i,patchSize:o,padding:u=0},{tensorAsBase64:l}){var c;const{model:h,modelDefinition:p}=a,d=null!==(c=p.scale)&&void 0!==c?c:1;if(o){var f;const[a,c]=t.shape.slice(1),m=aI([c,a],o,u);let g;yield;const y=m.length*m[0].length;for(let i=0;i<m.length;i++){const a=m[i],o=a.length;let u;yield[u,g];for(let c=0;c<o;c++){const{pre:f,post:m}=a[c];yield[g,u];const b=t.slice([0,...f.origin],[-1,...f.size]);yield[g,u,b];const x=oI(h,b);b.dispose(),yield[g,u,x];const w=[0,m.origin[0]*d,m.origin[1]*d],v=[-1,m.size[0]*d,m.size[1]*d],k=x.slice(w,v);x.dispose(),yield[g,u,k];const I=nk(e,k,p.postprocess,Qk(p.outputRange));if(yield[g,u,I],void 0!==r&&Yv(r)){const t=iI(i,c,o,y);if(Jv(r))r(t);else{const a=I.squeeze(),o={row:i,col:c,patchCoordinates:{pre:f,post:m}};if(Zv(r,n,s))r(t,a,o);else{const n=l(e,a);a.dispose(),r(t,n,o)}}}yield[g,u,I],u=rI(e,[u,I],2),I.dispose(),yield[g,u]}g=rI(e,[g,u],1),u.dispose(),yield[g]}const b=nk(e,g.clone(),Zk(e,i,d));null===(f=g)||void 0===f||f.dispose(),yield[b];const x=b.squeeze();return b.dispose(),x}r&&Xv(lk);const m=oI(h,t);yield[m];const g=nk(e,m.clone(),p.postprocess,Qk(p.outputRange),Zk(e,i,d));m.dispose(),yield[g];const y=g.squeeze();return g.dispose(),y}async function*lI(e,t,n,r,{getImageAsTensor:s,tensorAsBase64:a}){const i=nI(t),o=await s(e,i);yield o;const u=o.shape,{patchSize:l,padding:c,modelInputShape:h}=Yk(e,r,n,u),p=nk(e,o,r.modelDefinition.preprocess,eI(e,r.modelDefinition.inputRange),h?Jk(e,h):void 0);yield p;const d=uI(e,p,{output:n.output,progressOutput:n.progressOutput,progress:n.progress},r,{originalImageSize:u,patchSize:l,padding:c},{tensorAsBase64:a});let f=await d.next();yield f.value;while(!f.done)f=await d.next(),Array.isArray(f.value)?yield[...f.value,p]:Vv(f.value)?yield[f.value,p]:yield p;p.dispose();const m=f.value;if("tensor"===n.output)return m;const g=a(e,m);return m.dispose(),g}async function cI(e,t,{signal:n,awaitNextFrame:r,...s},a,{checkValidEnvironment:i,...o}){i(t,{output:s.output,progressOutput:s.progressOutput});const u=Ak(e,n||a.signal,r);await u();const l=await ek(lI(e,t,s,a,o),u);return await u(),l}const hI=ie;function pI({tf:e,getUpscaleOptions:t,checkValidEnvironment:n,getImageAsTensor:r,tensorAsBase64:s,loadModel:a}){class i{constructor(t={}){(0,Z.A)(this,"_opts",void 0),(0,Z.A)(this,"_model",void 0),(0,Z.A)(this,"ready",void 0),(0,Z.A)(this,"_abortController",new AbortController),(0,Z.A)(this,"upscale",this.execute.bind(this)),(0,Z.A)(this,"warmup",(async(t=[],n)=>(await this.ready,Bk(e,this._model,t,n,{signal:this._abortController.signal})))),(0,Z.A)(this,"abort",(()=>{this._abortController.abort(),this._abortController=new AbortController})),(0,Z.A)(this,"dispose",(async()=>{await this.ready;const{model:t,modelDefinition:n}=await this._model;n.teardown&&await n.teardown(e),t.dispose()})),(0,Z.A)(this,"getModel",(()=>this._model)),this._opts={...t},this._model=a(e,Hk(e,this._opts.model||hI)),this.ready=new Promise(((t,n)=>{this._model.then((()=>Bk(e,this._model,this._opts.warmupSizes||[],void 0,{signal:this._abortController.signal}))).then(t).catch(n)}))}async execute(a,i){const o={checkValidEnvironment:n,getImageAsTensor:r,tensorAsBase64:s};await this.ready;const u=await this._model;return cI(e,a,t(i),{...u,signal:this._abortController.signal},o)}}return i}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const dI={kernelName:bt,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Cu(e,$y(Xo(n,"float32"),-1))}}},fI={kernelName:xt,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=Fu(Xo(n,"float32")),r=Ru(nl(Vu(1),t));return Zl(Tu(e,r))}}}},mI={kernelName:wt,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=Ru(nl(Fu(Xo(n,"float32")),1));return Tu(e,t)}}}},gI={kernelName:vt,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=ul(n.shape,r.shape),a=()=>{let t=e;const r=ol(n.shape,s);return r.length>0&&(t=Kd(t,r)),Xh(t,n.shape)},i=()=>{let t=e;const n=ol(r.shape,s);return n.length>0&&(t=Kd(t,n)),Xh(t,r.shape)};return{a:a,b:i}}},yI={kernelName:kt,saveAllInputs:!0,gradFunc:(e,t)=>{const n={};return t.forEach(((t,r)=>{n[r]=()=>e.clone()})),n}},bI={kernelName:St,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Du(n)}}},xI={kernelName:Tt,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Du(n)}}},wI={kernelName:$t,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Tu(e,Ru(nl(Vu(1),Fu(Xo(n,"float32")))))}}},vI={kernelName:Ct,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=Ru(ku(Vu(1),Fu(Xo(n,"float32"))));return Tu(e,t)}}}},kI={kernelName:At,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=ul(n.shape,r.shape),a=()=>{const t=ku(Fu(n),Fu(r));let a=Cu(e,Tu(r,t));const i=ol(n.shape,s);return i.length>0&&(a=Kd(a,i)),Xh(a,n.shape)},i=()=>{const t=ku(Fu(n),Fu(r));let a=Zl(Cu(e,Tu(n,t)));const i=ol(r.shape,s);return i.length>0&&(a=Kd(a,i)),Xh(a,r.shape)};return{a:a,b:i}}},II={kernelName:Et,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Tu(e,ku(Fu(Xo(n,"float32")),1))}}},NI={kernelName:Rt,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Tu(e,nl(Vu(1),Fu(Xo(n,"float32"))))}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function SI(e,t,n,r,s,a){const i=$i(e,"dy","avgPool3dGrad"),o=$i(t,"input","avgPool3dGrad");let u=i,l=o,c=!1;4===o.rank&&(c=!0,u=Xh(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),l=Xh(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),we(5===u.rank,(()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${u.rank}.`)),we(5===l.rank,(()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${l.rank}.`)),qh("avgPool3dGrad",s,a);const h={dy:u,input:l},p={filterSize:n,strides:r,pad:s,dimRoundingMode:a},d=gi.runKernel(Ot,h,p);return c?Xh(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const TI=Ri({avgPool3dGrad_:SI}),$I={kernelName:Dt,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{filterSize:s,strides:a,pad:i,dimRoundingMode:o}=n;return{x:()=>TI(e,r,s,a,i,o)}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function CI(e,t,n,r,s){const a=$i(e,"dy","avgPoolGrad"),i=$i(t,"input","avgPoolGrad");we(i.rank===a.rank,(()=>`Rank of input (${i.rank}) does not match rank of dy (${a.rank})`));let o=i,u=a,l=!1;3===i.rank&&(l=!0,o=Xh(i,[1,i.shape[0],i.shape[1],i.shape[2]]),u=Xh(a,[1,a.shape[0],a.shape[1],a.shape[2]])),we(4===u.rank,(()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${u.rank}.`)),we(4===o.rank,(()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${o.rank}.`));const c={dy:u,input:o},h={filterSize:n,strides:r,pad:s},p=gi.runKernel(_t,c,h);return l?Xh(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const EI=Ri({avgPoolGrad_:CI}),RI={kernelName:Ft,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{filterSize:s,strides:a,pad:i}=n;return{x:()=>EI(e,r,s,a,i)}}},AI={kernelName:Mt,inputsToSave:["a","b"],gradFunc:(e,t,n)=>{const[r,s]=t,{transposeA:a,transposeB:i}=n;return a||i?!a&&i?{a:()=>jl(e,s,!1,!1),b:()=>jl(e,r,!0,!1)}:a&&!i?{a:()=>jl(s,e,!1,!0),b:()=>jl(r,e,!1,!1)}:{a:()=>jl(s,e,!0,!0),b:()=>jl(e,r,!0,!0)}:{a:()=>jl(e,s,!1,!0),b:()=>jl(r,e,!0,!1)}}},FI={kernelName:Lt,gradFunc:(e,t,n)=>{const{blockShape:r,crops:s}=n;return{x:()=>Gm(e,r,s)}}},_I={kernelName:Bt,gradFunc:(e,t,n)=>{const r=n,s=r.inputShape,a=r.shape,i=Array.from(a);for(let u=s.length-1;u>=0;u--)if(s[u]===a[u])i[u]=1;else if(1!==s[u])throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${a}].`);const o=[];for(let u=0;u<i.length;u++)i[u]>1&&o.push(u);return{x:()=>Kd(e,o,!0)}}},DI={kernelName:Vt,gradFunc:e=>({x:()=>e.clone()})},OI={kernelName:Ut,gradFunc:e=>({x:()=>Du(e)})},MI={kernelName:Gt,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{clipValueMin:s,clipValueMax:a}=n;return{x:()=>kd(qf(bf(r,s),Rf(r,a)),e,Du(e))}}},LI={kernelName:jt,inputsToSave:["x"],gradFunc:dI.gradFunc},zI={kernelName:qt,saveAllInputs:!0,gradFunc:(e,t,n)=>{const r=t.map((e=>e.shape)),{axis:s}=n,a=De(s,t[0].shape)[0],i=r.map((e=>e[a])),o=yy(e,i,a);return o.map((e=>()=>e))}},PI={kernelName:Kt,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[r,s]=t,{dilations:a,strides:i,pad:o,dataFormat:u}=n;return we(Uh(a),(()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`)),{x:()=>jp(r.shape,e,s,i,o,u),filter:()=>xb(r,e,s.shape,i,o,u)}}},BI={kernelName:Yt,inputsToSave:["dy","filter"],gradFunc:(e,t,n)=>{const[r,s]=t,{strides:a,pad:i,dataFormat:o,dimRoundingMode:u}=n;return{dy:()=>Vp(e,s,a,i,o,1,u),filter:()=>xb(e,r,s.shape,a,i,o,u)}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function WI(e,t,n,r,s){let a=e;4===e.rank&&(a=Xh(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]));let i=t;4===i.rank&&(i=Xh(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),we(5===a.rank,(()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${a.shape}.`)),we(5===i.rank,(()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${i.shape}.`)),we(5===n.length,(()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`)),we(a.shape[4]===n[3],(()=>`Error in conv3dDerFilter: depth of input ${a.shape[4]}) must match input depth in filter (${n[3]}.`)),we(i.shape[4]===n[4],(()=>`Error in conv3dDerFilter: depth of dy (${i.shape[4]}) must match output depth for filter (${n[4]}).`));const o={x:a,dy:i},u={strides:r,pad:s,filterShape:n};return gi.runKernel(Zt,o,u)}const VI=Ri({conv3DBackpropFilter_:WI}),UI={kernelName:Jt,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:r,strides:s,pad:a}=n;we(Uh(r),(()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`));const[i,o]=t;return{x:()=>Zp(i.shape,e,o,s,a),filter:()=>VI(i,e,o.shape,s,a)}}},GI={kernelName:en,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Cu(Zl(Jg(Xo(n,"float32"))),e)}}},HI={kernelName:tn,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Cu(Qg(Xo(n,"float32")),e)}}},jI={kernelName:rn,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{axis:s,exclusive:a,reverse:i}=n;return{x:()=>{const t=Bd([s],r.rank);let n=ud(e,s,a,!i);return null!=t&&(n=nc(n,t)),n}}}},qI={kernelName:un,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:r,strides:s,pad:a,dimRoundingMode:i}=n,o=null==r?[1,1]:r;we(Uh(o),(()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`));const[u,l]=t;return we(4===u.rank,(()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${u.rank}.`)),we(4===l.rank,(()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${l.rank}.`)),we(u.shape[3]===l.shape[2],(()=>`Error in gradient of depthwiseConv2d: number of input channels (${u.shape[3]}) must match the inChannels dimension in filter ${l.shape[2]}.`)),we(Gh(s,o),(()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${s} and dilations '${o}'.`)),qh("depthwiseConv2d",a,i),{x:()=>Eb(u.shape,e,l,s,a,o,i),filter:()=>$b(u,e,l.shape,s,a,o,i)}}},KI={kernelName:pn,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[r,s]=t,a={x:r,filter:s,dy:e},i={x:r,filter:s,dy:e};return{x:()=>gi.runKernel(dn,a,n),filter:()=>gi.runKernel(fn,i,n)}}},XI={kernelName:bn,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t,r={dy:e,y:n};return{x:()=>gi.runKernel(xn,r)}}},YI={kernelName:wn,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,r=Cu(tf(Zl(Fu(n))),2/Math.sqrt(Math.PI));return{x:()=>Cu(e,r)}}},JI={kernelName:kn,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Cu(e,n)}}},ZI={kernelName:In,inputsToSave:["input"],gradFunc:(e,t)=>{const[n]=t;return{input:()=>Xh(e,n.shape)}}},QI={kernelName:Nn,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Cu(e,tf(n))}}},eN={kernelName:Cn,gradFunc:e=>({x:()=>Du(e)})},tN={kernelName:En,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=ul(n.shape,r.shape),a=()=>{const t=Tu(e,Xo(r,"float32")),a=ol(n.shape,s);return a.length>0?Xh(Kd(t,a),n.shape):t},i=()=>{let t=Cu(e,Xo(n,"float32"));const a=ol(r.shape,s);a.length>0&&(t=Xh(Kd(t,a),r.shape));const i=Fu(r);return Zl(Tu(t,Xo(i,"float32")))};return{a:a,b:i}}},nN={kernelName:Rn,inputsToSave:["x","mean","variance","scale"],gradFunc:(e,t,n)=>{const{varianceEpsilon:r}=n,[s,a,i,o]=t,u=null==o?Vu(1):o,l=ol(a.shape,s.shape),c=[];if(1===a.rank){for(let e=0;e<s.shape.length-1;++e)c.push(s.shape[e]);c.push(1)}const h=nl(s,a),p=Cu(e,u),d=Wg(ku(i,Vu(r))),f=Cu(Cu(Cu(d,d),d),Vu(-.5)),m=()=>1===a.rank?Xh(Cu(Cu(e,uf(Xh(d,[1,1,1,a.shape[0]]),c)),u),s.shape):Xh(Cu(Cu(e,d),u),s.shape),g=()=>{let e=Cu(Cu(d,Vu(-1)),p);return 1===a.rank&&(e=Kd(e,l)),Xh(e,a.shape)},y=()=>{let e=Cu(Cu(f,h),p);return 1===a.rank&&(e=Kd(e,l)),Xh(e,a.shape)},b=()=>{const t=Cu(h,d);let n=Cu(e,t);return 1===a.rank&&(n=Kd(n,l)),Xh(n,a.shape)},x=()=>{let t=e;return 1===a.rank&&(t=Kd(t,l)),Xh(t,a.shape)};return{x:m,mean:g,variance:y,scale:b,offset:x}}},rN={kernelName:An,inputsToSave:["x","indices"],gradFunc:(e,t,n)=>{const[r,s]=t,{axis:a,batchDims:i}=n,o=De(a,r.shape)[0],u=(e,t,n)=>()=>{const r=e.shape,s=t.size,i=r.slice(0,o),u=i.length,l=r.slice(a,r.length).slice(1),c=l.length,h=sN(0,u),p=sN(u+1,u+1+c),d=aN([i,[s],l]),f=Xh(n,d),m=Xh(t,[s]),g=aN([[u],h,p]),y=nc(f,g);let b=jy(y,m,e.shape[o]);const x=Wd(g);return b=nc(b,x),b};if(1===i){const t=r.shape[0],n=r.split(t,0),a=()=>{const t=Sy(n.map(((t,n)=>u(t,s.slice(n,1),e.slice(n,1))())));return t.reshape(r.shape)};return{x:a,indices:()=>s}}return{x:u(r,s,e),indices:()=>s}}};function sN(e,t){const n=[];for(let r=e;r<t;++r)n.push(r);return n}function aN(e){const t=[];for(let n=0;n<e.length;++n)for(let r=0;r<e[n].length;++r)t.push(e[n][r]);return t}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const iN={kernelName:Dn,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t;return{a:()=>Du(n),b:()=>Du(r)}}},oN={kernelName:On,gradFunc:e=>({x:()=>Xo(e,"float32")})},uN={kernelName:zn,gradFunc:e=>({x:()=>Du(e)})},lN={kernelName:Pn,gradFunc:e=>({x:()=>Du(e)})},cN={kernelName:Bn,gradFunc:e=>({x:()=>Du(e)})},hN={kernelName:Wn,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{alpha:s}=n,a=gf(r,0);return{x:()=>kd(a,e,Cu(e,s))}}},pN={kernelName:jn,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Tu(e,ku(n,1))}}},dN={kernelName:Hn,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Tu(e,Xo(n,"float32"))}}},fN={kernelName:Jn,inputsToSave:[],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r]=t,{axis:s}=n;return{logits:()=>{const t=!0,n=tf(r);return nl(e,Cu(Kd(e,s,t),n))}}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function mN(e,t,n,r=5,s=1,a=1,i=.5){const o={x:e,y:t,dy:n},u={depthRadius:r,bias:s,alpha:a,beta:i};return gi.runKernel(er,o,u)}const gN=Ri({localResponseNormalizationBackprop_:mN}),yN={kernelName:Qn,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r,s]=t,{depthRadius:a,bias:i,alpha:o,beta:u}=n;return{x:()=>gN(r,s,e,a,i,o,u)}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function bN(e,t,n,r){return t.rank<n.rank&&(t=Xh(t,zd(t.shape,r))),e.rank<n.rank&&(e=Xh(e,zd(e.shape,r))),{x:()=>{const r=Cu(e,Xo(wd(n,t),e.dtype));return r}}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const xN={kernelName:nr,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const r=n,{reductionIndices:s}=r,a=t[0],i=t[1],o=De(s,a.shape),u=bN(e,i,a,o);return{x:()=>u["x"]()}}},wN={kernelName:rr,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=()=>Cu(e,Xo(bf(n,r),"float32")),a=()=>Cu(e,Xo(Cf(n,r),"float32"));return{a:s,b:a}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function vN(e,t,n,r,s,a,i){const o=$i(e,"dy","maxPool3dGrad"),u=$i(t,"input","maxPool3dGrad"),l=$i(n,"output","maxPool3dGrad");let c=o,h=u,p=l,d=!1;4===u.rank&&(d=!0,c=Xh(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),h=Xh(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]]),p=Xh(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]])),we(5===c.rank,(()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`)),we(5===h.rank,(()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${h.rank}.`)),we(5===p.rank,(()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${p.rank}.`)),qh("maxPool3dGrad",a,i);const f={dy:c,input:h,output:p},m={filterSize:r,strides:s,pad:a,dimRoundingMode:i},g=gi.runKernel(or,f,m);return d?Xh(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}const kN=Ri({maxPool3dGrad_:vN}),IN={kernelName:ir,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r,s]=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:u}=n;return{x:()=>kN(e,r,s,a,i,o,u)}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function NN(e,t,n,r,s,a,i){const o=$i(e,"dy","maxPoolGrad"),u=$i(t,"input","maxPoolGrad"),l=$i(n,"output","maxPoolGrad");we(u.rank===o.rank,(()=>`Rank of input (${u.rank}) does not match rank of dy (${o.rank})`)),we(4===o.rank,(()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${o.rank}.`)),we(4===u.rank,(()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${u.rank}.`)),qh("maxPoolGrad",a,i);const c={dy:o,input:u,output:l},h={filterSize:r,strides:s,pad:a,dimRoundingMode:i};return gi.runKernel(ar,c,h)}const SN=Ri({maxPoolGrad_:NN}),TN={kernelName:sr,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r,s]=t,{filterSize:a,strides:i,pad:o}=n;return{x:()=>SN(e,r,s,a,i,o)}}},$N={kernelName:lr,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{axis:s}=n,a=De(s,r.shape),i=Ld(r.shape,a),o=i[1],u=Ie(o),l=()=>{const t=r.shape.slice();a.forEach((e=>{t[e]=1}));const n=Xh(e,t),s=Tu(Cu(n,dm(r.shape,"float32")),u);return s};return{x:l}}},CN={kernelName:cr,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const r=n,{axis:s}=r,[a,i]=t,o=De(s,a.shape),u=bN(e,i,a,o);return{x:()=>u["x"]()}}},EN={kernelName:hr,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=()=>Cu(e,Xo(Rf(n,r),"float32")),a=()=>Cu(e,Xo(gf(n,r),"float32"));return{a:s,b:a}}},RN={kernelName:pr,inputsToSave:["x"],gradFunc:(e,t,n)=>{const r=t[0],{paddings:s}=n,a=s.map((e=>e[0]));return{x:()=>ap(e,a,r.shape)}}},AN={kernelName:dr,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=ul(n.shape,r.shape),a=()=>{const t=ol(n.shape,s);return t.length>0?Xh(Kd(e,t),n.shape):e},i=()=>{const t=Cu(e,Zl(pf(Tu(n,r)))),a=ol(r.shape,s);return a.length>0?Xh(Kd(t,a),r.shape):t};return{a:a,b:i}}},FN={kernelName:mr,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=ul(n.shape,r.shape),a=()=>{const t=Cu(e,Xo(r,"float32")),a=ol(n.shape,s);return a.length>0?Xh(Kd(t,a),n.shape):t},i=()=>{const t=Cu(e,Xo(n,"float32")),a=ol(r.shape,s);return a.length>0?Xh(Kd(t,a),r.shape):t};return{a:a,b:i}}},_N={kernelName:gr,gradFunc:e=>({x:()=>Zl(e)})},DN={kernelName:kr,inputsToSave:["indices"],gradFunc:(e,t)=>{const n=t[0];return{indices:()=>pm(n.shape,"float32")}}},ON={kernelName:vr,gradFunc:e=>({x:()=>Du(e)})},MN={kernelName:Ir,saveAllInputs:!0,gradFunc:(e,t,n)=>{const{axis:r}=n,s=Ky(e,r);return s.map((e=>()=>e))}},LN={kernelName:Nr,inputsToSave:["x"],gradFunc:(e,t,n)=>{const r=t[0],{paddings:s}=n,a=s.map((e=>e[0]));return{x:()=>ap(e,a,r.shape)}}},zN={kernelName:Tr,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(e,t)=>{const[n,r,s]=t,a=n,i=r,o=ul(a.shape,i.shape),u=()=>{const t=Xo(i,"float32");let n=Cu(e,Cu(t,el(a,nl(t,Vu(1)))));const r=ol(a.shape,o);return r.length>0&&(n=Kd(n,r)),Xh(n,a.shape)},l=()=>{const t=gf(a,0),n=kd(t,Of(a),Du(a));let r=Cu(e,Cu(s,n));const u=ol(i.shape,o);return u.length>0&&(r=Kd(r,u)),Xh(r,i.shape)};return{a:u,b:l}}},PN={kernelName:$r,inputsToSave:["x","alpha"],gradFunc:(e,t)=>{const[n,r]=t,s=gf(n,0);return{x:()=>kd(s,e,Cu(e,r)),alpha:()=>{let t=kd(s,Du(e),Cu(e,n));const a=ol(r.shape,e.shape);return a.length>0&&(t=Kd(t,a)),Xh(t,r.shape)}}}};
/**
 * @license
 * Copyright 2022 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function BN(e,t,n){const r=e.shape.slice();r[n]=1;const s=Xh(t,r),a=id(e,n,!0,!1),i=id(e,n,!0,!0),o=Cu(a,i);return Cu(s,o)}function WN(e,t,n){const r=e.shape.length,s=r-n.length,a=Bd(n,r);let i=e;null!=a&&(i=nc(e,a));const o=i.shape.slice(),u=o.splice(r-n.length,n.length),l=u.reduce(((e,t)=>e*t),1);o.push(l);const c=i.reshape(o);let h=BN(c,t,s);if(h=h.reshape(i.shape),null!=a){const e=Wd(a);h=nc(h,e)}return h}const VN={kernelName:Cr,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{axis:s}=n;let a=[];return a=void 0===s||null===s?r.shape.map(((e,t)=>t)):"number"===typeof s?[s]:s,{x:()=>WN(r,e,a)}}},UN={kernelName:gn,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=ul(n.shape,r.shape),a=()=>{const t=Tu(e,Xo(r,"float32")),a=ol(n.shape,s);return a.length>0?Xh(Kd(t,a),n.shape):t},i=()=>{let t=Cu(e,Xo(n,"float32"));const a=ol(r.shape,s);a.length>0&&(t=Xh(Kd(t,a),r.shape));const i=Fu(r);return Zl(Tu(t,Xo(i,"float32")))};return{a:a,b:i}}},GN={kernelName:Dr,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Tu(e,Zl(Fu(n)))}}},HN={kernelName:Wr,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,r=Cu(Rf(n,6),$y(n));return{x:()=>Cu(e,Xo(r,"float32"))}}},jN={kernelName:Or,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Cu(e,Xo($y(n),"float32"))}}},qN={kernelName:Mr,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Xh(e,n.shape)}}},KN={kernelName:Pr,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[r]=t,s={dy:e,images:r},a=()=>gi.runKernel(Br,s,n);return{images:a}}},XN={kernelName:Lr,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[r]=t,s={dy:e,images:r},a=()=>gi.runKernel(zr,s,n);return{images:a}}},YN={kernelName:Vr,gradFunc:(e,t,n)=>{const{dims:r}=n,s=De(r,e.shape);return{x:()=>Eg(e,s)}}},JN={kernelName:Ur,gradFunc:e=>({x:()=>Du(e)})},ZN={kernelName:Gr,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Zl(Tu(e,Cu(el(n,1.5),2)))}}},QN={kernelName:Kr,inputsToSave:["condition"],gradFunc:(e,t)=>{const[n]=t;return{condition:()=>Xo(Du(n),"float32"),t:()=>Cu(e,Xo(n,e.dtype)),e:()=>Cu(e,Xo(Xf(n),e.dtype))}}},eS={kernelName:Xr,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=gf(n,Vu(0)),r=Vu(jw),s=Vu(qw),a=Cu(e,s),i=Cu(Cu(e,r),tf(Xo(n,"float32")));return kd(t,a,i)}}}},tS={kernelName:es,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Cu(e,Cu(n,nl(Vu(1),n)))}}},nS={kernelName:Qr,gradFunc:e=>({x:()=>Du(e)})},rS={kernelName:Jr,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Cu(nd(Xo(n,"float32")),e)}}},sS={kernelName:Zr,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Cu(sd(Xo(n,"float32")),e)}}},aS={kernelName:Yr,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{begin:s,size:a}=n,i=r.shape,[o,u]=Pc(r,s,a),l=[];for(let c=0;c<e.rank;c++)l.push([o[c],i[c]-o[c]-u[c]]);return{x:()=>Dm(e,l)}}},iS={kernelName:is,outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r]=t,{dim:s}=n,a=!0,i=Cu(e,r);return{logits:()=>nl(i,Cu(Kd(i,[s],a),r))}}},oS={kernelName:ts,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Cu(e,rp(n))}}},uS={kernelName:ss,gradFunc:(e,t,n)=>{const{blockShape:r,paddings:s}=n;return{x:()=>hp(e,r,s)}}},lS={kernelName:as,gradFunc:(e,t,n)=>{const{axis:r}=n;return{x:()=>tp(e,r)}}},cS={kernelName:ns,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Tu(e,Cu(Ru(Xo(n,"float32")),2))}}},hS={kernelName:ds,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Cu(e,Cu(Xo(n,"float32"),2))}}},pS={kernelName:ps,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=Vu(2),a=()=>Cu(e,Cu(s,nl(n,r))),i=()=>Cu(e,Cu(s,nl(r,n)));return{a:a,b:i}}},dS={kernelName:As,gradFunc:e=>({x:()=>Du(e)})},fS={kernelName:xs,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=ul(n.shape,r.shape),a=()=>{let t=e;const r=ol(n.shape,s);return r.length>0&&(t=Kd(t,r)),Xh(t,n.shape)},i=()=>{let t=e;const n=ol(r.shape,s);return n.length>0&&(t=Kd(t,n)),Xh(Zl(t),r.shape)};return{a:a,b:i}}},mS={kernelName:rs,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,s=r.shape.slice(),{axis:a}=n,i=De(a,r.shape);i.forEach((e=>{s[e]=1}));const o=Xh(e,s),u=Cu(o,dm(r.shape,"float32"));return{x:()=>u}}},gS={kernelName:ws,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Tu(e,Fu(nd(n)))}}},yS={kernelName:vs,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Cu(nl(Vu(1),Fu(n)),e)}}},bS={kernelName:ks,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{reps:s}=n,a=()=>{let t=Du(r);if(1===r.rank)for(let n=0;n<s[0];++n)t=ku(t,ap(e,[n*r.shape[0]],[r.shape[0]]));else if(2===r.rank)for(let n=0;n<s[0];++n)for(let a=0;a<s[1];++a)t=ku(t,ap(e,[n*r.shape[0],a*r.shape[1]],[r.shape[0],r.shape[1]]));else if(3===r.rank)for(let n=0;n<s[0];++n)for(let a=0;a<s[1];++a)for(let i=0;i<s[2];++i)t=ku(t,ap(e,[n*r.shape[0],a*r.shape[1],i*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else{if(4!==r.rank)throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);for(let n=0;n<s[0];++n)for(let a=0;a<s[1];++a)for(let i=0;i<s[2];++i)for(let o=0;o<s[3];++o)t=ku(t,ap(e,[n*r.shape[0],a*r.shape[1],i*r.shape[2],o*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]))}return t};return{x:a}}},xS={kernelName:Ss,gradFunc:(e,t,n)=>{const r=n,{perm:s}=r,a=Wd(s);return{x:()=>nc(e,a)}}},wS={kernelName:$s,gradFunc:(e,t,n)=>{const r=n,{axis:s}=r;return{value:()=>Sy(e,s)}}},vS={kernelName:Cs,inputsToSave:["segmentIds"],gradFunc:(e,t)=>{const[n]=t,r=()=>kS(e,n);return{x:r}}};function kS(e,t){const n=cl(t,Du(t)),r=ff(e,n);let s=bf(t,Vu(0,"int32"));const a=r.rank-s.rank;for(let o=0;o<a;++o)s=rf(s,o+1);s=qf(s,dm(r.shape,"bool"));const i=Du(r);return kd(s,r,i)}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const IS={kernelName:Rs,gradFunc:e=>({x:()=>Du(e)})},NS=[dI,fI,mI,gI,yI,bI,xI,wI,vI,kI,II,NI,$I,RI,AI,FI,_I,DI,OI,MI,LI,zI,BI,PI,UI,GI,HI,jI,qI,KI,UN,XI,YI,JI,ZI,QI,tN,eN,nN,rN,iN,oN,uN,lN,cN,hN,pN,dN,fN,yN,xN,xN,wN,IN,TN,$N,CN,EN,RN,AN,FN,_N,DN,ON,MN,LN,LN,zN,PN,VN,GN,HN,jN,qN,KN,XN,YN,JN,ZN,QN,eS,tS,nS,rS,sS,aS,iS,oS,uS,uS,lS,lS,cS,pS,hS,dS,fS,mS,gS,yS,bS,xS,wS,vS,IS];for(const c7 of NS)Hs(c7);
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.abs=function(){return this.throwIfDisposed(),al(this)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.acos=function(){return this.throwIfDisposed(),ih(this)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.acosh=function(){return this.throwIfDisposed(),uh(this)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.add=function(e){return this.throwIfDisposed(),ku(this,e)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.all=function(e,t){return this.throwIfDisposed(),ph(this,e,t)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.any=function(e,t){return this.throwIfDisposed(),fh(this,e,t)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.argMax=function(e){return this.throwIfDisposed(),gh(this,e)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.argMin=function(e){return this.throwIfDisposed(),bh(this,e)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.asScalar=function(){return this.throwIfDisposed(),we(1===this.size,(()=>"The array must have only 1 element.")),Xh(this,[])},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.asType=function(e){return this.throwIfDisposed(),Xo(this,e)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.as1D=function(){return this.throwIfDisposed(),Xh(this,[this.size])},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.as2D=function(e,t){return this.throwIfDisposed(),Xh(this,[e,t])},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.as3D=function(e,t,n){return this.throwIfDisposed(),Xh(this,[e,t,n])},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.as4D=function(e,t,n,r){return this.throwIfDisposed(),Xh(this,[e,t,n,r])},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.as5D=function(e,t,n,r,s){return this.throwIfDisposed(),Xh(this,[e,t,n,r,s])},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.asin=function(){return this.throwIfDisposed(),wh(this)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.asinh=function(){return this.throwIfDisposed(),kh(this)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.atan=function(){return this.throwIfDisposed(),Nh(this)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.atan2=function(e){return this.throwIfDisposed(),Th(this,e)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.atanh=function(){return this.throwIfDisposed(),Ch(this)},qa().prototype.avgPool=function(e,t,n,r){return this.throwIfDisposed(),Jh(this,e,t,n,r)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.batchToSpaceND=function(e,t){return this.throwIfDisposed(),hp(this,e,t)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.batchNorm=function(e,t,n,r,s){return this.throwIfDisposed(),fp(this,e,t,n,r,s)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.broadcastTo=function(e){return this.throwIfDisposed(),Cp(this,e)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.cast=function(e){return this.throwIfDisposed(),Xo(this,e)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.ceil=function(){return this.throwIfDisposed(),Rp(this)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.clipByValue=function(e,t){return this.throwIfDisposed(),Fp(this,e,t)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.concat=function(e,t){return this.throwIfDisposed(),e instanceof ja&&(e=[e]),tp([this,...e],t)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.conv1d=function(e,t,n,r,s,a){return this.throwIfDisposed(),Gp(this,e,t,n,r,s,a)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.conv2dTranspose=function(e,t,n,r,s){return this.throwIfDisposed(),Kp(this,e,t,n,r,s)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.conv2d=function(e,t,n,r,s,a){return this.throwIfDisposed(),Vp(this,e,t,n,r,s,a)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.cos=function(){return this.throwIfDisposed(),nd(this)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.cosh=function(){return this.throwIfDisposed(),sd(this)},
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.cumprod=function(e,t,n){return this.throwIfDisposed(),id(this,e,t,n)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.cumsum=function(e,t,n){return this.throwIfDisposed(),ud(this,e,t,n)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.depthToSpace=function(e,t){return this.throwIfDisposed(),pd(this,e,t)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.depthwiseConv2d=function(e,t,n,r,s,a){return this.throwIfDisposed(),fd(this,e,t,n,r,s,a)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.dilation2d=function(e,t,n,r,s){return this.throwIfDisposed(),bd(this,e,t,n,r,s)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.divNoNan=function(e){return this.throwIfDisposed(),Nd(this,e)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.div=function(e){return this.throwIfDisposed(),Tu(this,e)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.dot=function(e){return this.throwIfDisposed(),Td(this,e)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.elu=function(){return this.throwIfDisposed(),Rd(this)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.equal=function(e){return this.throwIfDisposed(),wd(this,e)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.erf=function(){return this.throwIfDisposed(),Dd(this)},
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.euclideanNorm=function(e,t){return this.throwIfDisposed(),Qd(this,e,t)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.exp=function(){return this.throwIfDisposed(),tf(this)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.expandDims=function(e){return this.throwIfDisposed(),rf(this,e)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.expm1=function(){return this.throwIfDisposed(),af(this)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.fft=function(){return this.throwIfDisposed(),hy(this)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.flatten=function(){return this.throwIfDisposed(),Xh(this,[this.size])},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.floor=function(){return this.throwIfDisposed(),pf(this)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.floorDiv=function(e){return this.throwIfDisposed(),Nu(this,e)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.gather=function(e,t,n){return this.throwIfDisposed(),ff(this,e,t,n)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.greaterEqual=function(e){return this.throwIfDisposed(),bf(this,e)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.greater=function(e){return this.throwIfDisposed(),gf(this,e)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.ifft=function(){return this.throwIfDisposed(),dy(this)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.irfft=function(){return this.throwIfDisposed(),my(this)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.isFinite=function(){return this.throwIfDisposed(),wf(this)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.isInf=function(){return this.throwIfDisposed(),kf(this)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.isNaN=function(){return this.throwIfDisposed(),Nf(this)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.leakyRelu=function(e){return this.throwIfDisposed(),Tf(this,e)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.lessEqual=function(e){return this.throwIfDisposed(),Rf(this,e)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.less=function(e){return this.throwIfDisposed(),Cf(this,e)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.localResponseNormalization=function(e,t,n,r){return this.throwIfDisposed(),_f(this,e,t,n,r)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.logSigmoid=function(){return this.throwIfDisposed(),Wf(this)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.logSoftmax=function(e){return this.throwIfDisposed(),Uf(this,e)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.logSumExp=function(e,t){return this.throwIfDisposed(),Hf(this,e,t)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.log=function(){return this.throwIfDisposed(),Of(this)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.log1p=function(){return this.throwIfDisposed(),Lf(this)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.logicalAnd=function(e){return this.throwIfDisposed(),qf(this,e)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.logicalNot=function(){return this.throwIfDisposed(),Xf(this)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.logicalOr=function(e){return this.throwIfDisposed(),Jf(this,e)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.logicalXor=function(e){return this.throwIfDisposed(),Qf(this,e)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.matMul=function(e,t,n){return this.throwIfDisposed(),jl(this,e,t,n)},qa().prototype.maxPool=function(e,t,n,r){return this.throwIfDisposed(),am(this,e,t,n,r)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.max=function(e,t){return this.throwIfDisposed(),Gd(this,e,t)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.maximum=function(e){return this.throwIfDisposed(),cl(this,e)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.mean=function(e,t){return this.throwIfDisposed(),hm(this,e,t)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.min=function(e,t){return this.throwIfDisposed(),jd(this,e,t)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.minimum=function(e){return this.throwIfDisposed(),gm(this,e)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.mirrorPad=function(e,t){return this.throwIfDisposed(),bm(this,e,t)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.mod=function(e){return this.throwIfDisposed(),wm(this,e)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.mul=function(e){return this.throwIfDisposed(),Cu(this,e)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.neg=function(){return this.throwIfDisposed(),Zl(this)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.norm=function(e,t,n){return this.throwIfDisposed(),Jd(this,e,t,n)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.notEqual=function(e){return this.throwIfDisposed(),Cm(this,e)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.oneHot=function(e,t=1,n=0){return this.throwIfDisposed(),Kl(this,e,t,n)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.onesLike=function(){return this.throwIfDisposed(),Rm(this)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.pad=function(e,t){return this.throwIfDisposed(),Dm(this,e,t)},qa().prototype.pool=function(e,t,n,r,s,a){return this.throwIfDisposed(),Km(this,e,t,n,r,s,a)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.pow=function(e){return this.throwIfDisposed(),el(this,e)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.prelu=function(e){return this.throwIfDisposed(),Ym(this,e)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.prod=function(e,t){return this.throwIfDisposed(),Zm(this,e,t)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.reciprocal=function(){return this.throwIfDisposed(),Ig(this)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.relu=function(){return this.throwIfDisposed(),Sg(this)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.relu6=function(){return this.throwIfDisposed(),$g(this)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.reshapeAs=function(e){return this.throwIfDisposed(),Xh(this,e.shape)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.reshape=function(e){return this.throwIfDisposed(),Xh(this,e)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.resizeBilinear=function(e,t,n){return this.throwIfDisposed(),Ix(this,e,t,n)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.resizeNearestNeighbor=function(e,t,n){return this.throwIfDisposed(),Sx(this,e,t,n)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.reverse=function(e){return this.throwIfDisposed(),Eg(this,e)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.rfft=function(){return this.throwIfDisposed(),xy(this)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.round=function(){return this.throwIfDisposed(),Pg(this)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.rsqrt=function(){return this.throwIfDisposed(),Wg(this)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.selu=function(){return this.throwIfDisposed(),Ug(this)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.separableConv2d=function(e,t,n,r,s,a){return this.throwIfDisposed(),Hg(this,e,t,n,r,s,a)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.sigmoid=function(){return this.throwIfDisposed(),rp(this)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.sign=function(){return this.throwIfDisposed(),Xg(this)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.sin=function(){return this.throwIfDisposed(),Jg(this)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.sinh=function(){return this.throwIfDisposed(),Qg(this)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.slice=function(e,t){return this.throwIfDisposed(),ap(this,e,t)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.softmax=function(e){return this.throwIfDisposed(),ly(this,e)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.softplus=function(){return this.throwIfDisposed(),Pf(this)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.spaceToBatchND=function(e,t){return this.throwIfDisposed(),Gm(this,e,t)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.split=function(e,t){return this.throwIfDisposed(),yy(this,e,t)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.sqrt=function(){return this.throwIfDisposed(),Ru(this)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.square=function(){return this.throwIfDisposed(),Fu(this)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.squaredDifference=function(e){return this.throwIfDisposed(),vy(this,e)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.squeeze=function(e){return this.throwIfDisposed(),Iy(this,e)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.stack=function(e,t){this.throwIfDisposed();const n=e instanceof ja?[this,e]:[this,...e];return Sy(n,t)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.step=function(e){return this.throwIfDisposed(),$y(this,e)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.stridedSlice=function(e,t,n,r,s,a,i,o){return this.throwIfDisposed(),Ey(this,e,t,n,r,s,a,i,o)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.sub=function(e){return this.throwIfDisposed(),nl(this,e)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.sum=function(e,t){return this.throwIfDisposed(),Kd(this,e,t)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.tan=function(){return this.throwIfDisposed(),Ay(this)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.tanh=function(){return this.throwIfDisposed(),op(this)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.tile=function(e){return this.throwIfDisposed(),uf(this,e)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.toBool=function(){return this.throwIfDisposed(),Xo(this,"bool")},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.toFloat=function(){return this.throwIfDisposed(),Xo(this,"float32")},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.toInt=function(){return this.throwIfDisposed(),Xo(this,"int32")},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.topk=function(e,t){return this.throwIfDisposed(),By(this,e,t)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.transpose=function(e){return this.throwIfDisposed(),nc(this,e)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.unique=function(e){return this.throwIfDisposed(),Gy(this,e)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.unsortedSegmentSum=function(e,t){return this.throwIfDisposed(),jy(this,e,t)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.unstack=function(e){return this.throwIfDisposed(),Ky(this,e)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.where=function(e,t){return this.throwIfDisposed(),kd(e,this,t)},
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
qa().prototype.zerosLike=function(){return this.throwIfDisposed(),Du(this)};
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
class SS extends Error{constructor(e){super(e),Object.setPrototypeOf(this,SS.prototype)}}class TS extends Error{constructor(e){super(e),Object.setPrototypeOf(this,TS.prototype)}}class $S extends Error{constructor(e){super(e),Object.setPrototypeOf(this,$S.prototype)}}class CS extends Error{constructor(e){super(e),Object.setPrototypeOf(this,CS.prototype)}}class ES extends Error{constructor(e){super(e),Object.setPrototypeOf(this,ES.prototype)}}Error;
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
class RS{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){const e=this.cache.keys().next().value;this.cache.delete(e)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){const e=this.cache.keys().next().value;this.cache.delete(e)}this.maxEntries=e}}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function AS(e,t){if(Array.isArray(e)){let n=[];for(let r=0;r<t;r++)n=n.concat(e);return n}{const n=new Array(t);return n.fill(e),n}}function FS(e,t){if(!e)throw new ES(t)}function _S(e,t){let n=0;for(const r of e)r===t&&n++;return n}function DS(e){return 1===e.length?e[0]:e}function OS(e){return Array.isArray(e)?e:[e]}function MS(e){const t=e.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2"),n=t.replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==n[0]?n:"private"+n}function LS(e){return e.length<=1||-1===e.indexOf("_")?e:e.replace(/[_]+(\w|$)/g,((e,t)=>t.toUpperCase()))}let zS={};function PS(e){if(null===e||void 0===e)return null;const t={};return t["className"]=e.getClassName(),t["config"]=e.getConfig(),t}function BS(e){if(null!=e&&"object"===typeof e)if(Array.isArray(e))e.forEach((e=>BS(e)));else{const t=Object.keys(e);for(const n of t){const t=e[n];null!=t&&"object"===typeof t&&(Array.isArray(t)||"ndarray"!==t["type"]||"number"!==typeof t["value"]?BS(t):e[n]=t["value"])}}}function WS(e,t={},n={},r="object",s=!1){if("string"===typeof e){const s=e;let a;if(s in n)a=n[s];else if(s in zS)a=zS[s];else if(a=t[s],null==a)throw new $S(`Unknown ${r}: ${e}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return a}{const a=e;if(null==a["className"]||null==a["config"])throw new $S(`${r}: Improper config format: ${JSON.stringify(a)}.\n'className' and 'config' must set.`);const i=a["className"];let o,u;if(i in n?[o,u]=n[i]:i in zS?[o,u]=zS["className"]:i in t&&([o,u]=t[i]),null==o)throw new $S(`Unknown ${r}: ${i}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(null!=u){const e={};for(const n of Object.keys(zS))e[n]=zS[n];for(const s of Object.keys(n))e[s]=n[s];const t=a["config"];t["customObjects"]=e;const r=Object.assign({},zS);for(const s of Object.keys(n))zS[s]=n[s];BS(a["config"]);const i=u(o,a["config"],n,s);return zS=Object.assign({},r),i}{const e=Object.assign({},zS);for(const r of Object.keys(n))zS[r]=n[r];const t=new o(a["config"]);return zS=Object.assign({},e),t}}}function VS(e,t){return e<t?-1:e>t?1:0}function US(e,t){return-1*VS(e,t)}function GS(e){if(null==e)return e;const t=[];for(const n of e)-1===t.indexOf(n)&&t.push(n);return t}function HS(e){if(null==e)throw new $S(`Invalid value in obj: ${JSON.stringify(e)}`);for(const t in e)if(e.hasOwnProperty(t))return!1;return!0}function jS(e,t,n){if(null!=n&&e.indexOf(n)<0)throw new $S(`${n} is not a valid ${t}.  Valid values are ${e} or null/undefined.`)}function qS(e,t,n=0,r=1/0){return FS(n>=0),FS(r>=n),Array.isArray(e)&&e.length>=n&&e.length<=r&&e.every((e=>typeof e===t))}function KS(e,t){Array.isArray(e)?(we(e.length>0,(()=>`${t} is unexpectedly an empty array.`)),e.forEach(((e,n)=>KS(e,`element ${n+1} of ${t}`)))):we(Number.isInteger(e)&&e>0,(()=>`Expected ${t} to be a positive integer, but got ${XS(e)}.`))}function XS(e){return null===e?"null":Array.isArray(e)?"["+e.map((e=>XS(e))).join(",")+"]":"string"===typeof e?`"${e}"`:`${e}`}function YS(e,t,n){let r,s=null!=n?n():xa();const a=(...a)=>{const i=null!=n?n():xa();return i-s<t||(s=i,r=e(...a)),r};return a}function JS(e){return"relu"===e?"relu":"linear"===e?"linear":"elu"===e?"elu":null}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
let ZS=0;function QS(){return ZS++}const eT={};function tT(e=""){return e in eT||(eT[e]=0),eT[e]+=1,e+eT[e].toString()}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
const nT=["channelsFirst","channelsLast"],rT=["nearest","bilinear"],sT=["valid","same","causal"],aT=["max","avg"],iT=["sum","mul","concat","ave"],oT=new Map;function uT(e){jS(nT,"DataFormat",e)}function lT(e){jS(rT,"InterpolationFormat",e)}function cT(e){jS(sT,"PaddingMode",e)}function hT(e){jS(aT,"PoolMode",e)}const pT=[],dT="/";function fT(e,t){pT.push(e);try{const e=t();return pT.pop(),e}catch(n){throw pT.pop(),n}}function mT(){return 0===pT.length?"":pT.join(dT)+dT}function gT(e){if(!xT(e))throw new Error("Not a valid tensor name: '"+e+"'");return mT()+e}function yT(e){if(!xT(e))throw new Error("Not a valid tensor name: '"+e+"'");oT.has(e)||oT.set(e,0);const t=oT.get(e);if(oT.set(e,oT.get(e)+1),t>0){const n=`${e}_${t}`;return oT.set(n,1),n}return e}const bT=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function xT(e){return!!e.match(bT)}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function wT(e){return e===parseInt(e.toString(),10)}function vT(e,t,n){null==t&&(t=0),null==n&&(n=e.length);let r=1;for(let s=t;s<n;++s)r*=e[s];return r}function kT(e){if(0===e.length)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let n=0;n<e.length;n++){const r=e[n];r<t&&(t=r)}return t}function IT(e){if(0===e.length)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let n=0;n<e.length;n++){const r=e[n];r>t&&(t=r)}return t}function NT(e,t){if(t<e)throw new $S(`end (${t}) < begin (${e}) is forbidden.`);const n=[];for(let r=e;r<t;++r)n.push(r);return n}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
let ST;function TT(){return null==ST&&(ST=xu().epsilon()),ST}function $T(){return"channelsLast"}function CT(e,t){return Xo(e,t)}function ET(e,t=-1){const n=e.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),Xh(e,n)}function RT(e,t){return uu((()=>{if(2!==e.shape.length)throw new $S(`repeat() expects a rank-2 tensor, but received a rank-${e.shape.length} tensor.`);const n=ET(e,1);return zT(n,[1,t,1])}))}function AT(e){const t=[vT(e.shape)];return Xh(e,t)}function FT(e){if(e.rank<=1)throw new $S(`batchFlatten requires a minimum rank of 2. Got rank: ${e.rank}.`);const t=[e.shape[0],vT(e.shape,1)];return Xh(e,t)}function _T(e,t,n){return uu((()=>{switch(e.rank){case 1:return ty(e,t,n);case 2:return ry(e,[t,0],[n,e.shape[1]]);case 3:return ay(e,[t,0,0],[n,e.shape[1],e.shape[2]]);case 4:return oy(e,[t,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3]]);case 5:return ap(e,[t,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4]]);case 6:return ap(e,[t,0,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4],e.shape[5]]);default:throw new $S(`sliceAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function DT(e,t,n){return uu((()=>{switch(e.rank){case 1:return ty(e,t,n);case 2:return ry(e,[0,t],[e.shape[0],n]);case 3:return ay(e,[0,0,t],[e.shape[0],e.shape[1],n]);case 4:return oy(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],n]);default:throw new $S(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function OT(e,t,n,r){return uu((()=>{switch(e.rank){case 1:return ty(e,t,n);case 2:switch(r){case 1:return _T(e,t,n);case 2:return DT(e,t,n);default:throw new $S(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return _T(e,t,n);case 2:return ay(e,[0,t,0],[e.shape[0],n,e.shape[2]]);case 3:return DT(e,t,n);default:throw new $S(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return _T(e,t,n);case 2:return oy(e,[0,t,0,0],[e.shape[0],n,e.shape[2],e.shape[3]]);case 3:return oy(e,[0,0,t,0],[e.shape[0],e.shape[1],n,e.shape[3]]);case 4:return DT(e,t,n);default:throw new $S(`The axis is not within the rank of the tensor ${r}`)}default:throw new $S(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function MT(e,t=-1){let n;return t<0&&(n=e[0].rank,t=0!==n?n:0),t===e[0].rank&&(t=-1),tp(e,t)}function LT(e,t){switch(e.rank){case 1:return Dp([e,t]);case 2:return Mp([e,t],0);case 3:return zp([e,t],0);case 4:return Bp([e,t],0);default:throw new $S(`concatAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}function zT(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new $S(`The length of input n (${t.length}) does not match the number of dimensions in input x (${e.rank})`);return uf(e,t)}function PT(e,t=0,n=1,r,s){return fg(e,t,n,r,s)}function BT(e,t,n,r){if(e.rank<2||t.rank<2)throw new CS(`dot requires both inputs to be rank >= 2 but got x shape = ${e.shape} and y shape = ${t.shape}`);if(t.rank>=3){const n=e.shape.slice(-1)[0],r=t.shape.slice(-2)[0];if(n!==r)throw new CS(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${e.shape} and  y shape = ${t.shape}`)}if(2===e.rank&&2===t.rank){const s=!1,a=!1;return _b({a:e,b:t,transposeA:s,transposeB:a,bias:r?UT(e.rank,r,$T()):null,activation:n})}{const s=e.shape.slice(),a=s.pop();e=Xh(e,[-1,a]);const i=t.shape.slice(),o=i.pop(),u=i.pop(),l=[...i,o],c=Array.from({length:t.rank},((e,n)=>0===n?t.rank-2:n<=t.rank-2?n-1:n));t=Xh(nc(t,c),[u,-1]);const h=[...s,...l],p=!1,d=!1;return Xh(_b({a:e,b:t,transposeA:p,transposeB:d,bias:r?UT(e.rank,r,$T()):null,activation:n}),h)}}function WT(e,t,n){return uu((()=>(t=Array.isArray(t)?Fy(t,"int32"):Xo(t,"int32"),ff(e,t,n))))}function VT(e){return Cu(e,e)}function UT(e,t,n){const r=t.shape;if(1!==t.rank&&t.rank!==e)throw new $S(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${e}`);if(5===e){if("channelsFirst"===n)return 1===r.length?Xh(t,[1,r[0],1,1,1]):Xh(t,[1,r[3],r[0],r[1],r[2]]);if("channelsLast"===n)return 1===r.length?Xh(t,[1,1,1,1,r[0]]):Xh(t,[1].concat(r))}else if(4===e){if("channelsFirst"===n)return 1===r.length?Xh(t,[1,r[0],1,1]):Xh(t,[1,r[2],r[0],r[1]]);if("channelsLast"===n)return 1===r.length?Xh(t,[1,1,1,r[0]]):Xh(t,[1].concat(r))}else if(3===e){if("channelsFirst"===n)return 1===r.length?Xh(t,[1,r[0],1]):Xh(t,[1,r[1],r[0]]);if("channelsLast"===n)return 1===r.length?Xh(t,[1,1,r[0]]):Xh(t,[1].concat(r))}else if(e<3)return t;throw new $S(`Unsupported input rank by biasAdd: ${t.rank}`)}function GT(e,t,n){return uu((()=>(null==n&&(n=$T()),uT(n),ku(e,UT(e.rank,t,n)))))}function HT(e,t=1){if(1!==t)throw new CS(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return Rd(e)}function jT(e){return uu((()=>Tu(e,ku(al(e),1))))}function qT(e,t,n,r){return uu((()=>db(e,t,n,r)))}function KT(e){return uu((()=>{const t=ku(.5,Cu(.2,e));return Fp(t,0,1)}))}function XT(e,t,n=!1){return n?e():t()}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
const YT=["fanIn","fanOut","fanAvg"],JT=["normal","uniform","truncatedNormal"];
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function ZT(e){jS(YT,"FanMode",e)}function QT(e){jS(JT,"Distribution",e)}class e$ extends Hu{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class t$ extends e${apply(e,t){return pm(e,t)}}t$.className="Zeros",qu(t$);class n$ extends e${apply(e,t){return dm(e,t)}}n$.className="Ones",qu(n$);class r$ extends e${constructor(e){if(super(),"object"!==typeof e)throw new $S(`Expected argument of type ConstantConfig but got ${e}`);if(void 0===e.value)throw new $S(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return uu((()=>Cu(Vu(this.value),dm(e,t))))}getConfig(){return{value:this.value}}}r$.className="Constant",qu(r$);class s$ extends e${constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return bg(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}s$.className="RandomUniform",qu(s$);class a$ extends e${constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32","float32"!==t&&"int32"!==t)throw new CS(`randomNormal does not support dType ${t}.`);return PT(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}a$.className="RandomNormal",qu(a$);class i$ extends e${constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32","float32"!==t&&"int32"!==t)throw new CS(`truncatedNormal does not support dType ${t}.`);return Vy(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}i$.className="TruncatedNormal",qu(i$);class o$ extends e${constructor(e){super(),this.gain=null!=e.gain?e.gain:1}apply(e,t){return uu((()=>{if(2!==e.length||e[0]!==e[1])throw new $S("Identity matrix initializer can only be used for 2D square matrices.");return Cu(this.gain,cf(e[0]))}))}getConfig(){return{gain:this.gain}}}function u$(e,t="channelsLast"){let n,r;if(uT(t),2===e.length)n=e[0],r=e[1];else if(-1!==[3,4,5].indexOf(e.length)){if("channelsFirst"===t){const t=vT(e,2);n=e[1]*t,r=e[0]*t}else if("channelsLast"===t){const t=vT(e,0,e.length-2);n=e[e.length-2]*t,r=e[e.length-1]*t}}else{const t=vT(e);n=Math.sqrt(t),r=Math.sqrt(t)}return[n,r]}o$.className="Identity",qu(o$);class l$ extends e${constructor(e){if(super(),e.scale<0)throw new $S(`scale must be a positive float. Got: ${e.scale}`);this.scale=null==e.scale?1:e.scale,this.mode=null==e.mode?"fanIn":e.mode,ZT(this.mode),this.distribution=null==e.distribution?"normal":e.distribution,QT(this.distribution),this.seed=e.seed}apply(e,t){const n=u$(e),r=n[0],s=n[1];let a=this.scale;if("fanIn"===this.mode?a/=Math.max(1,r):"fanOut"===this.mode?a/=Math.max(1,s):a/=Math.max(1,(r+s)/2),"normal"===this.distribution){const n=Math.sqrt(a);if(t=t||"float32","float32"!==t&&"int32"!==t)throw new CS(`${this.getClassName()} does not support dType ${t}.`);return Vy(e,0,n,t,this.seed)}{const n=Math.sqrt(3*a);return bg(e,-n,n,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}l$.className="VarianceScaling",qu(l$);class c$ extends l${constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return l$.className}}c$.className="GlorotUniform",qu(c$);class h$ extends l${constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return l$.className}}h$.className="GlorotNormal",qu(h$);class p$ extends l${constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return l$.className}}p$.className="HeNormal",qu(p$);class d$ extends l${constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return l$.className}}d$.className="HeUniform",qu(d$);class f$ extends l${constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return l$.className}}f$.className="LeCunNormal",qu(f$);class m$ extends l${constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return l$.className}}m$.className="LeCunUniform",qu(m$);class g$ extends e${constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=null==e.gain?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,t){return uu((()=>{if(e.length<2)throw new CS("Shape must be at least 2D.");if("int32"!==t&&"float32"!==t&&void 0!==t)throw new TypeError(`Unsupported data type ${t}.`);const n=Ie(e.slice(0,-1)),r=e[e.length-1],s=n*r;s>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${s}) elements: Slowness may result.`);const a=[Math.max(r,n),Math.min(r,n)],i=PT(a,0,1,t,this.seed),o=Nw.qr(i,!1);let u=o[0];const l=o[1],c=l.flatten().stridedSlice([0],[Math.min(r,n)*Math.min(r,n)],[Math.min(r,n)+1]);return u=Cu(u,c.sign()),n<r&&(u=u.transpose()),Cu(Vu(this.gain),u.reshape(e))}))}getConfig(){return{gain:this.gain,seed:this.seed}}}g$.className="Orthogonal",qu(g$);const y$={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function b$(e,t={}){return WS(e,ju.getMap().classNameMap,t,"initializer")}function x$(e){return PS(e)}function w$(e){if("string"===typeof e){const t=e in y$?y$[e]:e;if("GlorotNormal"===t)return new h$;if("GlorotUniform"===t)return new c$;if("HeNormal"===t)return new p$;if("HeUniform"===t)return new d$;if("LeCunNormal"===t)return new f$;if("LeCunUniform"===t)return new m$;{const e={};return e["className"]=t,e["config"]={},b$(e)}}return e instanceof e$?e:b$(e)}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function v$(e){return Array.isArray(e)&&Array.isArray(e[0])}function k$(e){return 0===e.length?[]:Array.isArray(e[0])?e:[e]}function I$(e){let t;if(Array.isArray(e)){if(1!==e.length)throw new $S(`Expected Tensor length to be 1; got ${e.length}`);t=e[0]}else t=e;return t}function N$(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(1===e.length)return e[0];throw new $S(`Expected exactly 1 Shape; got ${e.length}`)}return e}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function S$(e){let t=0;for(const n of e)0===n.shape.length?t+=1:t+=n.shape.reduce(((e,t)=>e*t));return t}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
const T$="Variable";class $${constructor(e,t="float32",n=T$,r=!0,s=null){this.dtype=null==t?"float32":t,this.shape=e.shape,this.id=QS(),n=null==n?T$:n,this.originalName=gT(n),this.name=yT(this.originalName),this.trainable_=r,this.constraint=s,this.val=Yy(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),C$(this.val,e),this.val.id!==e.id&&(this.val.assign(e),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}}function C$(e,t){if(e.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(e.shape)+" vs. "+JSON.stringify(t.shape))}function E$(e){return e.map((e=>e.read()))}function R$(e){e.forEach((e=>{const t=e[0];t.write(e[1])}))}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
class A${constructor(e){this.dtype=e.dtype,this.shape=e.shape,null!=e.shape?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}}class F${constructor(e,t,n,r,s,a,i){this.dtype=e,this.shape=t,this.sourceLayer=n,this.inputs=r,this.callArgs=s,this.outputTensorIndex=i,this.id=QS(),null!=a&&(this.originalName=gT(a),this.name=yT(this.originalName)),this.rank=t.length}}let _$=0;class D${constructor(e,t){this.callArgs=t,this.id=_$++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(const n of e.inboundLayers)null!=n&&n.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){const e=[];for(const t of this.inboundLayers)null!=t?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let O$=0;class M$ extends Hu{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=O$++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){const e=this.getClassName();t=MS(e)+"_"+tT(e)}if(this.name=t,this.trainable_=null==e.trainable||e.trainable,null!=e.inputShape||null!=e.batchInputShape){let t;if(null!=e.batchInputShape)t=e.batchInputShape;else if(null!=e.inputShape){let n=null;null!=e.batchSize&&(n=e.batchSize),t=[n].concat(e.inputShape)}this.batchInputShape=t;let n=e.dtype;null==n&&(n=e.inputDType),null==n&&(n="float32"),this.dtype=n}null!=e.weights?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(0===this.inboundNodes.length)throw new TS(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new $S(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return DS(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return DS(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new SS(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(0===this.inboundNodes.length)throw new SS(`Layer ${this.name} is not connected, no input to return.`);return DS(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new SS(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new SS(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return DS(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map((e=>e()))}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach((t=>t.trainable=e)),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter((e=>e.trainable)):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter((e=>!e.trainable)).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){const t=OS(e);if(null==this.inputSpec||0===this.inputSpec.length)return;const n=OS(this.inputSpec);if(t.length!==n.length)throw new $S(`Layer ${this.name} expects ${n.length} inputs, but it received ${t.length} input tensors. Input received: ${e}`);for(let r=0;r<t.length;r++){const e=t[r],s=n[r];if(null==s)continue;const a=e.rank;if(null!=s.ndim&&a!==s.ndim)throw new $S(`Input ${r} is incompatible with layer ${this.name}: expected ndim=${s.ndim}, found ndim=${a}`);if(null!=s.maxNDim&&a>s.maxNDim)throw new $S(`Input ${r} is incompatible with layer ${this.name}: expected max_ndim=${s.maxNDim}, found ndim=${a}`);if(null!=s.minNDim&&a<s.minNDim)throw new $S(`Input ${r} is incompatible with layer ${this.name}: expected min_ndim=${s.minNDim}, found ndim=${a}.`);if(null!=s.dtype&&e.dtype!==s.dtype)throw new $S(`Input ${r} is incompatible with layer ${this.name} : expected dtype=${s.dtype}, found dtype=${e.dtype}.`);if(s.axes){const t=e.shape;for(const e in s.axes){const n=Number(e),a=s.axes[e],i=n>=0?t[n]:t[t.length+n];if(null!=a&&-1===[a,null].indexOf(i))throw new $S(`Input ${r} is incompatible with layer ${this.name}: expected axis ${n} of input shape to have value ${a} but got shape ${t}.`)}}if(null!=s.shape)for(let t=0;t<s.shape.length;++t){const n=s.shape[t],a=e.shape[t];if(null!=n&&null!=a&&n!==a)throw new $S(`Input ${r} is incompatible with layer ${this.name}: expected shape=${s.shape}, found shape=${e.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){null!=this._callHook&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();const n=OS(e),r=B$(e),s=W$(e);if(r===s)throw new $S("Arguments to apply() must be all SymbolicTensors or all Tensors");return fT(this.name,(()=>{if(!this.built){this.assertInputCompatibility(e);const t=[];for(const n of OS(e))t.push(n.shape);this.build(DS(t)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&s&&(this._refCount=1)}if(this.assertInputCompatibility(e),s){let r=this.call(e,t);this.supportsMasking&&this.setMaskMetadata(e,r);const s=OS(r),a=[];for(let e of s)-1!==n.indexOf(e)&&(e=e.clone()),a.push(e);if(r=DS(a),null!=this.activityRegularizer)throw new CS("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return r}{const n=L$(e),r=this.computeOutputShape(n);let s;const a=z$(e);if(this.warnOnIncompatibleInputShape(Array.isArray(e)?n[0]:n),s=null!=r&&r.length>0&&Array.isArray(r[0])?r.map(((n,r)=>new F$(a,n,this,OS(e),t,this.name,r))):new F$(a,r,this,OS(e),t,this.name),this.addInboundNode(e,s,null,null,n,r,t),this._refCount++,null!=this.activityRegularizer)throw new CS("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return s}}))}warnOnIncompatibleInputShape(e){if(null!=this.batchInputShape)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach(((n,r)=>{null!=n&&null!=e[r]&&e[r]!==n&&(t=!0)})),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new SS(`The layer ${this.name} has never been called and thus has no defined output shape.`);const e=[];for(const t of this.inboundNodes){const n=JSON.stringify(t.outputShapes);-1===e.indexOf(n)&&e.push(n)}if(1===e.length){const e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&1===e.length?e[0]:e}throw new SS(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new TS(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return S$(this.weights)}build(e){this.built=!0}getWeights(e=!1){return E$(e?this.trainableWeights:this.weights)}setWeights(e){uu((()=>{const t=this.weights;if(t.length!==e.length)throw new $S(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(0===t.length)return;const n=[],r=E$(t);for(let s=0;s<r.length;++s){const a=r[s],i=t[s],o=e[s];if(!Te(a.shape,o.shape))throw new $S(`Layer weight shape ${a.shape} not compatible with provided weight shape ${o.shape}`);n.push([i,o])}R$(n)}))}addWeight(e,t,n,r,s,a,i,o){if(-1!==this._addedWeightNames.indexOf(e))throw new $S(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),null==n&&(n="float32"),this.fastWeightInitDuringBuild&&(r=null!=o?o():w$("zeros"));const u=r.apply(t,n),l=new $$(u,n,e,a,i);return u.dispose(),null!=s&&this.addLoss((()=>s.apply(l.read()))),null==a&&(a=!0),a?this._trainableWeights.push(l):this._nonTrainableWeights.push(l),l}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){null==e||Array.isArray(e)&&0===e.length||(e=OS(e),void 0!==this._losses&&null!==this._losses&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(null!=t){if(!Array.isArray(t))throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);t.forEach((e=>{if(null!=e)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)}))}return null}return t}setMaskMetadata(e,t,n){if(!this.supportsMasking)return;const r=this.computeMask(e,n);if(t instanceof Array&&r instanceof Array){if(t.length!==r.length)throw new Error(`${this.name} outputs ${t.length} tensors but ${r.length} masks for those tensors`);for(let e=0;e<t.length;e++)t[e].kerasMask=r[e]}else{if(r instanceof Array)throw new Error(`{this.name} outputs a single tensor but ${r.length} masks`);if(t instanceof Array)throw new Error(`{this.name} outputs ${t.length} tensors but only one mask`);t.kerasMask=r}}addInboundNode(e,t,n,r,s,a,i=null){const o=OS(e);t=OS(t),n=OS(n),r=OS(r),s=k$(s),a=k$(a);const u=[],l=[],c=[];for(const h of o)u.push(h.sourceLayer),l.push(h.nodeIndex),c.push(h.tensorIndex);new D$({outboundLayer:this,inboundLayers:u,nodeIndices:l,tensorIndices:c,inputTensors:o,outputTensors:t,inputMasks:n,outputMasks:r,inputShapes:s,outputShapes:a},i);for(let h=0;h<t.length;h++)t[h].sourceLayer=this,t[h].nodeIndex=this.inboundNodes.length-1,t[h].tensorIndex=h}getConfig(){const e={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(e["batchInputShape"]=this.batchInputShape),null!=this.dtype&&(e["dtype"]=this.dtype),e}disposeWeights(){return this.weights.forEach((e=>e.dispose())),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(null===this._refCount)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return 0===--this._refCount&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}}function L$(e){e=OS(e);const t=[];for(const n of e)t.push(n.shape);return DS(t)}function z$(e){return"float32"}function P$(e,t,n){if((null==t||null!=n&&n>0)&&(t=e.sourceLayer,n=e.nodeIndex),0===t.inboundNodes.length)return[e];{const e=t.inboundNodes[n];if(0===e.inboundLayers.length)return e.inputTensors;{const t=[];for(let n=0;n<e.inboundLayers.length;n++){const r=e.inputTensors[n],s=e.inboundLayers[n],a=e.nodeIndices[n],i=P$(r,s,a);for(const e of i)-1===t.indexOf(e)&&t.push(e)}return t}}}function B$(e){let t=!0;for(const n of OS(e))if(!(n instanceof F$)){t=!1;break}return t}function W$(e){let t=!0;for(const n of OS(e))if(n instanceof F$){t=!1;break}return t}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
class V$ extends M${constructor(e){if(super({dtype:e.dtype,name:null!=e.name?e.name:tT("input").toString()}),null==e.batchSize&&(e.batchSize=null),null==e.sparse&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,null!=e.inputShape&&null!=e.batchInputShape)throw new $S("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(null==t){if(null==e.inputShape)throw new $S("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(null!=e.batchSize)throw new $S("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const n=e.dtype||"float32";this.batchInputShape=t,this.dtype=n,this.inputSpec=[{shape:t}];const r=new F$(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new D$({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new $S(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}function U$(e){if(null==e.batchShape&&null==e.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=e.batchShape&&null!=e.shape)throw new $S("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=e.batchShape;null!=e.shape&&null==t&&(t=[null].concat(e.shape));let n=e.dtype;null==n&&(n="float32");const r=new V$({batchInputShape:t,name:e.name,dtype:n,sparse:e.sparse}),s=r.inboundNodes[0].outputTensors;return s[0]}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function G$(e,t){if(null==e.dtype||e.dtype===t.dtype)return t;try{return Xo(t,e.dtype)}catch(l7){throw new $S(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${e.name}' (${e.dtype}).`)}}V$.className="InputLayer",qu(V$);class H${constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof H$)for(const t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(null==e)return;for(const t of e)this.add(t.key,t.value)}}add(e,t,n){if(null!=this.id2Value[e.id])throw new $S(`Duplicate key: name=${e.name}, id=${e.id}`);return this.id2Value[e.id]=G$(e,t),this.name2Id[e.name]=e.id,null!=n&&(this.id2Mask[e.id]=n),this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return null!=this.id2Value[e.id]}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof F$){if(null==this.id2Value[e.id])throw new $S(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}{const t=this.name2Id[e];if(null==t)throw new $S(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[t]}}getMask(e){if(e instanceof F$){if(null==this.id2Value[e.id])throw new $S(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}{const t=this.name2Id[e];if(null==t)throw new $S(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[t]}}disposeMasks(){null!=this.id2Mask&&lu(this.id2Mask)}}const j$=new RS,q$=new RS;function K$(e){null!=j$&&j$.setMaxEntries(e),null!=q$&&q$.setMaxEntries(e)}function X$(e,t,n,r){const s=null!=n&&n["training"],a=Array.isArray(e),i=a?e:[e],o=i.map((e=>e.name)),u=[],l=t.names();for(const f of o)-1!==l.indexOf(f)?u.push(t.getValue(f)):u.push(null);null!=r&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);const c=o.join(",")+"|"+t.names().sort().join(",");let h,p=j$.get(c);if(null==p){const e=Y$(i,t);p=e.sorted,h=e.recipientCounts,j$.put(c,p),q$.put(c,h)}h={},s||Object.assign(h,q$.get(c));const d=new H$(t);for(let f=0;f<p.length;++f){if(null!=r){const e=iu().numTensors;e>r.maxNumTensors&&(r.maxNumTensors=e),e<r.minNumTensors&&(r.minNumTensors=e)}const e=p[f],a=e.sourceLayer;if(a instanceof V$)continue;const i=[],l=[],c=[];let m=!1;for(const n of e.inputs){const e=d.getValue(n),r=d.getMask(n);i.push(e),l.push(r),null!=r&&(m=!0),s||(h[n.name]--,0!==h[n.name]||t.hasKey(n)||-1!==o.indexOf(n.name)||e.isDisposed||!0===n.sourceLayer.stateful||c.push(e))}m&&(n=n||{},n["mask"]=l[0]);const g=OS(a.apply(i,n));let y=null;a.supportsMasking&&(y=a.computeMask(i,l));const b=Q$(e),x=Array.isArray(b)?b:[b];for(let t=0;t<x.length;++t){d.hasKey(x[t])||d.add(x[t],g[t],Array.isArray(y)?y[0]:y);const e=o.indexOf(x[t].name);-1!==e&&(u[e]=g[t])}s||lu(c)}return d.disposeMasks(),a?u:u[0]}function Y$(e,t){we(null!=e&&e.length>0,(()=>"Expected at least one fetch, got none"));let n=[],r={};if(1===e.length){const s=Z$(e[0],t);n=s.sorted,r=s.recipientMap}else{const s=new Set;for(const a of e){const{sorted:e,recipientMap:i}=Z$(a,t);for(const t of e)s.has(t.name)||(n.push(t),s.add(t.name));for(const t in i)null==r[t]&&(r[t]=new Set),i[t].forEach((e=>r[t].add(e)))}}return{sorted:n,recipientCounts:J$(r)}}function J$(e){const t={};for(const n in e)t[n]=e[n].size;return t}function Z$(e,t){const n=new Set,r=[],s={};for(const o of t.names())n.add(o);const a=[],i=[];a.push(e);while(a.length>0){const e=a[a.length-1];if(n.has(e.name)){a.pop();continue}const t=i[i.length-1]===a.length-1;if(0===e.inputs.length||t)a.pop(),r.push(e),n.add(e.name),t&&i.pop();else{i.push(a.length-1);for(const t of e.inputs)null==s[t.name]&&(s[t.name]=new Set),s[t.name].add(e.name),n.has(t.name)||a.push(t)}}return{sorted:r,recipientMap:s}}function Q$(e){let t;if(1===e.sourceLayer.inboundNodes.length)t=e.sourceLayer.output;else{let n=null;for(let t=0;t<e.sourceLayer.inboundNodes.length;++t)for(const r of e.sourceLayer.inboundNodes[t].outputTensors)if(r.id===e.id){n=t;break}t=e.sourceLayer.getOutputAt(n)}return t}
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const eC=ht();
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function tC(e,t){return uu((()=>Ru(Kd(Cu(e,e),t,!0))))}eC.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",(()=>100),K$);class nC extends Hu{getConfig(){return{}}}class rC extends nC{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return uu((()=>{const t=tC(e,this.axis),n=Fp(t,0,this.maxValue);return Cu(e,Tu(n,ku(TT(),t)))}))}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}rC.className="MaxNorm",qu(rC);class sC extends nC{constructor(e){super(),this.defaultAxis=0,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return uu((()=>Tu(e,ku(TT(),tC(e,this.axis)))))}getConfig(){return{axis:this.axis}}}sC.className="UnitNorm",qu(sC);class aC extends nC{apply(e){return Sg(e)}}aC.className="NonNeg",qu(aC);class iC extends nC{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=e.minValue?e.minValue:this.defaultMinValue,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.rate=null!=e.rate?e.rate:this.defaultRate,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return uu((()=>{const t=tC(e,this.axis),n=ku(Cu(this.rate,Fp(t,this.minValue,this.maxValue)),Cu(1-this.rate,t));return Cu(e,Tu(n,ku(TT(),t)))}))}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}iC.className="MinMaxNorm",qu(iC);const oC={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function uC(e){return PS(e)}function lC(e,t={}){return WS(e,ju.getMap().classNameMap,t,"constraint")}function cC(e){if(null==e)return null;if("string"===typeof e){const t=e in oC?oC[e]:e,n={className:t,config:{}};return lC(n)}return e instanceof nC?e:lC(e)}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function hC(e){return new rC(e)}function pC(e){return new sC(e)}function dC(){return new aC}function fC(e){return new iC(e)}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function mC(){return new t$}function gC(){return new n$}function yC(e){return new r$(e)}function bC(e){return new s$(e)}function xC(e){return new a$(e)}function wC(e){return new i$(e)}function vC(e){return new o$(e)}function kC(e){return new l$(e)}function IC(e){return new c$(e)}function NC(e){return new h$(e)}function SC(e){return new p$(e)}function TC(e){return new d$(e)}function $C(e){return new f$(e)}function CC(e){return new m$(e)}function EC(e){return new g$(e)}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
async function RC(e){if(null==e)return;const t=[],n=[],r=[];for(const s in e){const a=e[s];if("number"!==typeof a){const e=a;t.push(e.data()),n.push(s),r.push(e)}}if(t.length>0){const s=await Promise.all(t);for(let t=0;t<s.length;++t)e[n[t]]=s[t][0];lu(r)}}function AC(e){if(null!=e)for(const t in e){const n=e[t];"number"!==typeof n&&n.dispose()}}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
var FC;(function(e){e[e["SILENT"]=0]="SILENT",e[e["VERBOSE"]=1]="VERBOSE"})(FC||(FC={}));const _C=125;class DC{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}}class OC{constructor(e,t=10){null==e&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(const t of this.callbacks)t.setParams(e)}setModel(e){for(const t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onEpochBegin(e,t)}async onEpochEnd(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onEpochEnd(e,t)}async onBatchBegin(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onBatchBegin(e,t)}async onBatchEnd(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onBatchEnd(e,t)}async onTrainBegin(e){null==e&&(e={});for(const t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){null==e&&(e={});for(const t of this.callbacks)await t.onTrainEnd(e)}}class MC extends DC{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){null==t&&(t={});const n=null==t["size"]?0:t["size"];this.seen+=n;for(const r in t){const e=t[r];if("number"===typeof e)this.totals.hasOwnProperty(r)||(this.totals[r]=0),this.totals[r]=this.totals[r]+e*n;else{let t;r in this.totals?t=this.totals[r]:this.totals[r]=0;const s=uu((()=>ku(this.totals[r],Cu(e,n))));this.totals[r]=s,null!=t&&t.dispose()}}}async onEpochEnd(e,t){if(null!=t)for(const n of this.params["metrics"])null!=this.totals[n]&&("number"===typeof this.totals[n]?t[n]=this.totals[n]/this.seen:uu((()=>{const e=Cu(Tu(1,this.seen),this.totals[n]);t[n]=e,this.totals[n].dispose(),cu(t[n])})))}}class LC extends DC{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){null==t&&(t={}),this.epoch.push(e);for(const n in t)null==this.history[n]&&(this.history[n]=[]),this.history[n].push(t[n])}async syncData(){const e=[],t=[],n=[];for(const s in this.history){const r=this.history[s];for(let a=0;a<r.length;++a)if("number"!==typeof r[a]){const i=r[a];e.push(i.data()),t.push(s),n.push(a)}}const r=await Promise.all(e);for(let s=0;s<r.length;++s){const e=this.history[t[s]][n[s]];e.dispose(),this.history[t[s]][n[s]]=r[s][0]}}}class zC extends DC{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||Rw,this.yieldEvery=t||"auto","auto"===this.yieldEvery&&(this.yieldEvery=_C),"never"===this.yieldEvery&&null!=e.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");He(this.yieldEvery)&&(this.maybeWait=YS(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,n){const r=[];null!=this.yield&&(await RC(n),r.push(this.yield(e,t,n))),r.push(this.nextFrameFunc()),await Promise.all(r)}async onEpochBegin(e,t){this.currentEpoch=e,null!=this.epochBegin&&(await RC(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){const n=[];null!=this.epochEnd&&(await RC(t),n.push(this.epochEnd(e,t))),"epoch"===this.yieldEvery&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(e,t){null!=this.batchBegin&&(await RC(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){const n=[];null!=this.batchEnd&&(await RC(t),n.push(this.batchEnd(e,t))),"batch"===this.yieldEvery?n.push(this.nextFrameFunc()):He(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(n)}async onTrainBegin(e){null!=this.trainBegin&&(await RC(e),await this.trainBegin(e))}async onTrainEnd(e){null!=this.trainEnd&&(await RC(e),await this.trainEnd(e))}}function PC(e,t){if(null==e&&(e={}),e instanceof DC)return[e];if(Array.isArray(e)&&e[0]instanceof DC)return e;const n=OS(e);return n.map((e=>new zC(e,t)))}class BC{constructor(){}static registerCallbackConstructor(e,t){we(e>=0&&Number.isInteger(e),(()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`)),BC.checkForDuplicate(t),null==BC.constructors[e]&&(BC.constructors[e]=[]),BC.constructors[e].push(t)}static checkForDuplicate(e){for(const t in BC.constructors){const n=BC.constructors[+t];n.forEach((t=>{if(t===e)throw new $S("Duplicate callback constructor.")}))}}static clear(){BC.constructors={}}static createCallbacks(e){const t=[];for(const n in BC.constructors){const r=+n;e>=r&&t.push(...BC.constructors[r])}return t.map((e=>new e))}}function WC(e,t,n,r,s,a,i,o,u){const l=new LC,c=[new MC,...BC.createCallbacks(t)];null!=e&&c.push(...e),c.push(l);const h=new OC(c);return h.setParams({epochs:n,initialEpoch:r,samples:s,steps:a,batchSize:i,verbose:t,doValidation:o,metrics:u}),{callbackList:h,history:l}}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function VC(e,t={},n=!1){return WS(e,ju.getMap().classNameMap,t,"layer",n)}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function UC(e,t){return uu((()=>{"float32"!==e.dtype&&(e=Xo(e,"float32"));const n=Kd(VT(e),t,!0),r=Ju(n.shape,TT()),s=Ru(cl(n,r));return Tu(e,s)}))}function GC(e,t){return uu((()=>hm(VT(nl(t,e)),-1)))}function HC(e,t){return uu((()=>hm(al(nl(t,e)),-1)))}function jC(e,t){return uu((()=>{const n=nl(e,t),r=Fp(al(e),TT(),Number.MAX_VALUE),s=al(Tu(n,r));return Cu(100,hm(s,-1))}))}function qC(e,t){return uu((()=>{const n=Fp(t,TT(),Number.MAX_VALUE),r=Of(ku(1,n)),s=Fp(e,TT(),Number.MAX_VALUE),a=Of(ku(1,s));return hm(VT(nl(r,a)),-1)}))}function KC(e,t){return uu((()=>{const n=cl(0,nl(1,Cu(e,t)));return hm(VT(n),-1)}))}function XC(e,t){return uu((()=>{const n=cl(0,nl(1,Cu(e,t)));return hm(n,-1)}))}function YC(e,t){return uu((()=>{const n=Kd(Cu(e,t),-1),r=Gd(Cu(nl(1,e),t),-1);return cl(0,ku(1,nl(r,n)))}))}function JC(e,t){return uu((()=>{const n=Math.log(2),r=nl(t,e),s=nl(ku(r,Pf(Cu(-2,r))),n);return hm(s,-1)}))}function ZC(e,t,n=!1){return uu((()=>{if(n)t=ly(t);else{const e=Kd(t,t.shape.length-1,!0);t=Tu(t,e)}return t=Fp(t,TT(),1-TT()),Zl(Kd(Cu(Xo(e,"float32"),Of(t)),t.shape.length-1))}))}function QC(e,t,n=!1){return uu((()=>{const r=Xo(pf(AT(e)),"int32");t=Fp(t,TT(),1-TT());const s=t.shape,a=Xh(Kl(r,s[s.length-1]),s);return ZC(a,t,n)}))}function eE(e,t){if(!Te(e.shape,t.shape))throw new $S(`logits and labels must have the same shape, but got shapes ${JSON.stringify(e.shape)} and ${JSON.stringify(t.shape)}`);return uu((()=>{const n=Sg(t),r=Zl(al(t));return ku(nl(n,Cu(t,e)),Lf(tf(r)))}))}function tE(e,t){return uu((()=>{let n;return n=Fp(t,TT(),1-TT()),n=Of(Tu(n,nl(1,n))),hm(eE(e,n),-1)}))}function nE(e,t){return uu((()=>{const n=Fp(e,TT(),1),r=Fp(t,TT(),1);return Kd(Cu(e,Of(Tu(n,r))),-1)}))}function rE(e,t){return uu((()=>{const n=Of(ku(TT(),t));return hm(nl(t,Cu(e,n)),-1)}))}function sE(e,t){return uu((()=>{const n=UC(e,-1),r=UC(t,-1),s=Cu(n,r);return Zl(Kd(s,-1))}))}BC.constructors={};const aE={meanSquaredError:GC,meanAbsoluteError:HC,meanAbsolutePercentageError:jC,meanSquaredLogarithmicError:qC,squaredHinge:KC,hinge:XC,categoricalHinge:YC,logcosh:JC,categoricalCrossentropy:ZC,sparseCategoricalCrossentropy:QC,binaryCrossentropy:tE,kullbackLeiblerDivergence:nE,poisson:rE,cosineProximity:sE};function iE(e){if("string"===typeof e){if(e in aE)return aE[e];let t=`Unknown loss ${e}`;throw e.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${e}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new $S(t)}return e}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function oE(e,t){return uu((()=>{const n=Cu(.5,Rm(t)),r=CT(gf(t,n),e.dtype);return hm(wd(e,r),-1)}))}function uE(e,t){return uu((()=>CT(wd(gh(e,-1),gh(t,-1)),"float32")))}function lE(e,t){return uu((()=>Xo(Kd(qf(wd(e,1),wd(t,1))),"float32")))}function cE(e,t){return uu((()=>Xo(Kd(qf(wd(e,1),wd(t,0))),"float32")))}function hE(e,t){return uu((()=>Xo(Kd(qf(wd(e,0),wd(t,1))),"float32")))}function pE(e,t){return uu((()=>{const n=lE(e,t),r=hE(e,t),s=ku(n,r);return Xo(kd(gf(s,0),Tu(n,s),0),"float32")}))}function dE(e,t){return uu((()=>{const n=lE(e,t),r=cE(e,t),s=ku(n,r);return Xo(kd(gf(s,0),Tu(n,s),0),"float32")}))}function fE(e,t){return tE(e,t)}function mE(e,t){return e.rank===t.rank&&(e=Iy(e,[e.rank-1])),t=gh(t,-1),t.dtype!==e.dtype&&(t=Xo(t,e.dtype)),Xo(wd(e,t),"float32")}const gE=GC,yE=GC,bE=HC,xE=HC,wE=jC,vE=jC,kE=ZC,IE=sE,NE=QC,SE={binaryAccuracy:oE,categoricalAccuracy:uE,precision:pE,categoricalCrossentropy:kE,sparseCategoricalCrossentropy:NE,mse:gE,MSE:yE,mae:bE,MAE:xE,mape:wE,MAPE:vE,cosine:IE};function TE(e){if("string"===typeof e&&e in SE)return SE[e];if("string"!==typeof e&&null!=e)return e;throw new $S(`Unknown metric ${e}`)}function $E(e){if(FS(null!==e,`Unknown LossOrMetricFn ${e}`),"string"===typeof e)return e;{let t;for(const n of Object.keys(aE))if(aE[n]===e){t=n;break}if(void 0!==t)return t;for(const n of Object.keys(SE))if(SE[n]===e){t=n;break}return void 0!==t?t:e.name}}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function CE(e){const t={Adagrad:()=>Cw.adagrad(.01),Adadelta:()=>Cw.adadelta(1,.95,TT()),Adam:()=>Cw.adam(.001,.9,.999,TT()),Adamax:()=>Cw.adamax(.002,.9,.999,TT(),0),RMSProp:()=>Cw.rmsprop(.001,.9,0,TT()),SGD:()=>Cw.sgd(.01)};if(t["adagrad"]=t["Adagrad"],t["adadelta"]=t["Adadelta"],t["adam"]=t["Adam"],t["adamax"]=t["Adamax"],t["rmsprop"]=t["RMSProp"],t["sgd"]=t["SGD"],e in t)return t[e]();throw new $S(`Unknown Optimizer ${e}`)}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
const EE=1048576;function RE(e,t,n=!1){if(null==e||"object"!==typeof e||Object.getPrototypeOf(e)!==Object.prototype||!AE(e))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){const n=JSON.stringify(e);n.length>EE&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${n.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${EE}.`)}}function AE(e){if(null===e)return!0;if("object"===typeof e){if(Object.getPrototypeOf(e)===Object.prototype){const t=Object.keys(e);for(const n of t){if("string"!==typeof n)return!1;if(!AE(e[n]))return!1}return!0}if(Array.isArray(e)){for(const t of e)if(!AE(t))return!1;return!0}return!1}{const t=typeof e;return"string"===t||"number"===t||"boolean"===t}}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function FE(e,t,n,r=console.log){const s=DE(e),a=["Layer (type)","Input Shape","Output shape","Param #"];let i;if(s?(t=t||90,n=n||[.32,.61,.89,1]):(t=t||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map((e=>Math.floor(t*e)))),!s){a.push("Receives inputs"),i=[];for(const t in e.nodesByDepth)i.push(...e.nodesByDepth[t])}r("_".repeat(t)),OE(a,n,r),r("=".repeat(t));const o=e.layers;for(let c=0;c<o.length;++c)s?ME(o[c],n,r):LE(o[c],n,i,r),r((c===o.length-1?"=":"_").repeat(t));e.checkTrainableWeightsConsistency();const u=_E(e),l=S$(e.nonTrainableWeights);r(`Total params: ${u+l}`),r(`Trainable params: ${u}`),r(`Non-trainable params: ${l}`),r("_".repeat(t))}function _E(e){let t;return t=null!=e.collectedTrainableWeights?S$(e.collectedTrainableWeights):S$(e.trainableWeights),t}function DE(e){let t=!0;const n=[],r=[];for(const s in e.nodesByDepth)n.push(e.nodesByDepth[s]);for(const s of n){if(s.length>1||1===s.length&&s[0].inboundLayers.length>1){t=!1;break}r.push(...s)}if(t)for(const s of e.layers){let e=!1;for(const n of s.inboundNodes)if(-1!==r.indexOf(n)){if(e){t=!1;break}e=!0}if(!t)break}return t}function OE(e,t,n=console.log){let r="";for(let s=0;s<e.length;++s)s>0&&(r=r.slice(0,r.length-1)+" "),r+=e[s],r=r.slice(0,t[s]),r+=" ".repeat(t[s]-r.length);n(r)}function ME(e,t,n){let r,s;try{s=e.inboundNodes.map((e=>JSON.stringify(e.inputShapes))).join(",")}catch(l7){s="multiple"}try{r=JSON.stringify(e.outputShape)}catch(l7){r="multiple"}const a=e.name,i=e.getClassName(),o=[`${a} (${i})`,s,r,e.countParams().toString()];OE(o,t,n)}function LE(e,t,n,r){let s,a;try{a=e.inboundNodes.map((e=>JSON.stringify(e.inputShapes))).join(",")}catch(l7){a="multiple"}try{s=JSON.stringify(e.outputShape)}catch(l7){s="multiple"}const i=[];for(const h of e.inboundNodes)if(!(null!=n&&n.length>0&&-1===n.indexOf(h)))for(let e=0;e<h.inboundLayers.length;++e){const t=h.inboundLayers[e].name,n=h.nodeIndices[e],r=h.tensorIndices[e];i.push(`${t}[${n}][${r}]`)}const o=e.name,u=e.getClassName(),l=0===i.length?"":i[0],c=[`${o} (${u})`,a,s,e.countParams().toString(),l];OE(c,t,r);for(let h=1;h<i.length;++h)OE(["","","","",i[h]],t,r)}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function zE(e,t,n){return("inboundNodes"===e||"outputLayers"===e||"inputLayers"===e)&&0===t&&"string"===typeof n}function PE(e,t){if(null===e)return null;if("string"===typeof e)return LS(e);if("number"===typeof e||"boolean"===typeof e)return e;if(e instanceof Array){const n=[],r=e.length;for(let s=0;s<r;++s){const r=e[s];zE(t,s,r)?n.push(r):n.push(PE(r,t))}return n}{const t={};for(const n of Object.keys(e)){const r=e[n];if("name"===n&&"string"===typeof r)t[n]=r;else{const e=LS(n);t[e]=PE(r,e)}}return t}}function BE(e,t){if(null===e||void 0===e)return null;if("string"===typeof e)return MS(e);if("number"===typeof e||"boolean"===typeof e)return e;if(e instanceof Array){const n=[],r=e.length;for(let s=0;s<r;++s){const r=e[s];zE(t,s,r)?n.push(r):n.push(BE(r,t))}return n}{const t={};for(const n of Object.keys(e)){const r=e[n],s=MS(n);t[s]="name"!==n&&"className"!==n||"string"!==typeof r?BE(r,n):r}return t}}
/** @license See the LICENSE file. */
const WE="4.11.0",VE=e=>{const t=Object.keys(e);if(0===t.length)return!1;const n=t[0].split("/");return!isNaN(parseInt(n[n.length-1],10))};class UE extends M${constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,null==this.name){const e=this.getClassName().toLowerCase();this.name=tT(e)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],GS(this.inputs).length!==this.inputs.length)throw new $S(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map((e=>e.name))}`);GS(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map((e=>e.name))}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const y of this.outputs){const e=y.sourceLayer,t=y.nodeIndex,n=y.tensorIndex;this.outputLayers.push(e),this.outputLayersNodeIndices.push(t),this.outputLayersTensorIndices.push(n)}for(const y of this.inputs){const e=y.sourceLayer,t=y.nodeIndex,n=y.tensorIndex;FS(0===t,"input layer has >1 nodes"),FS(0===n,"input layer has >1 tensors"),this.inputLayers.push(e),this.inputLayersNodeIndices.push(t),this.inputLayersTensorIndices.push(n)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let y=0;y<this.inputLayers.length;y++){const t=this.inputLayers[y];if(!(t instanceof V$))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${y} (0-based) originates from layer type ${t.getClassName()}.`);this.inputNames.push(t.name),this.feedInputShapes.push(t.batchInputShape),this.feedInputNames.push(t.name)}for(const y of this.outputLayers)this.outputNames.push(y.name);this.internalInputShapes=this.inputs.map((e=>e.shape)),this.internalOutputShapes=this.outputs.map((e=>e.shape));const t={},n={},r={},s={},a={},i=[],o=(e,t,n,r,s,u)=>{null!=r&&null!=s&&null!=u||(r=e.sourceLayer,s=e.nodeIndex,u=e.tensorIndex);const l=r.inboundNodes[s];if(-1!==n.indexOf(l))throw new TS(`The tensor ${e.name} at layer "${r.name}" is part of a cycle.`);if(-1!==t.indexOf(l))return;this.containerNodes.add(UE.nodeKey(r,s)),r.id in a||(a[r.id]=Object.keys(a).length),-1===n.indexOf(l)&&n.push(l);const c=l.inboundLayers.length;for(let a=0;a<c;a++){const e=l.inputTensors[a],r=l.inboundLayers[a],s=l.nodeIndices[a],i=l.tensorIndices[a];o(e,t,n,r,s,i)}t.push(l);while(n.indexOf(l)>=0)n.splice(n.indexOf(l),1);i.push(l)},u=[],l=[];for(const y of this.outputs)o(y,u,l);const c=i.slice().reverse();for(const y of c){n[y.id]=y,y.id in t||(t[y.id]=0);let e=t[y.id];const a=null==r[y.outboundLayer.id]?0:r[y.outboundLayer.id];e=Math.max(e,a),r[y.outboundLayer.id]=e,s[y.outboundLayer.id]=y.outboundLayer,t[y.id]=e;for(let r=0;r<y.inboundLayers.length;r++){const s=y.inboundLayers[r],a=y.nodeIndices[r],i=s.inboundNodes[a],o=null==t[i.id]?0:t[i.id];t[i.id]=Math.max(e+1,o),n[i.id]=i}}const h={};for(const y in t){const e=t[y];e in h||(h[e]=[]),h[e].push(n[y])}const p={};for(const y in r){const e=r[y];e in p||(p[e]=[]),p[e].push(s[y])}let d=Object.keys(p).map((e=>parseInt(e,10))).sort(US);this.layers=[];for(const y of d){const e=p[y];e.sort(((e,t)=>{const n=a[e.id],r=a[t.id];return n<r?-1:n>r?1:0}));for(const t of e)t instanceof UE&&this.internalContainerRefs.push(t),this.layers.push(t)}this.layersByDepth=p,d=Object.keys(h).map((e=>parseInt(e,10))).sort(US);const f=this.inputs.slice(),m=[];for(const y of d)for(const e of h[y]){const t=e.outboundLayer;if(null!=t){for(const n of e.inputTensors)if(-1===f.indexOf(n))throw new TS(`Graph disconnected: cannot obtain value for tensor ${n} at layer "${t.name}". The following previous layers were accessed without issue: ${m}`);for(const t of e.outputTensors)f.push(t);m.push(t.name)}}this.nodesByDepth=h;const g=this.layers.map((e=>e.name));for(const y of g){const e=g.filter((e=>e===y)).length;if(1!==e)throw new TS(`The name "${y}" is used ${e} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(g))}this.outboundNodes=[],this.inboundNodes=[],new D$({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map((e=>null)),outputMasks:this.outputs.map((e=>null)),inputShapes:this.inputs.map((e=>e.shape)),outputShapes:this.outputs.map((e=>e.shape))}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const e={refCountAfterDispose:null,numDisposedVariables:0};if(0===--this._refCount){for(const t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(const t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach((t=>{t._trainableWeights.forEach((t=>t.trainable=e))})),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new $S("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(const t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const e of this.layers)t.push(...e.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e,t=!0){const n={};let r=0;const s=VE(e);s&&this.parseWeights(e);for(const i of this.layers)for(const[e,t]of i.weights.entries()){const a=s?`${t.name.split("/").slice(0,-1).join("/")+"/"}${e}`:t.originalName;if(null!=n[a])throw new $S(`Duplicate weight name: ${a}`);n[a]=t,r++}const a=[];for(const i in e){let r=i;if(null==n[i]){const e=i.split("/"),t=e.slice(0,-2).concat([e[e.length-1]]);r=t.join("/")}if(null!=n[r])a.push([n[r],e[i]]);else if(t)throw new $S(`Provided weight data has no target variable: ${i}`);delete n[r]}if(t){const e=[];for(const t in n)e.push(t);if(e.length>0)throw new $S(`${e.length} of ${r} weights are not set: ${e}`)}R$(a)}parseWeights(e){for(const t in Object.keys(e)){const n=t.split("/"),r=["vars","layer_checkpoint_dependencies"],s=n.map((e=>e.startsWith("_")?e.slice(1):e)).filter((e=>!r.includes(e))).join("/");s!==t&&(e[s]=e[t],delete e[t])}}updatedConfig(){const e=this.getConfig(),t={};return t["className"]=this.getClassName(),t["config"]=e,t["kerasVersion"]=`tfjs-layers ${WE}`,t["backend"]="TensorFlow.js",t}toJSON(e,t=!0){const n=BE(this.updatedConfig());return t?JSON.stringify(n):n}call(e,t){return uu((()=>{e=OS(e);const n=new H$;for(let t=0;t<this.inputs.length;++t)n.add(this.inputs[t],e[t]);return X$(this.outputs,n,t)}))}computeMask(e,t){return uu((()=>{let n;return e=OS(e),n=null==t?AS(null,e.length):OS(t),this.runInternalGraph(e,n)[1]}))}computeOutputShape(e){const t=k$(e);if(t.length!==this.inputLayers.length)throw new $S(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);const n={};for(let i=0;i<t.length;i++){const e=this.inputLayers[i],r=t[i],s=e.name+"_0_0";n[s]=r}const r=Object.keys(this.nodesByDepth).map((e=>parseInt(e,10))).sort(US);if(r.length>1)for(const i of r){const e=this.nodesByDepth[i];for(const t of e){const e=t.outboundLayer;if(-1!==this.inputLayers.map((e=>e.id)).indexOf(e.id))continue;const r=[];for(let o=0;o<t.inboundLayers.length;o++){const e=t.inboundLayers[o],s=t.nodeIndices[o],a=t.tensorIndices[o],i=`${e.name}_${s}_${a}`,u=n[i];r.push(u)}const s=e.computeOutputShape(DS(r)),a=k$(s),i=e.inboundNodes.indexOf(t);for(let t=0;t<a.length;t++){const r=`${e.name}_${i}_${t}`;n[r]=a[t]}}}const s=[],a=[];for(let i=0;i<this.outputLayers.length;i++){const e=this.outputLayers[i],t=this.outputLayersNodeIndices[i],n=this.outputLayersTensorIndices[i],r=`${e.name}_${t}_${n}`;a.push(r)}for(let i=0;i<a.length;i++){const e=a[i];FS(e in n),s.push(n[e])}return DS(s)}runInternalGraph(e,t){null==t&&(t=AS(null,e.length));const n={};for(let o=0;o<this.inputs.length;++o){const r=this.inputs[o],s=e[o],a=t[o];n[r.id]=[s,a]}const r=Object.keys(this.nodesByDepth).map((e=>parseInt(e,10))).sort(US);for(const o of r){const e=this.nodesByDepth[o];for(const t of e){const e=t.outboundLayer,r=t.inputTensors,s=t.outputTensors,a=new Array;for(const t of r)t.id in n&&a.push(n[t.id]);if(a.length===r.length){let r,i,o,u,l={};if(null!=t.callArgs&&(l=t.callArgs),1===a.length){const[t,n]=a[0];null==l["mask"]&&(l["mask"]=n),o=OS(e.call(t,l)),u=OS(e.computeMask(t,n)),r=[t],i=[n]}else r=a.map((e=>e[0])),i=a.map((e=>e[1])),null==l["mask"]&&(l["mask"]=i),o=OS(e.call(r,l)),u=OS(e.computeMask(r,i));if(e.activityRegularizer)throw new CS("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let e=0;e<s.length;++e){const t=s[e],r=o[e],a=u[e];n[t.id]=[r,a]}}}}const s=[],a=[],i=[];for(const o of this.outputs){FS(o.id in n,`Could not compute output ${o.name} : ${o.id}`);const[e,t]=n[o.id];i.push(e.shape),s.push(e),a.push(t)}return[s,a,i]}buildNodeConversionMap(e){const t={};let n;for(const r of this.layers){n=r instanceof UE?1:0;for(let e=0;e<r.inboundNodes.length;e++){const s=UE.nodeKey(r,e);this.containerNodes.has(s)&&(t[s]=n,n+=1)}}return t}getLayer(e,t){if(null!=t)return this.findLayer(t);if(null==e)throw new $S("Provide either a layer name or layer index");if("number"===typeof e)return this.findLayer(e);for(const n of this.layers)if(n.name===e)return n;throw new $S(`No such layer: ${e}`)}findLayer(e){if(this.layers.length<=e)throw new $S(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}calculateLosses(){return uu((()=>{const e=[];for(const t of this.layers)for(let n=0;n<t.inboundNodes.length;++n){const r=UE.nodeKey(t,n);this.containerNodes.has(r)&&e.push(...t.calculateLosses())}return e}))}getConfig(){const e={name:this.name},t=this.buildNodeConversionMap(this.layers),n=[];for(const a of this.layers){const e=a.getClassName(),r=a.getConfig(),s=[];for(let n=0;n<a.inboundNodes.length;n++){const e=a.inboundNodes[n],r=UE.nodeKey(a,n);let i={};if(this.containerNodes.has(r)){if(e.callArgs)try{JSON.stringify(e.callArgs),i=e.callArgs}catch(l7){console.warn(`Layer ${a.name} was passed non-serializable keyword arguments: ${e.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),i={}}if(e.inboundLayers.length>0){const n=[];for(let r=0;r<e.inboundLayers.length;r++){const s=e.inboundLayers[r],a=e.nodeIndices[r],o=e.tensorIndices[r],u=UE.nodeKey(s,a);let l=t[u];null==l&&(l=0),n.push([s.name,l,o,i])}s.push(n)}}}const i={};i["name"]=a.name,i["className"]=e,i["config"]=r,i["inboundNodes"]=s,n.push(i)}e["layers"]=n;const r=[];for(let a=0;a<this.inputLayers.length;a++){const e=this.inputLayers[a],n=this.inputLayersNodeIndices[a],s=UE.nodeKey(e,n);if(!this.containerNodes.has(s))continue;let i=t[s];null!==i&&void 0!==i||(i=0);const o=this.inputLayersTensorIndices[a];r.push([e.name,i,o])}e["inputLayers"]=r;const s=[];for(let a=0;a<this.outputLayers.length;a++){const e=this.outputLayers[a],n=this.outputLayersNodeIndices[a],r=UE.nodeKey(e,n);if(!this.containerNodes.has(r))continue;let i=t[r];null!==i&&void 0!==i||(i=0);const o=this.outputLayersTensorIndices[a];s.push([e.name,i,o])}return e["outputLayers"]=s,e}static fromConfig(e,t,n={},r=!1){const s={},a={};function i(e,t){e.name in a?a[e.name].push(t):a[e.name]=[t]}function o(e,t){const n=[];let r;for(const a of t){const o=a[0],u=a[1],l=a[2];if(r=null==a[3]?{}:a[3],!(o in s))return void i(e,t);const c=s[o];if(c.inboundNodes.length<=u)return void i(e,t);const h=c.inboundNodes[u];n.push(h.outputTensors[l])}n.length>0&&e.apply(DS(n),r)}function u(e){const n=e["name"],a=VC(e,null!=t["customObjects"]?t["customObjects"]:{});a.setFastWeightInitDuringBuild(r),s[n]=a;const o=e["inboundNodes"];o.forEach((e=>{if(!(e instanceof Array))throw new $S(`Corrupted configuration, expected array for nodeData: ${e}`);i(a,e)}))}const l=t["name"],c=t["layers"];for(const m of c)u(m);while(!HS(a))for(const e of c){const t=s[e["name"]];if(t.name in a){const e=a[t.name];delete a[t.name];for(const n of e)o(t,n)}}const h=[],p=[],d=t["inputLayers"];for(const m of d){const e=m[0],t=m[1],n=m[2];FS(e in s);const r=s[e],a=r.inboundNodes[t].outputTensors;h.push(a[n])}const f=t["outputLayers"];for(const m of f){const e=m[0],t=m[1],n=m[2];FS(e in s);const r=s[e],a=r.inboundNodes[t].outputTensors;p.push(a[n])}return new e({inputs:h,outputs:p,name:l})}get stateful(){if(this._stateful)throw new $S("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const e of this.layers)if(e.stateful)return!0;return!1}resetStates(){uu((()=>{this.layers.forEach((e=>{e.stateful&&e.resetStates()}))}))}}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function GE(e,t,n){const r=t.length;if(null==e||Array.isArray(e)&&0===e.length)return t.map((e=>null));if(1===r)return Array.isArray(e)&&1===e.length?e:"object"===typeof e&&t[0]in e?[e[t[0]]]:[e];if(Array.isArray(e)){if(e.length!==r)throw new Error(`Provided ${n} is an array of ${e.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return e}if("object"===typeof e&&Object.keys(e).length>0&&"object"===typeof e[Object.keys(e)[0]]){const n=[];return t.forEach((t=>{t in e?n.push(e[t]):n.push(null)})),n}throw new Error(`The model has multiple (${r}) outputs, so ${n} must be either an array with ${r} elements or an object with ${t} keys. Provided ${n} not understood: ${JSON.stringify(e)}`)}function HE(e,t){return GE(e,t,"classWeight")}async function jE(e,t,n,r){if(null!=t||null!=r)throw new Error("Support sampleWeight is not implemented yet");if(null!=n){const t=uu((()=>{if(1===e.shape.length)return Jo(e);if(2===e.shape.length){if(e.shape[1]>1){const t=1;return gh(e,t)}if(1===e.shape[1])return Xh(e,[e.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${e.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}throw new Error(`Unexpected rank of target (y) tensor (${e.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)})),r=Array.from(await t.data());lu(t);const s=[];return r.forEach((e=>{if(null==n[e])throw new Error(`classWeight must contain all classes in the training data. The class ${e} exists in the data but not in classWeight`);s.push(n[e])})),Fy(s,"float32")}return null}function qE(e,t){return Cu(e,t)}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
const KE=32;function XE(e,t){let n,r;const s=t;n=s["xs"],r=s["ys"],we(null!=n&&null!=r,(()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`));const a=YE("input",e.inputNames,n),i=YE("output",e.outputNames,r),o=a[0].shape[0];we(a.length===e.inputs.length,(()=>`LayersModel has ${e.inputs.length} inputs, but the dataset provides ${a.length} inputs.  (Expected input keys: ${JSON.stringify(e.inputNames)})`)),we(i.length===e.outputs.length,(()=>`LayersModel has ${e.outputs.length} outputs, but the dataset provides ${i.length} outputs.  (Expected output keys: ${JSON.stringify(e.outputNames)})`));for(let u=0;u<a.length;u++)we(a[u].shape[0]===o,(()=>`Batch size mismatch: input ${e.inputNames[u]} has ${a[u].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`));for(let u=0;u<i.length;u++)we(i[u].shape[0]===o,(()=>`Batch size mismatch: output ${e.outputNames[u]} has ${i[u].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`));return{xs:a,ys:i}}function YE(e,t,n){if(n instanceof ja)return[n];if(Array.isArray(n))return we(n.length===t.length,(()=>`Received an array of ${n.length} Tensors, but expected ${t.length} to match the ${e} keys ${t}.`)),n;{const r=[];for(const s of t){if(null==n[s])throw new $S(`The feature data generated by the dataset lacks the required ${e} key '${s}'.`);r.push(n[s])}return r}}function JE(e){if(3===e.length)throw new CS("Validation with sample weights is not implemented yet.");return{xs:e[0],ys:e[1]}}async function ZE(e,t,n){const r=null!=n.batchesPerEpoch;if(we(null!=e.optimizer,(()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig).")),we(null!=n,(()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call.")),we(null!=n.epochs&&n.epochs>0&&Number.isInteger(n.epochs),(()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`)),we(!r||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),(()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`)),we(null==n["validationSplit"],(()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead.")),e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0;try{const s=null!=n.validationData;let a,i;if(s)if(eR(n.validationData))we(null==n.validationBatches||n.validationBatches>0&&Number.isInteger(n.validationBatches),(()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`));else{const e=JE(n.validationData);a=e.xs,i=e.ys}const o=e.makeTrainFunction(),u=e.getDedupedMetricsNames();let l;l=s?u.slice().concat(u.map((e=>"val_"+e))):u.slice();const c=PC(n.callbacks,n.yieldEvery),h=null==n.verbose?1:n.verbose,{callbackList:p,history:d}=WC(c,h,n.epochs,null,null,QE(t,n),null,s,l);p.setModel(e),e.history=d,await p.onTrainBegin(),e.stopTraining_=!1;let f=null==n.initialEpoch?0:n.initialEpoch,m=await t.iterator();while(f<n.epochs){const l={};await p.onEpochBegin(f);let c=0,h=0;r||(m=await t.iterator());while(!r||c<n.batchesPerEpoch){const t=await m.next();if(r&&t.done){console.warn(`You provided \`batchesPerEpoch\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${c} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, `+n.batchesPerEpoch*n.epochs+" batches). You may need to use the repeat() function when building your dataset.");break}if(null!=t.value){const{xs:r,ys:s}=XE(e,t.value),a={};a["batch"]=h,a["size"]=r[0].shape[0],await p.onBatchBegin(h,a);const i=[];if(null!=n.classWeight){const t=HE(n.classWeight,e.outputNames);for(let e=0;e<t.length;++e)i.push(await jE(s[e],null,t[e]))}const l=r.concat(s).concat(i),d=o(l);lu(l);for(let e=0;e<u.length;++e){const t=u[e],n=d[e];a[t]=n,cu(n)}await p.onBatchEnd(h,a),AC(a),h++,c++}if(r?c>=n.batchesPerEpoch:t.done){if(s){let t;t=eR(n.validationData)?OS(await e.evaluateDataset(n.validationData,{batches:n.validationBatches})):OS(e.evaluate(a,i,{batchSize:null==n.validationBatchSize?KE:n.validationBatchSize,verbose:0}));for(let n=0;n<e.metricsNames.length;++n)l[`val_${e.metricsNames[n]}`]=t[n]}break}if(e.stopTraining_)break}if(await p.onEpochEnd(f,l),f++,e.stopTraining_)break}return await p.onTrainEnd(),await e.history.syncData(),e.history}finally{e.isTraining=!1}}function QE(e,t){let n=null;return null!=t.batchesPerEpoch?n=t.batchesPerEpoch:Number.isFinite(e.size)&&(n=e.size),n}function eR(e){return"function"===typeof e.iterator}function tR(e){return"function"===typeof e.next}async function nR(e,t,n){n=n||{};const r=null!=n.batches,s=e.testFunction;let a=[];if(n.verbose>0)throw new CS("Verbose mode is not implemented yet.");we(!r||n.batches>0&&Number.isInteger(n.batches),(()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`));const i=tR(t)?t:await t.iterator();let o=0,u=0;while(!r||u<n.batches){const t=await i.next();if(a=uu((()=>{if(t.value){const{xs:n,ys:r}=XE(e,t.value),i=n.concat(r),l=uu((()=>s(i)));if(lu(i),0===u)for(let e=0;e<l.length;++e)a.push(Vu(0));const c=i[0].shape[0];for(let e=0;e<l.length;++e){const t=l[e],n=a[e];a[e]=uu((()=>ku(a[e],Cu(c,t)))),u>0&&lu(n)}lu(l),o+=c,++u}return a})),t.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let l=0;l<a.length;++l){const e=a[l];a[l]=Tu(a[l],o),lu(e)}return DS(a)}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function rR(e){we(e>0&&Number.isInteger(e),(()=>`batchSize is required to be a positive integer, but got ${e}`))}function sR(e,t,n){return null==e?[null]:Array.isArray(e)?e.map((e=>_T(e,t,n-t))):_T(e,t,n-t)}function aR(e,t){return uu((()=>null==e?null:Array.isArray(e)?e.map((e=>aR(e,t))):WT(e,"int32"===t.dtype?t:Xo(t,"int32"))))}function iR(e,t){const n=[];let r=0,s=null;while(r<e)s=r+t,s>=e&&(s=e),n.push([r,s]),r=s;return n}function oR(e){const t=[];e instanceof ja&&(e=[e]);for(let n=0;n<e.length;++n){const r=e[n];if(1===r.rank)t.push(ET(r,1));else{if(0===r.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(r)}}return t}function uR(e,t){if(null==e)return;const n=[];if(t instanceof ja)n.push(t.id);else if(Array.isArray(t))t.forEach((e=>n.push(e.id)));else if(null!=t)for(const s in t){const e=t[s];n.push(e.id)}const r=[];if(e instanceof ja)-1===n.indexOf(e.id)&&r.push(e);else if(Array.isArray(e))e.forEach((e=>{-1===n.indexOf(e.id)&&r.push(e)}));else if(null!=e)for(const s in e){const t=e[s];-1===n.indexOf(t.id)&&r.push(t)}r.forEach((e=>{e.isDisposed||e.dispose()}))}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function lR(e){return e instanceof ja}function cR(e){return Array.isArray(e)}function hR(e){return!lR(e)&&!cR(e)}function pR(e,t,n,r=!0,s=""){if(null==t||0===t.length){if(null!=e){let t=!1;if(cR(e)&&e.length>0)t=!0;else if(hR(e)){for(const n in e)if(e.hasOwnProperty(n)){t=!0;break}}else t=!0;if(t)throw new $S(`Error when checking model ${s} expected no data, but got ${e}`)}return[]}if(null==e)return t.map((e=>null));let a;if(hR(e)){a=[];for(const n of t){if(null==e[n])throw new $S(`No data provided for "${n}". Need data for each key in: ${t}`);a.push(e[n])}}else if(cR(e)){if(e.length!==t.length)throw new $S(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${e}`);a=e}else{if(t.length>1)throw new $S(`The model ${s} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${e.shape}`);a=[e]}if(a=oR(a),null!=n)for(let i=0;i<t.length;++i){if(null==n[i])continue;const e=a[i];if(e.shape.length!==n[i].length)throw new $S(`Error when checking ${s}: expected ${t[i]} to have ${n[i].length} dimension(s). but got array with shape ${e.shape}`);for(let t=0;t<n[i].length;++t){if(0===t&&!r)continue;const a=e.shape[t],o=n[i][t];if(null!=o&&o>=0&&a!==o)throw new $S(`${s} expected a batch of elements where each example has shape [${n[i].slice(1,n[i].length)}] (i.e.,tensor shape [*,${n[i].slice(1,n[i].length)}]) but the ${s} received an input with ${e.shape[0]} examples, each with shape [${e.shape.slice(1,e.shape.length)}] (tensor shape [${e.shape}])`)}}return a}function dR(e,t,n){const r=GS(e.map((e=>e.shape[0])));r.sort();const s=GS(t.map((e=>e.shape[0])));if(s.sort(),r.length>1)throw new $S(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map((e=>e.shape)))}`);if(s.length>1)throw new $S(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map((e=>e.shape)))}`);if(r.length>0&&s.length>0&&!Te(r,s))throw new $S(`Input Tensors should have the same number of samples as target Tensors. Found ${r[0]} input sample(s) and ${s[0]} target sample(s).`)}function fR(e,t,n){const r=[GC,tE,ZC];for(let s=0;s<e.length;++s){const a=e[s],i=t[s],o=n[s];if(null!=i){if(i===ZC&&1===a.shape[a.shape.length-1])throw new $S(`You are passing a target array of shape ${a.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(-1!==r.indexOf(i)){const e=a.shape.slice(1),t=o.slice(1);for(let n=0;n<e.length;++n){const r=e[n],s=t[n];if(null!=s&&r!==s)throw new $S(`A target Tensor with shape ${a.shape} was passed for an output of shape ${o}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function mR(e,t,n,r=!0,s=""){let a;if(Array.isArray(e)){if(e.length!==t.length)throw new $S(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${e.length} Tensors(s).`);a=e}else{if(t.length>1)throw new $S(`The model expects ${t.length} ${s} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(e.shape)}.`);a=[e]}if(null!=n)for(let i=0;i<t.length;++i){if(null==n[i])continue;const e=a[i];if(e.shape.length!==n[i].length)throw new $S(`Error when checking ${s}: expected ${t[i]} to have ${n[i].length} dimension(s), but got array with shape ${JSON.stringify(e.shape)}`);for(let a=0;a<n[i].length;++a){if(0===a&&!r)continue;const o=e.shape[a],u=n[i][a];if(null!=u&&u!==o)throw new $S(`Error when checking ${s}: expected ${t[i]} to have shape ${JSON.stringify(n[i])} but got array with shape ${JSON.stringify(e.shape)}.`)}}}function gR(e,t){if(null==e||Array.isArray(e)&&0===e.length)return t.map((e=>[]));let n;if("string"===typeof e||"function"===typeof e)n=[e];else{if(!Array.isArray(e)&&"object"!==typeof e)throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${e}`);n=e}if(Array.isArray(n))return t.map((e=>n));{const e=[];for(const r of t){let t=n.hasOwnProperty(r)?n[r]:[];Array.isArray(t)||(t=[t]),e.push(t)}return e}}const yR="layers-model";class bR extends UE{constructor(e){super(e),this.isTraining=!1}summary(e,t,n=console.log){if(!this.built)throw new $S("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");FE(this,e,t,n)}compile(e){if(null==e.loss&&(e.loss=[]),this.loss=e.loss,"string"===typeof e.optimizer)this.optimizer_=CE(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof Xu))throw new $S("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(Array.isArray(e.loss)||"string"===typeof e.loss||"function"===typeof e.loss)if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new $S(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);const n=e.loss;t=n.map((e=>iE(e)))}else{const n=iE(e.loss);this.outputs.forEach((e=>{t.push(n)}))}else{e.loss=e.loss;for(const t in e.loss)if(-1===this.outputNames.indexOf(t))throw new $S(`Unknown entry in loss dictionary: "${t}". Only expected the following keys: ${this.outputNames}`);for(const n of this.outputNames)null==e.loss[n]&&console.warn(`Output "${n}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${n} during training`),t.push(iE(e.loss[n]))}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let a=0;a<this.outputs.length;++a){const e=this.internalOutputShapes[a],t=this.outputNames[a];this.feedOutputNames.push(t),this.feedOutputShapes.push(e),this.feedLossFns.push(this.lossFunctions[a])}const n=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],fT("loss",(()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==n.indexOf(e))continue;const t=this.lossFunctions[e];this.outputs.length>1&&(this.metricsTensors.push([t,e]),this.metricsNames.push(this.outputNames[e]+"_loss"))}}));const r=gR(e.metrics,this.outputNames),s=(e,t,n)=>{this.outputNames.length>1&&(t=this.outputNames[e]+"_"+t),this.metricsNames.push(t),this.metricsTensors.push([n,e])};fT("metric",(()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==n.indexOf(e))continue;const t=r[e],a=t=>{const n="";let r,a,i;for(const o of t){if("string"===typeof o&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(o)){const t=this.internalOutputShapes[e];let s;1===t[t.length-1]||this.lossFunctions[e]===tE?-1!==["accuracy","acc"].indexOf(o)?a=oE:-1!==["crossentropy","ce"].indexOf(o)&&(a=fE):this.lossFunctions[e]===QC?-1!==["accuracy","acc"].indexOf(o)?a=mE:-1!==["crossentropy","ce"].indexOf(o)&&(a=NE):-1!==["accuracy","acc"].indexOf(o)?a=uE:-1!==["crossentropy","ce"].indexOf(o)&&(a=kE),-1!==["accuracy","acc"].indexOf(o)?s="acc":-1!==["crossentropy","ce"].indexOf(o)&&(s="ce"),i=a,r=n+s}else{const e=TE(o);i=e,r=n+$E(o)}let t;fT(r,(()=>{t=i})),s(e,r,t)}};a(t)}})),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t,n={}){const r=null==n.batchSize?32:n.batchSize;rR(r);const s=!0,a=this.standardizeUserDataXY(e,t,s,r);try{const e=a[0].concat(a[1]);this.makeTestFunction();const t=this.testFunction,s=this.testLoop(t,e,r,n.verbose,n.steps);return DS(s)}finally{uR(a[0],e),uR(a[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),nR(this,e,t)}checkNumSamples(e,t,n,r="steps"){let s;if(null!=n){if(s=null,null!=t)throw new $S(`If ${r} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else{if(null==e)throw new $S(`Either the input data should have a defined shape, or ${r} shoud be specified.`);s=Array.isArray(e)?e[0].shape[0]:e.shape[0]}return s}execute(e,t){if(Array.isArray(t)&&0===t.length)throw new $S("`outputs` is an empty Array, which is not allowed.");const n=Array.isArray(t),r=n?t:[t],s=this.retrieveSymbolicTensors(r),a=new H$;if(e instanceof ja&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new $S(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let t=0;t<this.inputs.length;++t)a.add(this.inputs[t],e[t])}else for(const o of this.inputs){const t=e[o.name];if(null==t)throw new $S(`No value is provided for the model's input ${o.name}`);a.add(o,t)}const i=X$(s,a);return n?i:i[0]}retrieveSymbolicTensors(e){const t=AS(null,e.length);let n=e.length;for(const r of this.layers){const s=Array.isArray(r.output)?r.output:[r.output],a=s.map((e=>e.name));for(let r=0;r<e.length;++r){const i=a.indexOf(e[r]);if(-1!==i&&(t[r]=s[i],n--),0===n)break}if(0===n)break}if(n>0){const n=[];throw t.forEach(((t,r)=>{null==t&&n.push(e[r])})),new $S(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(n)}`)}return t}predictLoop(e,t=32,n=!1){return uu((()=>{const r=this.checkNumSamples(e);if(n)throw new CS("Verbose predictLoop() is not implemented yet.");const s=iR(r,t),a=this.outputs.map((e=>[]));for(let t=0;t<s.length;++t){const n=uu((()=>{const n=s[t][0],r=s[t][1],a=sR(e,n,r),i=[];if(Array.isArray(a))for(let e=0;e<a.length;++e)i.push({key:this.inputs[e],value:a[e]});else i.push({key:this.inputs[0],value:a});const o=new H$(i);return X$(this.outputs,o)}));n.forEach(((e,t)=>a[t].push(e)))}return DS(a.map((e=>tp(e,0))))}))}predict(e,t={}){const n=oR(e);mR(n,this.inputNames,this.feedInputShapes,!1);try{const e=null==t.batchSize?32:t.batchSize;return rR(e),this.predictLoop(n,e)}finally{uR(n,e)}}predictOnBatch(e){mR(e,this.inputNames,this.feedInputShapes,!0);const t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,n=!0,r){if(null==this.optimizer_)throw new TS("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const s=[];for(let a=0;a<this.feedOutputShapes.length;++a){const e=this.feedOutputShapes[a],t=this.feedLossFns[a];t===QC?s.push(e.slice(0,e.length-1).concat([1])):s.push(e)}if(e=pR(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=pR(t,this.feedOutputNames,s,!1,"target"),dR(e,t,null),fR(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=r&&r>0&&e[0].shape[0]%r!==0)throw new $S(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${r}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,n,r,s=!0,a){const[i,o]=this.standardizeUserDataXY(e,t,s,a);if(null!=n)throw new Error("sample weight is not supported yet.");let u=null;if(null!=r){const e=HE(r,this.outputNames);u=[];for(let t=0;t<e.length;++t)u.push(await jE(o[t],null,e[t]))}return[i,o,u]}testLoop(e,t,n,r=0,s){return uu((()=>{const a=this.checkNumSamples(t,n,s,"steps"),i=[];if(r>0)throw new CS("Verbose mode is not implemented yet.");if(null!=s)throw new CS("steps mode in testLoop() is not implemented yet");{const r=iR(a,n),s=Fy(NT(0,a));for(let n=0;n<r.length;++n){const a=r[n][0],o=r[n][1],u=_T(s,a,o-a),l=aR(t,u),c=e(l);if(0===n)for(let e=0;e<c.length;++e)i.push(Vu(0));for(let e=0;e<c.length;++e){const t=c[e];i[e]=ku(i[e],Cu(o-a,t))}}for(let e=0;e<i.length;++e)i[e]=Tu(i[e],a)}return i}))}getDedupedMetricsNames(){const e=this.metricsNames,t=[];for(let n=0;n<e.length;++n){const r=e[n];let s=r;if(_S(e,r)>1){const t=_S(e.slice(0,n),r);s+=`_${t}`}t.push(s)}return t}makeTrainFunction(){return e=>{const t=[],n=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),a=[],i=()=>{const e=[];for(let t=0;t<this.inputs.length;++t)e.push({key:this.inputs[t],value:n[t]});const i=new H$(e),o=X$(this.outputs,i,{training:!0});let u;for(let n=0;n<this.lossFunctions.length;++n){const e=this.lossFunctions[n];let a=e(r[n],o[n]);null!=s[n]&&(a=qE(a,s[n]));const i=hm(a);t.push(i),u=0===n?a:ku(u,a)}for(let n=0;n<this.metricsTensors.length;++n){let e;if(this.outputs.length>1&&n<this.outputs.length)e=t[n];else{const t=this.metricsTensors[n][0],s=this.metricsTensors[n][1];e=hm(t(r[s],o[s]))}cu(e),a.push(e)}return u=hm(u),this.calculateLosses().forEach((e=>{u=ku(u,e)})),u},o=this.collectedTrainableWeights.map((e=>e.read())),u=!0,l=this.optimizer_.minimize(i,u,o);return[l].concat(a)}}makeTestFunction(){this.testFunction=e=>uu((()=>{const t=[];let n;const r=e.slice(0,this.inputs.length),s=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=[];for(let e=0;e<this.inputs.length;++e)a.push({key:this.inputs[e],value:r[e]});const i=new H$(a),o=X$(this.outputs,i);for(let e=0;e<this.lossFunctions.length;++e){const r=this.lossFunctions[e],a=hm(r(s[e],o[e]));n=0===e?a:ku(n,a),t.push(n)}for(let e=0;e<this.metricsTensors.length;++e){const n=this.metricsTensors[e][0],r=this.metricsTensors[e][1],a=hm(n(s[r],o[r]));t.push(a)}return t}))}async fit(e,t,n={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");let r,s,a,i,o,u,l,c,h;this.isTraining=!0;try{const p=null==n.batchSize?32:n.batchSize;rR(p);const d=!1,f=await this.standardizeUserData(e,t,n.sampleWeight,n.classWeight,d,p);r=f[0],s=f[1],h=f[2];let m,g=!1;if(null!=n.validationData&&n.validationData.length>0){if(g=!0,2!==n.validationData.length)throw 3===n.validationData.length?new CS("validationData including sample weights is not supported yet."):new $S(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${n.validationData} is invalid.`);o=n.validationData[0],u=n.validationData[1];const e=!0,t=await this.standardizeUserData(o,u,null,null,e,p);l=t[0],c=t[1],m=l.concat(c)}else if(null!=n.validationSplit&&n.validationSplit>0&&n.validationSplit<1){g=!0;const e=Math.floor(r[0].shape[0]*(1-n.validationSplit)),t=r[0].shape[0];l=sR(r,e,t),a=r,r=sR(r,0,e),c=sR(s,e,t),i=s,s=sR(s,0,e),m=l.concat(c)}else null!=n.validationSteps&&(g=!0);const y=r.concat(s).concat(h);this.checkTrainableWeightsConsistency();const b=this.makeTrainFunction(),x=this.getDedupedMetricsNames();let w,v;g?(this.makeTestFunction(),w=this.testFunction,v=x.slice().concat(x.map((e=>"val_"+e)))):(w=null,m=[],v=x.slice());const k=PC(n.callbacks,n.yieldEvery),I=await this.fitLoop(b,y,x,p,n.epochs,n.verbose,k,w,m,n.shuffle,v,n.initialEpoch,null,null);return I}finally{this.isTraining=!1,uR(r,e),uR(s,t),uR(a,e),uR(i,t),uR(l,o),uR(c,u),null!=h&&lu(h)}}async fitLoop(e,t,n,r,s,a,i,o,u,l,c,h,p,d){null==r&&(r=32),null==s&&(s=1),null==l&&(l=!0),null==h&&(h=0);let f=!1;if(null!=o&&null!=u&&(f=!0),null!=d&&(f=!0,null==p))throw new $S("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const m=this.checkNumSamples(t,r,p,"steps_per_epoch");let g;null!=m&&(g=NT(0,m)),null==a&&(a=1);const{callbackList:y,history:b}=WC(i,a,s,h,m,p,r,f,c);y.setModel(this),this.history=b,await y.onTrainBegin(),this.stopTraining_=!1;for(let x=h;x<s;++x){await y.onEpochBegin(x);const s={};if(null!=p)throw new CS("stepsPerEpoch mode is not implemented yet.");{if("batch"===l)throw new CS("batch shuffling is not implemneted yet");l&&pe(g);const a=Fy(g),i=iR(m,r);for(let l=0;l<i.length;++l){const c={};if(await y.onBatchBegin(l,c),uu((()=>{const h=i[l][0],p=i[l][1],d=_T(a,h,p-h);c["batch"]=l,c["size"]=p-h;const m=aR(t,d),g=e(m);for(let e=0;e<n.length;++e){const t=n[e],r=g[e];c[t]=r,cu(r)}if(l===i.length-1&&f){const e=this.testLoop(o,u,r);for(let t=0;t<n.length;++t){const r=n[t],a=e[t];cu(a),s["val_"+r]=a}}})),await y.onBatchEnd(l,c),AC(c),this.stopTraining_)break}a.dispose()}if(await y.onEpochEnd(x,s),this.stopTraining_)break}return await y.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return ZE(this,e,t)}async trainOnBatch(e,t){const n=await this.standardizeUserData(e,t),r=n[0],s=n[1],a=this.makeTrainFunction(),i=a(r.concat(s)),o=[];for(const u of i){const e=await u.data();o.push(e[0])}return lu(i),uR(n[0],e),uR(n[1],t),DS(o)}getNamedWeights(e){const t=[],n=null!=e&&e.trainableOnly,r=n?this.trainableWeights:this.weights,s=this.getWeights(n);for(let a=0;a<r.length;++a)n&&!r[a].trainable||t.push({name:r[a].originalName,tensor:s[a]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(0===e.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){const t=iu().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-iu().numTensors}return e}getLossIdentifiers(){let e;if("string"===typeof this.loss)e=MS(this.loss);else if(Array.isArray(this.loss)){for(const e of this.loss)if("string"!==typeof e)throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map((e=>MS(e)))}else{const t=Object.keys(this.loss);e={};const n=this.loss;for(const r of t){if("string"!==typeof n[r])throw new Error("Serialization of non-string loss is not supported.");e[r]=MS(n[r])}}return e}getMetricIdentifiers(){if("string"===typeof this.metrics||"function"===typeof this.metrics)return[MS($E(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map((e=>MS($E(e))));{const e={};for(const t in this.metrics)e[t]=MS($E(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(null!=e.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=e.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=e.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");const t=PE(e.optimizer_config),n=VC(t);let r,s;if("string"===typeof e.loss)r=LS(e.loss);else if(Array.isArray(e.loss))r=e.loss.map((e=>LS(e)));else if(null!=e.loss){r={};for(const t in e.loss)r[t]=LS(e.loss[t])}if(Array.isArray(e.metrics))s=e.metrics.map((e=>LS(e)));else if(null!=e.metrics){s={};for(const t in e.metrics)s[t]=LS(e.metrics[t])}this.compile({loss:r,metrics:s,optimizer:n})}async save(e,t){if("string"===typeof e){const t=io(e);if(0===t.length)throw new $S(`Cannot find any save handlers for URL '${e}'`);if(t.length>1)throw new $S(`Found more than one (${t.length}) save handlers for URL '${e}'`);e=t[0]}if(null==e.save)throw new $S("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const n=await Pi(this.getNamedWeights(t)),r=!1,s=null,a=this.toJSON(s,r),i={modelTopology:a,format:yR,generatedBy:`TensorFlow.js tfjs-layers v${WE}`,convertedBy:null},o=null!=t&&t.includeOptimizer;if(o&&null!=this.optimizer){i.trainingConfig=this.getTrainingConfig();const e="optimizer",{data:t,specs:r}=await Pi(await this.optimizer.getWeights(),e);n.specs.push(...r),n.data=ji([n.data,t])}if(null!=this.userDefinedMetadata){const e=!0;RE(this.userDefinedMetadata,this.name,e),i.userDefinedMetadata=this.userDefinedMetadata}return i.weightData=n.data,i.weightSpecs=n.specs,e.save(i)}setUserDefinedMetadata(e){RE(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}bR.className="Model",qu(bR);class xR extends bR{}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
async function wR(e,t){"modelTopology"in e||(e={modelTopology:e});let n=e.modelTopology;null!=n["model_config"]&&(n=n["model_config"]);const r=PE(n),s=VC(r,t);if(null!=e.weightsManifest){const t=await Cl(e.weightsManifest,e.pathPrefix,s.weights.map((e=>e.originalName))),n={};for(const e of s.weights)n[e.originalName]=t[e.originalName];s.loadWeights(n),lu(t)}return s}async function vR(e,t){if(null==t&&(t={}),"string"===typeof e){const n=oo(e,t);if(0===n.length)n.push(Ll(e,t));else if(n.length>1)throw new $S(`Found more than one (${n.length}) load handlers for URL '${e}'`);e=n[0]}return kR(e,void 0,t)}async function kR(e,t,n){if(null==n&&(n={}),null==e.load)throw new $S("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const r=await e.load();let s=r.modelTopology;null!=s["model_config"]&&(s=s["model_config"]);const a=null==n.strict||n.strict,i=null!=r.weightData&&null!=r.weightSpecs&&a,o=VC(PE(s),t,i),u=r.trainingConfig;if(null!=u&&o.loadTrainingConfig(u),null!=r.userDefinedMetadata&&o.setUserDefinedMetadata(r.userDefinedMetadata),null!=r.weightData){if(null==r.weightSpecs)throw new $S("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");const{modelWeights:e,optimizerWeights:t}=IR(r.weightData,r.weightSpecs);o.loadWeights(e,a),null!=o.optimizer&&t.length>0&&await o.optimizer.setWeights(t),lu(e),lu(t.map((e=>e.tensor)))}return o}function IR(e,t){const n=Bi(e,t),r={},s=[];return t.forEach((e=>{"optimizer"===e.group?s.push({name:e.name,tensor:n[e.name]}):r[e.name]=n[e.name]})),{modelWeights:r,optimizerWeights:s}}xR.className="Functional",qu(xR);class NR extends bR{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=null!=e.name?e.name:tT("sequential_"),null!=e.layers)for(const t of e.layers)this.add(t)}checkShape(e){const t=e.inboundNodes[0].outputTensors[0].shape;if(t.some((e=>e<0)))throw new $S(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const t=e instanceof NR||e instanceof bR;let n;if(t){if(n=e,1!==n.outputs.length)throw new $S("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==n.inputs.length)throw new $S("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===e.inboundNodes.length){if(null==e.batchInputShape)throw new $S("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const t=U$({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(t)}if(t)this.outputs=n.outputs,this.inputs=n.inputs;else{if(1!==e.inboundNodes.length)throw new $S(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(1!==e.inboundNodes[0].outputTensors.length)throw new $S("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=P$(this.outputs[0])}this.inboundNodes=[],new D$({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:AS(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map((e=>e.shape)),outputShapes:this.outputs[0].shape})}else{const t=e.apply(this.outputs[0]);if(Array.isArray(t))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[t],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return null==this.model&&this.build(),this.model.call(e,t)}build(e){if(N$(e),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new bR({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t,n=console.log){this.built||this.build(),super.summary(e,t,n)}setWeights(e){null==this.model&&this.build(),this.model.setWeights(e)}evaluate(e,t,n={}){if(!this.built)throw new TS("The model needs to be compiled before being used.");return this.model.evaluate(e,t,n)}async evaluateDataset(e,t){if(!this.built)throw new TS("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e,t={}){return null==this.model&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return null==this.model&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t,n={}){if(!this.built)throw new TS("The model needs to be compiled before being used.");return this.model.fit(e,t,n)}async fitDataset(e,t){if(!this.built)throw new TS("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(e,t,n={},r=!1){let s,a={};if(t instanceof Array){if(null==t[0].className||"Merge"===t[0]["className"])throw new $S("Legacy serialization format not supported yet.");s=t}else we(null!=t["layers"],(()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field.")),s=t["layers"],delete t["layers"],a=t;const i=new e(a);if(!(i instanceof NR))throw new CS(`Sequential.fromConfig called on non-Sequential input: ${i}`);for(const o of s){const e=void 0,t=VC(o,e,r);r&&t.setFastWeightInitDuringBuild(!0),i.add(t)}return i}set stopTraining(e){if(null==this.model)throw new $S("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(null==this.model)throw new $S("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const t of this.layers){const n={};n["className"]=t.getClassName(),n["config"]=t.getConfig(),e.push(n)}return{name:this.name,layers:e}}}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function SR(e){return new bR(e)}function TR(e){return new NR(e)}function $R(e){return U$(e)}function CR(e,t){BC.registerCallbackConstructor(e,t)}NR.className="Sequential",qu(NR);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
class ER extends Hu{getConfig(){return{}}}class RR extends ER{apply(e,t=1){return HT(e,t)}}RR.className="elu",qu(RR);class AR extends ER{apply(e){return Ug(e)}}AR.className="selu",qu(AR);class FR extends ER{apply(e){return Sg(e)}}FR.className="relu",qu(FR);class _R extends ER{apply(e){return uu((()=>gm(6,Sg(e))))}}_R.className="relu6",qu(_R);class DR extends ER{apply(e){return e}}DR.className="linear",qu(DR);class OR extends ER{apply(e){return rp(e)}}OR.className="sigmoid",qu(OR);class MR extends ER{apply(e){return KT(e)}}MR.className="hardSigmoid",qu(MR);class LR extends ER{apply(e){return Pf(e)}}LR.className="softplus",qu(LR);class zR extends ER{apply(e){return jT(e)}}zR.className="softsign",qu(zR);class PR extends ER{apply(e){return op(e)}}PR.className="tanh",qu(PR);class BR extends ER{apply(e,t=-1){return ly(e,t)}}BR.className="softmax",qu(BR);class WR extends ER{apply(e,t=-1){return Uf(e,t)}}WR.className="logSoftmax",qu(WR);class VR extends ER{apply(e,t=1){return uu((()=>Cu(rp(Cu(e,t)),e)))}}VR.className="swish",qu(VR);class UR extends ER{apply(e){return uu((()=>Cu(e,op(Pf(e)))))}}function GR(e){return e.getClassName()}function HR(e,t={}){return WS(e,ju.getMap().classNameMap,t,"activation")}function jR(e){if(null==e){const e={className:"linear",config:{}};return HR(e)}if("string"===typeof e){const t={};return t["className"]=e,t["config"]={},HR(t)}return e instanceof ER?e:HR(e)}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function qR(e){if(null!=e&&"object"!==typeof e)throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${e}`)}UR.className="mish",qu(UR);class KR extends Hu{}class XR extends KR{constructor(e){super(),qR(e),this.l1=null==e||null==e.l1?.01:e.l1,this.l2=null==e||null==e.l2?.01:e.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(e){return uu((()=>{let t=pm([1]);return this.hasL1&&(t=ku(t,Kd(Cu(this.l1,al(e))))),this.hasL2&&(t=ku(t,Kd(Cu(this.l2,VT(e))))),Xh(t,[])}))}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t["l1"],l2:t["l2"]})}}function YR(e){return qR(e),new XR({l1:null!=e?e.l1:null,l2:0})}function JR(e){return qR(e),new XR({l2:null!=e?e.l2:null,l1:0})}XR.className="L1L2",qu(XR);const ZR={l1l2:"L1L2"};function QR(e){return PS(e)}function eA(e,t={}){return WS(e,ju.getMap().classNameMap,t,"regularizer")}function tA(e){if(null==e)return null;if("string"===typeof e){const t=e in ZR?ZR[e]:e,n={className:t,config:{}};return eA(n)}return e instanceof KR?e:eA(e)}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
class nA extends M${constructor(e){super(null==e?{}:e),this.supportsMasking=!0,null!=e&&(this.maxValue=e.maxValue)}call(e,t){e=I$(e);let n=Sg(e);return null!=this.maxValue&&(n=Fp(n,0,this.maxValue)),n}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}}nA.className="ReLU",qu(nA);class rA extends M${constructor(e){super(null==e?{}:e),this.DEFAULT_ALPHA=.3,null==e&&(e={}),this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){const n=I$(e);return Tf(n,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}rA.className="LeakyReLU",qu(rA);class sA extends M${constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==e&&(e={}),this.supportsMasking=!0,this.alphaInitializer=w$(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=tA(e.alphaRegularizer),this.alphaConstraint=cC(e.alphaConstraint),null==e.sharedAxes)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else{if("number"!==typeof e.sharedAxes)throw new $S(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`);this.sharedAxes=[e.sharedAxes]}}build(e){e=N$(e);const t=e.slice(1);if(null!=this.sharedAxes)for(const r of this.sharedAxes)t[r-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const n={};if(null!=this.sharedAxes)for(let r=1;r<e.length;++r)n[r]=e[r];this.inputSpec=[new A$({ndim:e.length,axes:n})],this.built=!0}call(e,t){return e=I$(e),Ym(e,this.alpha.read())}getConfig(){const e={alphaInitializer:x$(this.alphaInitializer),alphaRegularizer:QR(this.alphaRegularizer),alphaConstraint:uC(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}}sA.className="PReLU",qu(sA);class aA extends M${constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA=1,null==e&&(e={}),null!=e.alpha&&e.alpha!==this.DEFAULT_ALPHA)throw new CS(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){const n=I$(e);return Rd(n)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}aA.className="ELU",qu(aA);class iA extends M${constructor(e){super(null==e?{}:e),this.DEFAULT_THETA=1,null==e&&(e={}),this.theta=null==e.theta?this.DEFAULT_THETA:e.theta}call(e,t){const n=I$(e);return Cu(n,Xo(gf(n,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}}iA.className="ThresholdedReLU",qu(iA);class oA extends M${constructor(e){super(null==e?{}:e),this.DEFAULT_AXIS=1,null==e&&(e={}),this.softmax=(new BR).apply,this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis}call(e,t){return uu((()=>{let n=I$(e);const r=t["mask"];if(null!=r){const e=Cu(nl(dm(n.shape),Xo(r,n.dtype)),Vu(-1e9));n=ku(n,e)}return this.axis instanceof Array?this.axis.length>1?tf(nl(n,Hf(n,this.axis,!0))):this.softmax(n,this.axis[0]):this.softmax(n,this.axis)}))}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function uA(e,t,n){if("number"===typeof e)return AS(e,t);if(e.length!==t)throw new $S(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${e.length} elements.`);for(let r=0;r<t;++r){const s=e[r];if(!wT(s))throw new $S(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(e)} including a non-integer number ${s}`)}return e}function lA(e,t,n,r,s=1){if(null==e)return e;const a=t+(t-1)*(s-1);let i;return i="same"===n?e:e-a+1,Math.floor((i+r-1)/r)}function cA(e,t,n,r){if(null==e)return null;if("valid"===r)e=e*t+IT([n-t,0]);else{if("same"!==r)throw new $S(`Unsupport padding mode: ${r}.`);e*=t}return e}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function hA(e,t){return uu((()=>(uT(t),"channelsFirst"===t?nc(e,[0,2,3,1]):e)))}function pA(e,t){return uu((()=>(uT(t),"channelsFirst"===t?nc(e,[0,2,3,4,1]):e)))}function dA(e,t,n,r=1,s="valid",a,i=1){return uu((()=>{if(null==a&&(a=$T()),uT(a),3!==e.shape.length)throw new $S(`The input of a conv1dWithBias operation should be 3, but is ${e.shape.length} instead.`);if(3!==t.shape.length)throw new $S(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(null!=n&&1!==n.shape.length)throw new $S(`The bias for a conv1dWithBias operation should be 1, but is ${t.shape.length} instead`);if("channelsFirst"===a&&(e=nc(e,[0,2,1])),"causal"===s)throw new CS("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let o=Gp(e,t,r,"same"===s?"same":"valid","NWC",i);return null!=n&&(o=GT(o,n)),o}))}function fA(e,t,n,r=[1,1],s="valid",a,i,o=null){return uu((()=>{if(null==a&&(a=$T()),uT(a),3!==e.rank&&4!==e.rank)throw new $S(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${e.rank}.`);if(3!==t.rank&&4!==t.rank)throw new $S(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${e.rank}.`);let u=hA(e,a);if("causal"===s)throw new CS("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return u=Sb({x:u,filter:t,strides:r,pad:"same"===s?"same":"valid",dilations:i,dataFormat:"NHWC",bias:n,activation:o}),"channelsFirst"===a&&(u=nc(u,[0,3,1,2])),u}))}function mA(e,t,n,r=[1,1,1],s="valid",a,i){return uu((()=>{if(null==a&&(a=$T()),uT(a),4!==e.rank&&5!==e.rank)throw new $S(`conv3dWithBias expects input to be of rank 4 or 5, but received ${e.rank}.`);if(4!==t.rank&&5!==t.rank)throw new $S(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${e.rank}.`);let o=pA(e,a);if("causal"===s)throw new CS("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return o=Yp(o,t,r,"same"===s?"same":"valid","NDHWC",i),null!=n&&(o=GT(o,n)),"channelsFirst"===a&&(o=nc(o,[0,4,1,2,3])),o}))}oA.className="Softmax",qu(oA);class gA extends M${constructor(e,t){if(super(t),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",gA.verifyArgs(t),this.rank=e,KS(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new CS(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=uA(t.kernelSize,e,"kernelSize"),this.strides=uA(null==t.strides?1:t.strides,e,"strides"),this.padding=null==t.padding?"valid":t.padding,cT(this.padding),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,uT(this.dataFormat),this.activation=jR(t.activation),this.useBias=null==t.useBias||t.useBias,this.biasInitializer=w$(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=cC(t.biasConstraint),this.biasRegularizer=tA(t.biasRegularizer),this.activityRegularizer=tA(t.activityRegularizer),this.dilationRate=uA(null==t.dilationRate?1:t.dilationRate,e,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new $S(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(2===this.rank){if("number"===typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new $S(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(3===this.rank)if("number"===typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new $S(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}static verifyArgs(e){if(FS("kernelSize"in e,"required key 'kernelSize' not in config"),"number"!==typeof e.kernelSize&&!qS(e.kernelSize,"number",1,3))throw new $S(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){const e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:GR(this.activation),useBias:this.useBias,biasInitializer:x$(this.biasInitializer),biasRegularizer:QR(this.biasRegularizer),activityRegularizer:QR(this.activityRegularizer),biasConstraint:uC(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}class yA extends gA{constructor(e,t){super(e,t),this.kernel=null,yA.verifyArgs(t),this.filters=t.filters,KS(this.filters,"filters"),this.kernelInitializer=w$(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=cC(t.kernelConstraint),this.kernelRegularizer=tA(t.kernelRegularizer)}build(e){e=N$(e);const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new $S(`The channel dimension of the input should be defined. Found ${e[t]}`);const n=e[t],r=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:n}}],this.built=!0}call(e,t){return uu((()=>{let t;e=I$(e);const n=null==this.bias?null:this.bias.read(),r=JS(this.activation.getClassName());if(null!=r&&2===this.rank)t=fA(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate,r);else{if(1===this.rank)t=dA(e,this.kernel.read(),n,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)t=fA(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new CS("convolutions greater than 3D are not implemented yet.");t=mA(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(t=this.activation.apply(t))}return t}))}computeOutputShape(e){e=N$(e);const t=[],n="channelsLast"===this.dataFormat?e.slice(1,e.length-1):e.slice(2);for(let s=0;s<n.length;++s){const e=lA(n[s],this.kernelSize[s],this.padding,this.strides[s],"number"===typeof this.dilationRate?this.dilationRate:this.dilationRate[s]);t.push(e)}let r=[e[0]];return"channelsLast"===this.dataFormat?(r=r.concat(t),r.push(this.filters)):(r.push(this.filters),r=r.concat(t)),r}getConfig(){const e={filters:this.filters,kernelInitializer:x$(this.kernelInitializer),kernelRegularizer:QR(this.kernelRegularizer),kernelConstraint:uC(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||"number"!==typeof e.filters||e.filters<1)throw new $S(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}}class bA extends yA{constructor(e){super(2,e),bA.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e["rank"],e}static verifyArgs(e){if("number"!==typeof e.kernelSize&&!qS(e.kernelSize,"number",1,2))throw new $S(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}bA.className="Conv2D",qu(bA);class xA extends yA{constructor(e){super(3,e),xA.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e["rank"],e}static verifyArgs(e){if("number"!==typeof e.kernelSize&&(!Array.isArray(e.kernelSize)||1!==e.kernelSize.length&&3!==e.kernelSize.length))throw new $S(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}xA.className="Conv3D",qu(xA);class wA extends bA{constructor(e){if(super(e),this.inputSpec=[new A$({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new $S(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=N$(e),4!==e.length)throw new $S("Input should have rank 4; Received input shape: "+JSON.stringify(e));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new $S("The channel dimension of the inputs should be defined. Found `None`.");const n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new A$({ndim:4,axes:{[t]:n}})],this.built=!0}call(e,t){return uu((()=>{let t=I$(e);if(4!==t.shape.length)throw new $S(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${t.shape.length}`);const n=t.shape,r=n[0];let s,a;"channelsFirst"===this.dataFormat?(s=2,a=3):(s=1,a=2);const i=n[s],o=n[a],u=this.kernelSize[0],l=this.kernelSize[1],c=this.strides[0],h=this.strides[1],p=cA(i,c,u,this.padding),d=cA(o,h,l,this.padding),f=[r,p,d,this.filters];"channelsLast"!==this.dataFormat&&(t=nc(t,[0,2,3,1]));let m=Kp(t,this.kernel.read(),f,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(m=nc(m,[0,3,1,2])),null!=this.bias&&(m=GT(m,this.bias.read(),this.dataFormat)),null!=this.activation&&(m=this.activation.apply(m)),m}))}computeOutputShape(e){e=N$(e);const t=e.slice();let n,r,s;"channelsFirst"===this.dataFormat?(n=1,r=2,s=3):(n=3,r=1,s=2);const a=this.kernelSize[0],i=this.kernelSize[1],o=this.strides[0],u=this.strides[1];return t[n]=this.filters,t[r]=cA(t[r],o,a,this.padding),t[s]=cA(t[s],u,i,this.padding),t}getConfig(){const e=super.getConfig();return delete e["dilationRate"],e}}wA.className="Conv2DTranspose",qu(wA);class vA extends xA{constructor(e){if(super(e),this.inputSpec=[new A$({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new $S(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=N$(e),5!==e.length)throw new $S("Input should have rank 5; Received input shape: "+JSON.stringify(e));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new $S("The channel dimension of the inputs should be defined. Found `None`.");const n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new A$({ndim:5,axes:{[t]:n}})],this.built=!0}call(e,t){return uu((()=>{let t=I$(e);if(5!==t.shape.length)throw new $S(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${t.shape.length}`);const n=t.shape,r=n[0];let s,a,i;"channelsFirst"===this.dataFormat?(i=2,s=3,a=4):(i=1,s=2,a=3);const o=n[i],u=n[s],l=n[a],c=this.kernelSize[0],h=this.kernelSize[1],p=this.kernelSize[2],d=this.strides[0],f=this.strides[1],m=this.strides[2],g=cA(o,d,c,this.padding),y=cA(u,f,h,this.padding),b=cA(l,m,p,this.padding),x=[r,g,y,b,this.filters];"channelsLast"!==this.dataFormat&&(t=nc(t,[0,2,3,4,1]));let w=ed(t,this.kernel.read(),x,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(w=nc(w,[0,4,1,2,3])),null!==this.bias&&(w=GT(w,this.bias.read(),this.dataFormat)),null!==this.activation&&(w=this.activation.apply(w)),w}))}computeOutputShape(e){e=N$(e);const t=e.slice();let n,r,s,a;"channelsFirst"===this.dataFormat?(n=1,r=2,s=3,a=4):(n=4,r=1,s=2,a=3);const i=this.kernelSize[0],o=this.kernelSize[1],u=this.kernelSize[2],l=this.strides[0],c=this.strides[1],h=this.strides[2];return t[n]=this.filters,t[r]=cA(t[r],l,i,this.padding),t[s]=cA(t[s],c,o,this.padding),t[a]=cA(t[a],h,u,this.padding),t}getConfig(){const e=super.getConfig();return delete e["dilationRate"],e}}vA.className="Conv3DTranspose",qu(vA);class kA extends yA{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==t.filters)throw new $S("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=t.kernelInitializer||null!=t.kernelRegularizer||null!=t.kernelConstraint)throw new $S("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=t.padding&&"same"!==t.padding&&"valid"!==t.padding)throw new $S(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=null==t.depthMultiplier?1:t.depthMultiplier,this.depthwiseInitializer=w$(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=tA(t.depthwiseRegularizer),this.depthwiseConstraint=cC(t.depthwiseConstraint),this.pointwiseInitializer=w$(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=tA(t.pointwiseRegularizer),this.pointwiseConstraint=cC(t.pointwiseConstraint)}build(e){if(e=N$(e),e.length<this.rank+2)throw new $S(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t]||e[t]<0)throw new $S(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);const n=e[t],r=this.kernelSize.concat([n,this.depthMultiplier]),s=[];for(let i=0;i<this.rank;++i)s.push(1);s.push(n*this.depthMultiplier,this.filters);const a=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,a,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",s,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,a,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,a,this.biasConstraint):this.bias=null,this.inputSpec=[new A$({ndim:this.rank+2,axes:{[t]:n}})],this.built=!0}call(e,t){return uu((()=>{let t;if(e=I$(e),1===this.rank)throw new CS("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(e=nc(e,[0,2,3,1])),t=Hg(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(t=GT(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),"channelsFirst"===this.dataFormat&&(t=nc(t,[0,3,1,2])),t}))}getConfig(){const e=super.getConfig();return delete e["rank"],delete e["kernelInitializer"],delete e["kernelRegularizer"],delete e["kernelConstraint"],e["depthwiseInitializer"]=x$(this.depthwiseInitializer),e["pointwiseInitializer"]=x$(this.pointwiseInitializer),e["depthwiseRegularizer"]=QR(this.depthwiseRegularizer),e["pointwiseRegularizer"]=QR(this.pointwiseRegularizer),e["depthwiseConstraint"]=uC(this.depthwiseConstraint),e["pointwiseConstraint"]=uC(this.pointwiseConstraint),e}}kA.className="SeparableConv";class IA extends kA{constructor(e){super(2,e)}}IA.className="SeparableConv2D",qu(IA);class NA extends yA{constructor(e){super(1,e),NA.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e["rank"],delete e["dataFormat"],e}static verifyArgs(e){if("number"!==typeof e.kernelSize&&!qS(e.kernelSize,"number",1,1))throw new $S(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}NA.className="Conv1D",qu(NA);class SA extends M${constructor(e){super(e),"number"===typeof e.cropping?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:"number"===typeof e.cropping[0]?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=void 0===e.dataFormat?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return uu((()=>{if(e=I$(e),"channelsLast"===this.dataFormat){const t=OT(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return OT(t,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{const t=OT(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return OT(t,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}}))}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}SA.className="Cropping2D",qu(SA);class TA extends M${constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==e.size?this.DEFAULT_SIZE:e.size,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,uT(this.dataFormat),this.interpolation=null==e.interpolation?"nearest":e.interpolation,lT(this.interpolation)}computeOutputShape(e){if("channelsFirst"===this.dataFormat){const t=null==e[2]?null:this.size[0]*e[2],n=null==e[3]?null:this.size[1]*e[3];return[e[0],e[1],t,n]}{const t=null==e[1]?null:this.size[0]*e[1],n=null==e[2]?null:this.size[1]*e[2];return[e[0],t,n,e[3]]}}call(e,t){return uu((()=>{let t=I$(e);const n=t.shape;if("channelsFirst"===this.dataFormat){t=nc(t,[0,2,3,1]);const e=this.size[0]*n[2],r=this.size[1]*n[3],s="nearest"===this.interpolation?Iw.resizeNearestNeighbor(t,[e,r]):Iw.resizeBilinear(t,[e,r]);return nc(s,[0,3,1,2])}{const e=this.size[0]*n[1],r=this.size[1]*n[2];return"nearest"===this.interpolation?Iw.resizeNearestNeighbor(t,[e,r]):Iw.resizeBilinear(t,[e,r])}}))}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function $A(e,t,n=[1,1],r="valid",s,a){return uu((()=>{null==s&&(s=$T()),uT(s);let i=hA(e,s);if(4!==e.rank)throw new $S(`Input for depthwiseConv2d is required to be 4-D, but is instead ${e.rank}-D`);if(4!==t.rank)throw new $S(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return i=fd(i,t,n,"same"===r?"same":"valid","NHWC",a),"channelsFirst"===s&&(i=nc(i,[0,3,1,2])),i}))}TA.className="UpSampling2D",qu(TA);class CA extends gA{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=w$(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=cC(e.depthwiseConstraint),this.depthwiseRegularizer=tA(e.depthwiseRegularizer)}build(e){if(e=N$(e),e.length<4)throw new $S(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const t="channelsFirst"===this.dataFormat?1:3;if(null==e[t]||e[t]<0)throw new $S(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);const n=e[t],r=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return uu((()=>{e=I$(e);let t=$A(e,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(t=GT(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),t}))}computeOutputShape(e){e=N$(e);const t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],r="channelsFirst"===this.dataFormat?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,s=lA(t,this.kernelSize[0],this.padding,this.strides[0]),a=lA(n,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[e[0],r,s,a]:[e[0],s,a,r]}getConfig(){const e=super.getConfig();return e["depthMultiplier"]=this.depthMultiplier,e["depthwiseInitializer"]=x$(this.depthwiseInitializer),e["depthwiseRegularizer"]=QR(this.depthwiseRegularizer),e["depthwiseConstraint"]=uC(this.depthwiseRegularizer),e}}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function EA(e,t,n,r){if(Array.isArray(e)){if(null!=t||null!=n)throw new $S("When inputs is an array, neither initialState or constants should be provided");null!=r&&(n=e.slice(e.length-r,e.length),e=e.slice(0,e.length-r)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function s(e){return null==e||Array.isArray(e)?e:[e]}return t=s(t),n=s(n),{inputs:e,initialState:t,constants:n}}function RA(e,t,n,r=!1,s,a,i=!1,o=!1){return uu((()=>{const u=t.shape.length;if(u<3)throw new $S(`Input should be at least 3D, but is ${u}D.`);const l=[1,0].concat(NT(2,u));if(t=nc(t,l),null!=a)throw new CS("The rnn() functoin of the deeplearn.js backend does not support constants yet.");i&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=s&&(s=Xo(Xo(s,"bool"),"float32"),s.rank===u-1&&(s=rf(s,-1)),s=nc(s,l)),r&&(t=Eg(t,0),null!=s&&(s=Eg(s,0)));const c=[];let h,p=n;const d=t.shape[0],f=Ky(t);let m,g;null!=s&&(m=Ky(s));for(let t=0;t<d;++t){const n=f[t],r=uu((()=>e(n,p)));if(null==s)h=r[0],p=r[1];else{const e=uu((()=>{const e=m[t],n=nl(Rm(e),e),s=ku(Cu(r[0],e),Cu(p[0],n)),a=p.map(((t,s)=>ku(Cu(r[1][s],e),Cu(t,n))));return{output:s,newStates:a}}));h=e.output,p=e.newStates}o&&c.push(h)}if(o){const e=1;g=Sy(c,e)}return[h,g,p]}))}CA.className="DepthwiseConv2D",qu(CA);class AA extends M${constructor(e){let t;if(super(e),null==e.cell)throw new $S("cell property is missing for the constructor of RNN.");if(t=Array.isArray(e.cell)?new PA({cells:e.cell}):e.cell,null==t.stateSize)throw new $S("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=null!=e.returnSequences&&e.returnSequences,this.returnState=null!=e.returnState&&e.returnState,this.goBackwards=null!=e.goBackwards&&e.goBackwards,this._stateful=null!=e.stateful&&e.stateful,this.unroll=null!=e.unroll&&e.unroll,this.supportsMasking=!0,this.inputSpec=[new A$({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(null==this.states_){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return NT(0,e).map((e=>null))}return this.states_}setStates(e){this.states_=e}computeOutputShape(e){v$(e)&&(e=e[0]);let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);const n=t[0];let r;if(r=this.returnSequences?[e[0],e[1],n]:[e[0],n],this.returnState){const n=[];for(const r of t)n.push([e[0],r]);return[r].concat(n)}return r}computeMask(e,t){return uu((()=>{Array.isArray(t)&&(t=t[0]);const e=this.returnSequences?t:null;if(this.returnState){const t=this.states.map((e=>null));return[e].concat(t)}return e}))}get states(){if(null==this.states_){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let n=0;n<e;++n)t.push(null);return t}return this.states_}set states(e){this.states_=e}build(e){const t=null;if(null!=this.numConstants)throw new CS("Constants support is not implemented in RNN yet.");v$(e)&&(e=e[0]);const n=this.stateful?e[0]:null,r=e.slice(2);this.inputSpec[0]=new A$({shape:[n,null,...r]});const s=[e[0]].concat(e.slice(2));if(null!=t)throw new CS("Constants support is not implemented in RNN yet.");let a;if(this.cell.build(s),a=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!Te(this.stateSpec.map((e=>e.shape[e.shape.length-1])),a))throw new $S(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=a.map((e=>new A$({shape:[null,e]})));this.stateful&&this.resetStates()}resetStates(e,t=!1){uu((()=>{if(!this.stateful)throw new SS("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape[0];if(null==n)throw new $S("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((e=>pm([n,e]))):this.states_=[pm([n,this.cell.stateSize])];else if(null==e)lu(this.states_),null!=this.keptStates&&(lu(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((e=>pm([n,e]))):this.states_[0]=pm([n,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new $S(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);!0===t?this.keptStates.push(this.states_.slice()):lu(this.states_);for(let t=0;t<this.states_.length;++t){const r=e[t],s=Array.isArray(this.cell.stateSize)?this.cell.stateSize[t]:this.cell.stateSize,a=[n,s];if(!Te(r.shape,a))throw new $S(`State ${t} is incompatible with layer ${this.name}: expected shape=${a}, received shape=${r.shape}`);this.states_[t]=r}}this.states_=this.states_.map((e=>cu(e.clone())))}))}apply(e,t){let n=null==t?null:t["initialState"],r=null==t?null:t["constants"];null==t&&(t={});const s=EA(e,n,r,this.numConstants);e=s.inputs,n=s.initialState,r=s.constants;let a=[],i=[];if(null!=n){t["initialState"]=n,a=a.concat(n),this.stateSpec=[];for(const e of n)this.stateSpec.push(new A$({shape:e.shape}));i=i.concat(this.stateSpec)}null!=r&&(t["constants"]=r,a=a.concat(r),this.numConstants=r.length);const o=a[0]instanceof F$;if(o){const n=[e].concat(a),r=this.inputSpec.concat(i),s=this.inputSpec;this.inputSpec=r;const o=super.apply(n,t);return this.inputSpec=s,o}return super.apply(e,t)}call(e,t){return uu((()=>{const n=null==t?null:t["mask"],r=null==t?null:t["training"];let s=null==t?null:t["initialState"];e=I$(e),null==s&&(s=this.stateful?this.states_:this.getInitialState(e));const a=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(s.length!==a)throw new $S(`RNN Layer has ${a} state(s) but was passed ${s.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const i={training:r},o=(e,t)=>{const n=this.cell.call([e].concat(t),i);return[n[0],n.slice(1)]},u=RA(o,e,s,this.goBackwards,n,null,this.unroll,this.returnSequences),l=u[0],c=u[1],h=u[2];this.stateful&&this.resetStates(h,r);const p=this.returnSequences?c:l;return this.returnState?[p].concat(h):p}))}getInitialState(e){return uu((()=>{let t=pm(e.shape);return t=Kd(t,[1,2]),t=ET(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map((e=>e>1?zT(t,[1,e]):t)):this.cell.stateSize>1?[zT(t,[1,this.cell.stateSize])]:[t]}))}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(t["numConstants"]=this.numConstants);const n=this.cell.getConfig();return this.getClassName()===AA.className&&(t["cell"]={className:this.cell.getClassName(),config:n}),Object.assign(Object.assign(Object.assign({},n),e),t)}static fromConfig(e,t,n={}){const r=t["cell"],s=VC(r,n);return new e(Object.assign(t,{cell:s}))}}AA.className="RNN",qu(AA);class FA extends M${}class _A extends FA{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,KS(this.units,"units"),this.activation=jR(null==e.activation?this.DEFAULT_ACTIVATION:e.activation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=w$(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=w$(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=w$(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=tA(e.kernelRegularizer),this.recurrentRegularizer=tA(e.recurrentRegularizer),this.biasRegularizer=tA(e.biasRegularizer),this.kernelConstraint=cC(e.kernelConstraint),this.recurrentConstraint=cC(e.recurrentConstraint),this.biasConstraint=cC(e.biasConstraint),this.dropout=kT([1,IT([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=kT([1,IT([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=N$(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return uu((()=>{if(2!==e.length)throw new $S(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let n=e[1];e=e[0];const r=null!=t["training"]&&t["training"];let s;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=BA({ones:()=>Rm(e),rate:this.dropout,training:r,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=BA({ones:()=>Rm(n),rate:this.recurrentDropout,training:r,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,i=this.recurrentDropoutMask;s=BT(null!=a?Cu(e,a):e,this.kernel.read()),null!=this.bias&&(s=GT(s,this.bias.read())),null!=i&&(n=Cu(n,i));let o=ku(s,BT(n,this.recurrentKernel.read()));return null!=this.activation&&(o=this.activation.apply(o)),[o,o]}))}getConfig(){const e=super.getConfig(),t={units:this.units,activation:GR(this.activation),useBias:this.useBias,kernelInitializer:x$(this.kernelInitializer),recurrentInitializer:x$(this.recurrentInitializer),biasInitializer:x$(this.biasInitializer),kernelRegularizer:QR(this.kernelRegularizer),recurrentRegularizer:QR(this.recurrentRegularizer),biasRegularizer:QR(this.biasRegularizer),activityRegularizer:QR(this.activityRegularizer),kernelConstraint:uC(this.kernelConstraint),recurrentConstraint:uC(this.recurrentConstraint),biasConstraint:uC(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}}_A.className="SimpleRNNCell",qu(_A);class DA extends AA{constructor(e){e.cell=new _A(e),super(e)}call(e,t){return uu((()=>{null!=this.cell.dropoutMask&&(lu(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(lu(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t["mask"],r=null==t?null:t["training"],s=null==t?null:t["initialState"];return super.call(e,{mask:n,training:r,initialState:s})}))}static fromConfig(e,t){return new e(t)}}DA.className="SimpleRNN",qu(DA);class OA extends FA{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new $S("GRUCell does not support reset_after parameter set to true.");this.units=e.units,KS(this.units,"units"),this.activation=jR(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=jR(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=w$(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=w$(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=w$(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=tA(e.kernelRegularizer),this.recurrentRegularizer=tA(e.recurrentRegularizer),this.biasRegularizer=tA(e.biasRegularizer),this.kernelConstraint=cC(e.kernelConstraint),this.recurrentConstraint=cC(e.recurrentConstraint),this.biasConstraint=cC(e.biasConstraint),this.dropout=kT([1,IT([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=kT([1,IT([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=N$(e);const t=e[e.length-1];this.kernel=this.addWeight("kernel",[t,3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return uu((()=>{if(2!==e.length)throw new $S(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const n=null!=t["training"]&&t["training"];let r=e[1];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=BA({ones:()=>Rm(e),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=BA({ones:()=>Rm(r),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));const s=this.dropoutMask,a=this.recurrentDropoutMask;let i,o,u;0<this.dropout&&this.dropout<1&&(e=Cu(e,s[0]));let l=BT(e,this.kernel.read());this.useBias&&(l=GT(l,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=Cu(r,a[0]));const c=this.recurrentKernel.read(),[h,p]=yy(c,[2*this.units,this.units],c.rank-1),d=BT(r,h),[f,m,g]=yy(l,3,l.rank-1),[y,b]=yy(d,2,d.rank-1);i=this.recurrentActivation.apply(ku(f,y)),o=this.recurrentActivation.apply(ku(m,b));const x=BT(Cu(o,r),p);u=this.activation.apply(ku(g,x));const w=ku(Cu(i,r),Cu(ku(1,Zl(i)),u));return[w,w]}))}getConfig(){const e=super.getConfig(),t={units:this.units,activation:GR(this.activation),recurrentActivation:GR(this.recurrentActivation),useBias:this.useBias,kernelInitializer:x$(this.kernelInitializer),recurrentInitializer:x$(this.recurrentInitializer),biasInitializer:x$(this.biasInitializer),kernelRegularizer:QR(this.kernelRegularizer),recurrentRegularizer:QR(this.recurrentRegularizer),biasRegularizer:QR(this.biasRegularizer),activityRegularizer:QR(this.activityRegularizer),kernelConstraint:uC(this.kernelConstraint),recurrentConstraint:uC(this.recurrentConstraint),biasConstraint:uC(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}}OA.className="GRUCell",qu(OA);class MA extends AA{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new OA(e),super(e)}call(e,t){return uu((()=>{null!=this.cell.dropoutMask&&(lu(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(lu(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t["mask"],r=null==t?null:t["training"],s=null==t?null:t["initialState"];return super.call(e,{mask:n,training:r,initialState:s})}))}static fromConfig(e,t){return 0===t["implmentation"]&&(t["implementation"]=1),new e(t)}}MA.className="GRU",qu(MA);class LA extends FA{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,KS(this.units,"units"),this.activation=jR(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=jR(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=w$(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=w$(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=w$(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=tA(e.kernelRegularizer),this.recurrentRegularizer=tA(e.recurrentRegularizer),this.biasRegularizer=tA(e.biasRegularizer),this.kernelConstraint=cC(e.kernelConstraint),this.recurrentConstraint=cC(e.recurrentConstraint),this.biasConstraint=cC(e.biasConstraint),this.dropout=kT([1,IT([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=kT([1,IT([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;e=N$(e);const n=e[e.length-1];let r;if(this.kernel=this.addWeight("kernel",[n,4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const e=this.biasInitializer,n=this.units;r=new(t=class extends e${apply(t,r){const s=e.apply([n]),a=(new n$).apply([n]),i=e.apply([2*n]);return LT(LT(s,a),i)}},t.className="CustomInit",t)}else r=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,r,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return uu((()=>{const n=null!=t["training"]&&t["training"];if(3!==e.length)throw new $S(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let r=e[1];const s=e[2];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=BA({ones:()=>Rm(e),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=BA({ones:()=>Rm(r),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,i=this.recurrentDropoutMask;let o,u,l,c;0<this.dropout&&this.dropout<1&&(e=Cu(e,a[0]));let h=BT(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=Cu(r,i[0])),h=ku(h,BT(r,this.recurrentKernel.read())),this.useBias&&(h=GT(h,this.bias.read()));const[p,d,f,m]=yy(h,4,h.rank-1);o=this.recurrentActivation.apply(p),u=this.recurrentActivation.apply(d),l=ku(Cu(u,s),Cu(o,this.activation.apply(f))),c=this.recurrentActivation.apply(m);const g=Cu(c,this.activation.apply(l));return[g,g,l]}))}getConfig(){const e=super.getConfig(),t={units:this.units,activation:GR(this.activation),recurrentActivation:GR(this.recurrentActivation),useBias:this.useBias,kernelInitializer:x$(this.kernelInitializer),recurrentInitializer:x$(this.recurrentInitializer),biasInitializer:x$(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:QR(this.kernelRegularizer),recurrentRegularizer:QR(this.recurrentRegularizer),biasRegularizer:QR(this.biasRegularizer),activityRegularizer:QR(this.activityRegularizer),kernelConstraint:uC(this.kernelConstraint),recurrentConstraint:uC(this.recurrentConstraint),biasConstraint:uC(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}}LA.className="LSTMCell",qu(LA);class zA extends AA{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new LA(e),super(e)}call(e,t){return uu((()=>{null!=this.cell.dropoutMask&&(lu(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(lu(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t["mask"],r=null==t?null:t["training"],s=null==t?null:t["initialState"];return super.call(e,{mask:n,training:r,initialState:s})}))}static fromConfig(e,t){return 0===t["implmentation"]&&(t["implementation"]=1),new e(t)}}zA.className="LSTM",qu(zA);class PA extends FA{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return uu((()=>{let n=e.slice(1);const r=[];for(const e of this.cells.slice().reverse())Array.isArray(e.stateSize)?r.push(n.splice(0,e.stateSize.length)):r.push(n.splice(0,1));r.reverse();const s=[];let a;for(let i=0;i<this.cells.length;++i){const o=this.cells[i];n=r[i],a=0===i?[e[0]].concat(n):[a[0]].concat(n),a=o.call(a,t),s.push(a.slice(1))}n=[];for(const e of s.slice().reverse())n.push(...e);return[a[0]].concat(n)}))}build(e){let t;v$(e)&&(e=e[0]),this.cells.forEach(((n,r)=>{fT(`RNNCell_${r}`,(()=>{n.build(e),t=Array.isArray(n.stateSize)?n.stateSize[0]:n.stateSize,e=[e[0],t]}))})),this.built=!0}getConfig(){const e=super.getConfig(),t=e=>({className:e.getClassName(),config:e.getConfig()}),n=this.cells.map(t),r={cells:n};return Object.assign(Object.assign({},e),r)}static fromConfig(e,t,n={}){const r=[];for(const s of t["cells"])r.push(VC(s,n));return new e({cells:r})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const e of this.cells)t.push(...e.trainableWeights);return t.concat(e)}return e}getWeights(){const e=[];for(const t of this.cells)e.push(...t.weights);return E$(e)}setWeights(e){const t=[];for(const n of this.cells){const r=n.weights.length,s=e.splice(r);for(let e=0;e<n.weights.length;++e)t.push([n.weights[e],s[e]])}R$(t)}}function BA(e){const{ones:t,rate:n,training:r=!1,count:s=1,dropoutFunc:a}=e,i=()=>null!=a?a(t(),n):qT(t(),n),o=()=>XT(i,t,r);if(!s||s<=1)return cu(o().clone());const u=Array(s).fill(void 0).map(o);return u.map((e=>cu(e.clone())))}PA.className="StackedRNNCells",qu(PA);
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
var WA=function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(null!=e&&"function"===typeof Object.getOwnPropertySymbols){var s=0;for(r=Object.getOwnPropertySymbols(e);s<r.length;s++)t.indexOf(r[s])<0&&Object.prototype.propertyIsEnumerable.call(e,r[s])&&(n[r[s]]=e[r[s]])}return n};class VA extends AA{constructor(e){if(e.unroll)throw new CS("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new CS("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new A$({ndim:5})]}call(e,t){return uu((()=>{if(null!=this.cell.dropoutMask&&(lu(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(lu(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t["constants"])throw new $S("ConvRNN2D cell does not support constants");const n=null==t?null:t["mask"],r=null==t?null:t["training"],s=null==t?null:t["initialState"];return super.call(e,{mask:n,training:r,initialState:s})}))}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return uu((()=>{const{stateSize:t}=this.cell,n=e.shape,r=this.computeSingleOutputShape(n),s=[r[0],...r.slice(2)],a=pm(s);return Array.isArray(t)?Array(t.length).fill(a):[a]}))}resetStates(e,t=!1){uu((()=>{if(!this.stateful)throw new SS("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape,r=this.computeSingleOutputShape(n),s=[r[0],...r.slice(2)],a=n[0];if(null==a)throw new $S("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>pm(s))):this.states_=[pm(s)];else if(null==e)lu(this.states_),null!=this.keptStates&&(lu(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>pm(s))):this.states_[0]=pm(s);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new $S(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):lu(this.states_);for(let t=0;t<this.states_.length;++t){const n=e[t],r=s;if(!Te(n.shape,r))throw new $S(`State ${t} is incompatible with layer ${this.name}: expected shape=${r}, received shape=${n.shape}`);this.states_[t]=n}}this.states_=this.states_.map((e=>cu(e.clone())))}))}computeSingleOutputShape(e){const{dataFormat:t,filters:n,kernelSize:r,padding:s,strides:a,dilationRate:i}=this.cell,o="channelsFirst"===t,u=e[o?3:2],l=e[o?4:3],c=lA(u,r[0],s,a[0],i[0]),h=lA(l,r[1],s,a[1],i[1]),p=[...e.slice(0,2),...o?[n,c,h]:[c,h,n]];return p}}VA.className="ConvRNN2D";class UA extends LA{constructor(e){const{filters:t,kernelSize:n,strides:r,padding:s,dataFormat:a,dilationRate:i}=e;super(Object.assign(Object.assign({},e),{units:t})),this.filters=t,KS(this.filters,"filters"),this.kernelSize=uA(n,2,"kernelSize"),this.kernelSize.forEach((e=>KS(e,"kernelSize"))),this.strides=uA(r||1,2,"strides"),this.strides.forEach((e=>KS(e,"strides"))),this.padding=s||"valid",cT(this.padding),this.dataFormat=a||"channelsLast",uT(this.dataFormat),this.dilationRate=uA(i||1,2,"dilationRate"),this.dilationRate.forEach((e=>KS(e,"dilationRate")))}build(e){var t;e=N$(e);const n="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[n])throw new $S(`The channel dimension of the input should be defined. Found ${e[n]}`);const r=e[n],s=4,a=this.kernelSize.concat([r,this.filters*s]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const i=this.kernelSize.concat([this.filters,this.filters*s]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",i,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let e;if(this.unitForgetBias){const n=this.biasInitializer,r=this.filters;e=new(t=class extends e${apply(e,t){const s=n.apply([r]),a=dm([r]),i=n.apply([2*r]);return MT([s,a,i])}},t.className="CustomInit",t)}else e=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*s],null,e,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return uu((()=>{if(3!==e.length)throw new $S(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const n=t["training"]||!1,r=e[0],s=e[1],a=e[2],i=4;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=BA({ones:()=>Rm(r),rate:this.dropout,training:n,count:i,dropoutFunc:this.dropoutFunc}));const o=this.dropoutMask,u=(e,t,n)=>t&&t[n]?Cu(t[n],e):e;let l=u(r,o,0),c=u(r,o,1),h=u(r,o,2),p=u(r,o,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=BA({ones:()=>Rm(s),rate:this.recurrentDropout,training:n,count:i,dropoutFunc:this.dropoutFunc}));const d=this.recurrentDropoutMask;let f=u(s,d,0),m=u(s,d,1),g=u(s,d,2),y=u(s,d,3);const b=3,[x,w,v,k]=yy(this.kernel.read(),i,b),[I,N,S,T]=this.useBias?yy(this.bias.read(),i):[null,null,null,null];l=this.inputConv(l,x,I,this.padding),c=this.inputConv(c,w,N,this.padding),h=this.inputConv(h,v,S,this.padding),p=this.inputConv(p,k,T,this.padding);const[$,C,E,R]=yy(this.recurrentKernel.read(),i,b);f=this.recurrentConv(f,$),m=this.recurrentConv(m,C),g=this.recurrentConv(g,E),y=this.recurrentConv(y,R);const A=this.recurrentActivation.apply(ku(l,f)),F=this.recurrentActivation.apply(ku(c,m)),_=ku(Cu(F,a),Cu(A,this.activation.apply(ku(h,g)))),D=Cu(this.recurrentActivation.apply(ku(p,y)),this.activation.apply(_));return[D,D,_]}))}getConfig(){const e=super.getConfig(),{units:t}=e,n=WA(e,["units"]),r={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},n),r)}inputConv(e,t,n,r){const s=Vp(e,t,this.strides,r||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return n?GT(s,n,this.dataFormat):s}recurrentConv(e,t){const n=1;return Vp(e,t,n,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}}UA.className="ConvLSTM2DCell",qu(UA);class GA extends VA{constructor(e){const t=new UA(e);super(Object.assign(Object.assign({},e),{cell:t}))}static fromConfig(e,t){return new e(t)}}GA.className="ConvLSTM2D",qu(GA);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
class HA extends M${constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(null==this.noiseShape)return this.noiseShape;const t=e.shape,n=[];for(let r=0;r<this.noiseShape.length;++r)n.push(null==this.noiseShape[r]?t[r]:this.noiseShape[r]);return n}call(e,t){return uu((()=>{this.invokeCallHook(e,t);const n=I$(e);if(0<this.rate&&this.rate<1){const e=null!=t["training"]&&t["training"],r=this.getNoiseShape(n),s=XT((()=>qT(n,this.rate,r,this.seed)),(()=>n),e);return s}return e}))}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}}HA.className="Dropout",qu(HA);class jA extends HA{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const t=e.shape;return[t[0],1,t[2]]}}jA.className="SpatialDropout1D",qu(jA);class qA extends M${constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==e.batchInputShape&&null==e.inputShape&&null!=e.inputDim){let t=null;null!=e.batchSize&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,KS(this.units,"units"),this.activation=jR(e.activation),null!=e.useBias&&(this.useBias=e.useBias),this.kernelInitializer=w$(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=w$(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=cC(e.kernelConstraint),this.biasConstraint=cC(e.biasConstraint),this.kernelRegularizer=tA(e.kernelRegularizer),this.biasRegularizer=tA(e.biasRegularizer),this.activityRegularizer=tA(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){e=N$(e);const t=e[e.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){e=N$(e);const t=e.slice();return t[t.length-1]=this.units,t}call(e,t){return uu((()=>{this.invokeCallHook(e,t);const n=I$(e),r=JS(this.activation.getClassName());let s;return null!=r?s=BT(n,this.kernel.read(),r,this.bias?this.bias.read():null):(s=BT(n,this.kernel.read()),null!=this.bias&&(s=GT(s,this.bias.read())),null!=this.activation&&(s=this.activation.apply(s))),s}))}getConfig(){const e={units:this.units,activation:GR(this.activation),useBias:this.useBias,kernelInitializer:x$(this.kernelInitializer),biasInitializer:x$(this.biasInitializer),kernelRegularizer:QR(this.kernelRegularizer),biasRegularizer:QR(this.biasRegularizer),activityRegularizer:QR(this.activityRegularizer),kernelConstraint:uC(this.kernelConstraint),biasConstraint:uC(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}qA.className="Dense",qu(qA);class KA extends M${constructor(e){e=e||{},super(e),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=N$(e);for(const t of e.slice(1))if(null==t)throw new $S(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],vT(e,1)]}call(e,t){return uu((()=>{this.invokeCallHook(e,t);let n=I$(e);if("channelsFirst"===this.dataFormat&&n.rank>1){const e=[0];for(let t=2;t<n.rank;++t)e.push(t);e.push(1),n=nc(n,e)}return FT(n)}))}getConfig(){const e={};null!=this.dataFormat&&(e["dataFormat"]=this.dataFormat);const t=super.getConfig();return Object.assign(e,t),e}}KA.className="Flatten",qu(KA);class XA extends M${constructor(e){super(e),this.supportsMasking=!0,this.activation=jR(e.activation)}call(e,t){return uu((()=>{this.invokeCallHook(e,t);const n=I$(e);return this.activation.apply(n)}))}getConfig(){const e={activation:GR(this.activation)},t=super.getConfig();return Object.assign(e,t),e}}XA.className="Activation",qu(XA);class YA extends M${constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return uu((()=>(e=I$(e),RT(e,this.n))))}getConfig(){const e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}}YA.className="RepeatVector",qu(YA);class JA extends M${constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||null==e}fixUnknownDimension(e,t){const n="Total size of new array must be unchanged.",r=t.slice();let s=1,a=null;for(let o=0;o<r.length;++o){const e=r[o];if(this.isUnknown(e)){if(null!==a)throw new $S("Can only specifiy one unknown dimension.");a=o}else s*=e}const i=vT(e);if(null!==a){if(0===s||i%s!==0)throw new $S(n);r[a]=i/s}else if(i!==s)throw new $S(n);return r}computeOutputShape(e){let t=!1;for(let n=0;n<e.length;++n)if(this.isUnknown(e[n])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return uu((()=>{this.invokeCallHook(e,t);const n=I$(e),r=n.shape,s=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return Xh(n,s)}))}getConfig(){const e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}}JA.className="Reshape",qu(JA);class ZA extends M${constructor(e){if(super(e),null==e.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const t=NT(1,e.dims.length+1);if(!Te(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new A$({ndim:this.dims.length+1})]}computeOutputShape(e){e=N$(e);const t=e.slice();return this.dims.forEach(((n,r)=>{t[r+1]=e[n]})),t}call(e,t){return nc(I$(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}}ZA.className="Permute",qu(ZA);class QA extends M${constructor(e){super(null==e?{}:e),this.supportsMasking=!0,this.maskValue=null!=e?null==e.maskValue?0:e.maskValue:0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){const n=I$(e),r=-1;return fh(Cm(n,this.maskValue),r)}call(e,t){return uu((()=>{this.invokeCallHook(e,t);const n=I$(e),r=-1,s=!0,a=fh(Cm(n,this.maskValue),r,s),i=Cu(n,Xo(a,n.dtype));return i}))}}QA.className="Masking",qu(QA);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
class eF extends M${constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==e.batchInputShape&&null==e.inputShape){let t=null;null!=e.batchSize&&(t=e.batchSize),null==e.inputLength?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(OS(e.inputLength))}this.inputDim=e.inputDim,KS(this.inputDim,"inputDim"),this.outputDim=e.outputDim,KS(this.outputDim,"outputDim"),this.embeddingsInitializer=w$(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=tA(e.embeddingsRegularizer),this.activityRegularizer=tA(e.activityRegularizer),this.embeddingsConstraint=cC(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return uu((()=>this.maskZero?(e=I$(e),Cm(e,Du(e))):null))}computeOutputShape(e){if(e=N$(e),null==this.inputLength)return[...e,this.outputDim];const t=OS(this.inputLength);if(t.length!==e.length-1)throw new $S(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let n=0;for(let r=0;r<t.length;++r){const s=t[r],a=e[r+1];if(null!=s&&null!=a&&s!==a)throw new $S(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);null==s&&(t[n]=a),n++}}return[e[0],...t,this.outputDim]}call(e,t){return uu((()=>{this.invokeCallHook(e,t);let n=I$(e);"int32"!==n.dtype&&(n=CT(n,"int32"));const r=WT(this.embeddings.read(),Xh(n,[n.size]));return Xh(r,N$(this.computeOutputShape(n.shape)))}))}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:x$(this.embeddingsInitializer),embeddingsRegularizer:QR(this.embeddingsRegularizer),activityRegularizer:QR(this.activityRegularizer),embeddingsConstraint:uC(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}}eF.className="Embedding",qu(eF);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
class tF extends M${constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new CS}computeElementwiseOpOutputShape(e,t){if(null==e||null==t)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(0===t.length)return e;const n=e.slice(0,e.length-t.length);for(let r=0;r<t.length;++r){const s=e[e.length-t.length+r],a=t[r];if(null==s||null==a||s<0||a<0)n.push(null);else if(1===s)n.push(a);else if(1===a)n.push(s);else{if(s!==a)throw new $S("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));n.push(s)}}return n}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[N$(e)]),e.length<2)throw new $S(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(const s of e)null!=s&&null!==s[0]&&t.push(s[0]);if(t=GS(t),t.length>1)throw new $S(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let n=null==e[0]?null:e[0].slice(1);for(let s=1;s<e.length;++s){const t=null==e[s]?null:e[s].slice(1);n=this.computeElementwiseOpOutputShape(n,t)}const r=e.map((e=>e.length));-1===e.indexOf(null)&&1===GS(r).length?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return uu((()=>{if(this.reshapeRequired){const t=[],n=e.map((e=>e.rank));if(-1===n.indexOf(null)){const r=IT(n);for(let n of e){const e=n.rank;for(let t=0;t<r-e;++t)n=ET(n,1);t.push(n)}return this.mergeFunction(t)}{let n=!1;for(const a of e){const e=a.rank;if(null==e){const e=a.shape,r=e[0],s=e.slice(1).concat([r]);let i=Xh(a,[r].concat(vT(e.slice(1))));i=nc(i,[1,0]),i=Xh(i,s),t.push(i),n=!0}else if(e>1){const r=NT(1,e).concat([0]);t.push(nc(a,r)),n=!0}else t.push(a)}let r=this.mergeFunction(t);const s=r.rank;if(n)if(null==s){const e=r.shape,t=e.length,n=e[t-1],s=[n].concat(e.slice(0,e.length-1));r=Xh(nc(Xh(r,[-1,n]),[1,0]),s)}else if(s>1){const e=[s-1].concat(NT(0,s-1));r=nc(r,e)}return r}}return this.mergeFunction(e)}))}computeOutputShape(e){let t;t=null==e[0]?null:e[0].slice(1);for(let r=1;r<e.length;++r){const n=null==e[r]?null:e[r].slice(1);t=this.computeElementwiseOpOutputShape(t,n)}let n=[];for(const r of e)null!=r&&null!==r[0]&&n.push(r[0]);return n=GS(n),t=1===n.length?n.concat(t):[null].concat(t),t}computeMask(e,t){return uu((()=>{if(null==t)return null;if(!Array.isArray(t))throw new $S("`mask` should be an Array");if(!Array.isArray(e))throw new $S("`inputs` should be an Array");if(t.length!==e.length)throw new $S(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every((e=>null==e)))return null;t=t.map((e=>null==e?e:rf(e,0)));let n=t[0];for(let e=1;e<t.length-1;++e)n=qf(n,t[e]);return n}))}}class nF extends tF{constructor(e){super(e)}mergeFunction(e){return uu((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=ku(t,e[n]);return t}))}}nF.className="Add",qu(nF);class rF extends tF{constructor(e){super(e)}mergeFunction(e){return uu((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=Cu(t,e[n]);return t}))}}rF.className="Multiply",qu(rF);class sF extends tF{constructor(e){super(e)}mergeFunction(e){return uu((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=ku(t,e[n]);return Cu(1/e.length,t)}))}}sF.className="Average",qu(sF);class aF extends tF{constructor(e){super(e)}mergeFunction(e){return uu((()=>{let t=e[0];for(let n=1;n<e.length;++n)t=cl(t,e[n]);return t}))}}aF.className="Maximum",qu(aF);class iF extends tF{constructor(e){super(e)}mergeFunction(e){return uu((()=>{let t=e[0];for(let n=1;n<e.length;++n)t=gm(t,e[n]);return t}))}}iF.className="Minimum",qu(iF);class oF extends tF{constructor(e){super(e),this.DEFAULT_AXIS=-1,null==e&&(e={}),this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!Array.isArray(e)||!Array.isArray(e[0])||1===e.length)throw new $S("A `Concatenate` layer should be called on a list of at least 2 inputs");let t=!0;for(const r of e)if(null!=r){t=!1;break}if(t)return;const n=[];for(let r=0;r<e.length;++r){const t=e[r].slice();t.splice(this.axis,1);let s=!1;for(const e of n)if(Te(e,t)){s=!0;break}s||n.push(t)}if(n.length>1)throw new $S("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return uu((()=>MT(e,this.axis)))}computeOutputShape(e){if(!Array.isArray(e)||!Array.isArray(e[0]))throw new $S("A `Concatenate` layer should be called on a list of inputs.");const t=e,n=t[0].slice(),r=this.axis<0?n.length+this.axis:this.axis;for(const s of t.slice(1)){if(null==n[r]||null==s[r]){n[r]=null;break}n[r]+=s[r]}return n}computeMask(e,t){if(null==t)return null;if(!Array.isArray(t))throw new $S("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new $S("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new $S(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return uu((()=>{let n=!0;if(t.forEach((e=>{null==e||(n=!1)})),n)return null;const r=[];for(let a=0;a<e.length;++a)null==t[a]?r.push(Xo(Rm(e[a]),"bool")):t[a].rank<e[a].rank?r.push(rf(t[a],-1)):r.push(t[a]);const s=tp(r,this.axis);return ph(s,-1,!1)}))}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}function uF(e,t){while(e<0)e+=t;return e}function lF(e,t,n){if(e.shape.length>3||t.shape.length>3)throw new CS("batchDot is not implemented for tensors of 4D or higher rank yet");if(we(e.shape.length>=2,(()=>`batchDot requires the rank of x to be >= 2, but got ${e.shape.length}`)),we(e.shape.length>=2,(()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`)),"number"===typeof n&&(n=[n,n]),"complex64"===e.dtype||"complex64"===t.dtype)throw new CS("batchDot is not implemented for complex64-type Tensors yet.");const r=e.shape.length,s=t.shape.length;null==n&&(n=[r-1,s-2]);const a=n;return uu((()=>{let n,i;if(r>s){n=r-s;const e=[];for(let t=0;t<n;++t)e.push(1);t=Xh(t,t.shape.concat(e))}else if(s>r){n=s-r;const t=[];for(let e=0;e<n;++e)t.push(1);e=Xh(e,e.shape.concat(t))}else n=0;if(2===e.shape.length&&2===t.shape.length)i=a[0]===a[1]?Kd(Cu(e,t),a[0]):Kd(Cu(nc(e,[1,0]),t),a[1]);else{const n=a[0]!==e.shape.length-1,r=a[1]===t.shape.length-1;i=jl(e,t,n,r)}if(n>0){let e;e=r>s?r+s-3:r-1;const t=[];for(let r=e;r<e+n;++r)t.push(r);i=Iy(i,t)}return 1===i.shape.length&&(i=rf(i,1)),i}))}oF.className="Concatenate",qu(oF);class cF extends tF{constructor(e){super(e),this.axes=e.axes,this.normalize=null!=e.normalize&&e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){we(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const t=e[0],n=e[1];if(t.length>3||n.length>3)throw new CS("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(t,n);if(t[r[0]]!==n[r[1]])throw new $S(`Dimension incompatibility: ${t[r[0]]} !== ${n[r[1]]}`)}mergeFunction(e){if(2!==e.length)throw new $S(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t,n=e[0],r=e[1];return t=Array.isArray(this.axes)?this.axes.map(((t,n)=>uF(t,e[n].shape.length))):[uF(this.axes,n.shape.length),uF(this.axes,r.shape.length)],this.normalize&&(n=UC(n,t[0]),r=UC(r,t[1])),lF(n,r,t)}interpretAxes(e,t){let n;return n=Array.isArray(this.axes)?this.axes:[uF(this.axes,e.length),uF(this.axes,t.length)],n}computeOutputShape(e){we(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const t=e[0].slice(),n=e[1].slice();if(t.length>3||n.length>3)throw new CS("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(t,n);t.splice(r[0],1),n.splice(r[1],1),n.splice(0,1);const s=t.concat(n);return 1===s.length&&s.push(1),s}computeMask(e,t){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}}cF.className="Dot",qu(cF);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
class hF extends M${constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return uu((()=>{this.invokeCallHook(e,t);const n=I$(e),r=()=>ku(PT(n.shape,0,this.stddev),n),s=XT(r,(()=>n),t["training"]||!1);return s}))}}hF.className="GaussianNoise",qu(hF);class pF extends M${constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return uu((()=>{this.invokeCallHook(e,t);const n=I$(e);if(this.rate>0&&this.rate<1){const e=()=>{const e=Math.sqrt(this.rate/(1-this.rate));return Cu(n,PT(n.shape,1,e))};return XT(e,(()=>n),t["training"]||!1)}return n}))}}pF.className="GaussianDropout",qu(pF);class dF extends M${constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||I$(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return uu((()=>{if(this.rate<1&&this.rate>0){const n=this._getNoiseShape(e),r=()=>{const t=I$(e),r=1.6732632423543772,s=1.0507009873554805,a=-r*s;let i=bf(bg(n),this.rate);i=CT(i,"float32");const o=((1-this.rate)*(1+this.rate*a**2))**-.5,u=-o*a*this.rate,l=ku(Cu(t,i),Cu(ku(i,-1),a));return ku(Cu(l,o),u)};return XT(r,(()=>I$(e)),t["training"]||!1)}return e}))}}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function fF(e,t,n,r,s,a=.001){let i;if(2===e.rank)i=gp(e,t,n,r,s,a);else if(3===e.rank)i=bp(e,t,n,r,s,a);else{if(4!==e.rank)throw new CS(`batchNormalization is not implemented for array of rank ${e.rank} yet`);i=wp(e,t,n,r,s,a)}return i}function mF(e,t,n,r,s=.001){return uu((()=>{const a=km(e,r),i=a.mean,o=a.variance,u=fF(e,i,o,n,t,s);return[u,i,o]}))}function gF(e,t,n,r,s=.001){return uu((()=>{const a=km(e,r),i=a.mean,o=a.variance,u=[];for(const t of NT(0,e.rank))-1!==r.indexOf(t)?u.push(1):u.push(e.shape[t]);const l=Xh(i,u),c=Xh(o,u),h=null==t?null:Xh(t,u),p=null==n?null:Xh(n,u),d=fF(e,l,c,p,h,s);return[d,i,o]}))}function yF(e,t,n,r,s=.001){return Te(r.slice().sort(),NT(0,e.rank-1))?mF(e,t,n,r,s):gF(e,t,n,r,s)}dF.className="AlphaDropout",qu(dF);class bF extends M${constructor(e){null==e&&(e={}),super(e),this.supportsMasking=!0,this.axis=null==e.axis?-1:e.axis,this.momentum=null==e.momentum?.99:e.momentum,this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=w$(e.betaInitializer||"zeros"),this.gammaInitializer=w$(e.gammaInitializer||"ones"),this.movingMeanInitializer=w$(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=w$(e.movingVarianceInitializer||"ones"),this.betaConstraint=cC(e.betaConstraint),this.gammaConstraint=cC(e.gammaConstraint),this.betaRegularizer=tA(e.betaRegularizer),this.gammaRegularizer=tA(e.gammaRegularizer)}build(e){e=N$(e);const t=this.axis>=0?this.axis:this.axis+e.length,n=e[t];if(null==n)throw new $S(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new A$({ndim:e.length,axes:{[t]:n}})];const r=[n];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return uu((()=>{const n=null!=t["training"]&&t["training"],r=I$(e),s=r.shape,a=s.length,i=NT(0,a),o=this.axis>=0?this.axis:this.axis+a;i.splice(o,1);const u=AS(1,a);u[o]=s[o];const l=i.slice();l.sort();const c=!Te(l,NT(0,a).slice(0,a-1)),h=()=>{if(c){const e=Xh(this.movingMean.read(),u),t=Xh(this.movingVariance.read(),u),n=this.center?Xh(this.beta.read(),u):null,s=this.scale?Xh(this.gamma.read(),u):null;return fF(r,e,t,n,s,this.epsilon)}return fF(r,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)};if(!n)return h();const[p,d,f]=yF(r,this.gamma.read(),this.beta.read(),i,this.epsilon),m=(e,t,n)=>{uu((()=>{const r=1-n,s=e.read(),a=Cu(nl(s,t),r);e.write(nl(s,a))}))},g=()=>{m(this.movingMean,d,this.momentum),m(this.movingVariance,f,this.momentum)};return g(),p}))}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:x$(this.betaInitializer),gammaInitializer:x$(this.gammaInitializer),movingMeanInitializer:x$(this.movingMeanInitializer),movingVarianceInitializer:x$(this.movingVarianceInitializer),betaRegularizer:QR(this.betaRegularizer),gammaRegularizer:QR(this.gammaRegularizer),betaConstraint:uC(this.betaConstraint),gammaConstraint:uC(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}}bF.className="BatchNormalization",qu(bF);class xF extends M${constructor(e){if(null==e&&(e={}),super(e),this.axis=null==e.axis?-1:e.axis,"number"===typeof this.axis){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else{if(!Array.isArray(this.axis))throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);for(const e of this.axis)if(!Number.isInteger(e))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=w$(e.betaInitializer||"zeros"),this.gammaInitializer=w$(e.gammaInitializer||"ones"),this.betaRegularizer=tA(e.betaRegularizer),this.gammaRegularizer=tA(e.gammaRegularizer),this.supportsMasking=!0}build(e){e=N$(e);const t=e.length;"number"===typeof this.axis&&(this.axis=[this.axis]);for(let s=0;s<this.axis.length;++s)this.axis[s]<0&&(this.axis[s]+=t);for(const s of this.axis)if(s<0||s>=t)throw new Error(`Invalid axis: ${s}`);if(this.axis.length!==GS(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const n=this.axis.map((t=>e[t])),r=!0;this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,r):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,r):this.beta=null,this.built=!0}call(e,t){const n=I$(e),r=n.shape,s=r.length;return uu((()=>{const e=!0;let{mean:t,variance:a}=km(n,this.axis,e);const i=AS(1,s);for(const n of this.axis)i[n]=r[n];const o=e=>null!=e&&e.shape.length!==s?Xh(e,i):e;let u=this.scale?o(this.gamma.read()):null,l=this.center?o(this.beta.read()):null;const c=[],h=[];for(let n=0;n<s;++n)-1!==this.axis.indexOf(n)?(c.push(r[n]),h.push(1)):(c.push(1),h.push(r[n]));return t=uf(t,c),a=uf(a,c),null!=u&&(u=uf(u,h)),null!=l&&(l=uf(l,h)),fF(n,t,a,l,u,this.epsilon)}))}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:x$(this.betaInitializer),gammaInitializer:x$(this.gammaInitializer),betaRegularizer:QR(this.betaRegularizer),gammaRegularizer:QR(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}}function wF(e,t,n){return uu((()=>{if(4!==e.rank)throw new $S(`temporalPadding expects input tensor to be 4-D, but received a ${e.rank}-D tensor.`);if(null==t&&(t=[[1,1],[1,1]]),2!==t.length||2!==t[0].length||2!==t[1].length)throw new $S("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==n&&(n=$T()),"channelsLast"!==n&&"channelsFirst"!==n)throw new $S(`Unknown data format: ${n}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let r;return r="channelsFirst"===n?[[0,0],[0,0],t[0],t[1]]:[[0,0],t[0],t[1],[0,0]],Dm(e,r)}))}xF.className="LayerNormalization",qu(xF);class vF extends M${constructor(e){if(null==e&&(e={}),super(e),this.dataFormat=null==e.dataFormat?$T():e.dataFormat,null==e.padding)this.padding=[[1,1],[1,1]];else if("number"===typeof e.padding)this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,2!==e.padding.length)throw new $S(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,n;if("number"===typeof e.padding[0])t=[e.padding[0],e.padding[0]],n=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,2!==e.padding[0].length)throw new $S(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],2!==e.padding[1].length)throw new $S(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);n=e.padding[1]}this.padding=[t,n]}this.inputSpec=[new A$({ndim:4})]}computeOutputShape(e){let t,n;return e=N$(e),"channelsFirst"===this.dataFormat?(t=null!=e[2]&&e[2]>=0?e[2]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[3]&&e[3]>=0?e[3]+this.padding[1][0]+this.padding[1][1]:null,[e[0],e[1],t,n]):(t=null!=e[1]&&e[1]>=0?e[1]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[2]&&e[2]>=0?e[2]+this.padding[1][0]+this.padding[1][1]:null,[e[0],t,n,e[3]])}call(e,t){return uu((()=>wF(I$(e),this.padding,this.dataFormat)))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function kF(e,t,n,r,s,a){return uu((()=>{let i;uT(s),hT(a),cT(r),null==n&&(n=[1,1]),null==r&&(r="valid"),null==s&&(s=$T()),null==a&&(a="max"),e=hA(e,s);const o="same"===r?"same":"valid";return i="max"===a?am(e,t,n,o):Jh(e,t,n,o),"channelsFirst"===s&&(i=nc(i,[0,3,1,2])),i}))}function IF(e,t,n,r,s,a){return uu((()=>{let i;uT(s),hT(a),cT(r),null==n&&(n=[1,1,1]),null==r&&(r="valid"),null==s&&(s=$T()),null==a&&(a="max"),e=pA(e,s);const o="same"===r?"same":"valid";return i="max"===a?om(e,t,n,o):Qh(e,t,n,o),"channelsFirst"===s&&(i=nc(i,[0,4,1,2,3])),i}))}vF.className="ZeroPadding2D",qu(vF);class NF extends M${constructor(e){if(null==e.poolSize&&(e.poolSize=2),super(e),"number"===typeof e.poolSize)this.poolSize=[e.poolSize];else{if(!Array.isArray(e.poolSize)||1!==e.poolSize.length||"number"!==typeof e.poolSize[0])throw new $S(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);this.poolSize=e.poolSize}if(KS(this.poolSize,"poolSize"),null==e.strides)this.strides=this.poolSize;else if("number"===typeof e.strides)this.strides=[e.strides];else{if(!Array.isArray(e.strides)||1!==e.strides.length||"number"!==typeof e.strides[0])throw new $S(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);this.strides=e.strides}KS(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,cT(this.padding),this.inputSpec=[new A$({ndim:3})]}computeOutputShape(e){e=N$(e);const t=lA(e[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return uu((()=>{this.invokeCallHook(e,t),e=ET(I$(e),2);const n=this.poolingFunction(I$(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return Iy(n,[2])}))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}}class SF extends NF{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return uT(s),cT(r),kF(e,t,n,r,s,"max")}}SF.className="MaxPooling1D",qu(SF);class TF extends NF{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return uT(s),cT(r),kF(e,t,n,r,s,"avg")}}TF.className="AveragePooling1D",qu(TF);class $F extends M${constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(2!==e.strides.length)throw new $S(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];KS(this.poolSize,"poolSize"),KS(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,uT(this.dataFormat),cT(this.padding),this.inputSpec=[new A$({ndim:4})]}computeOutputShape(e){e=N$(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2];return t=lA(t,this.poolSize[0],this.padding,this.strides[0]),n=lA(n,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n]:[e[0],t,n,e[3]]}call(e,t){return uu((()=>(this.invokeCallHook(e,t),this.poolingFunction(I$(e),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class CF extends $F{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return uT(s),cT(r),kF(e,t,n,r,s,"max")}}CF.className="MaxPooling2D",qu(CF);class EF extends $F{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return uT(s),cT(r),kF(e,t,n,r,s,"avg")}}EF.className="AveragePooling2D",qu(EF);class RF extends M${constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(3!==e.strides.length)throw new $S(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];KS(this.poolSize,"poolSize"),KS(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,uT(this.dataFormat),cT(this.padding),this.inputSpec=[new A$({ndim:5})]}computeOutputShape(e){e=N$(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],r="channelsFirst"===this.dataFormat?e[4]:e[3];return t=lA(t,this.poolSize[0],this.padding,this.strides[0]),n=lA(n,this.poolSize[1],this.padding,this.strides[1]),r=lA(r,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n,r]:[e[0],t,n,r,e[4]]}call(e,t){return uu((()=>(this.invokeCallHook(e,t),this.poolingFunction(I$(e),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class AF extends RF{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return uT(s),cT(r),IF(e,t,n,r,s,"max")}}AF.className="MaxPooling3D",qu(AF);class FF extends RF{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return uT(s),cT(r),IF(e,t,n,r,s,"avg")}}FF.className="AveragePooling3D",qu(FF);class _F extends M${constructor(e){super(e),this.inputSpec=[new A$({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new CS}}class DF extends _F{constructor(e){super(e||{})}call(e,t){return uu((()=>{const t=I$(e);return hm(t,1)}))}}DF.className="GlobalAveragePooling1D",qu(DF);class OF extends _F{constructor(e){super(e||{})}call(e,t){return uu((()=>{const t=I$(e);return Gd(t,1)}))}}OF.className="GlobalMaxPooling1D",qu(OF);class MF extends M${constructor(e){super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,uT(this.dataFormat),this.inputSpec=[new A$({ndim:4})]}computeOutputShape(e){return"channelsLast"===this.dataFormat?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new CS}getConfig(){const e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class LF extends MF{call(e,t){return uu((()=>{const t=I$(e);return"channelsLast"===this.dataFormat?hm(t,[1,2]):hm(t,[2,3])}))}}LF.className="GlobalAveragePooling2D",qu(LF);class zF extends MF{call(e,t){return uu((()=>{const t=I$(e);return"channelsLast"===this.dataFormat?Gd(t,[1,2]):Gd(t,[2,3])}))}}zF.className="GlobalMaxPooling2D",qu(zF);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
class PF extends M${constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(e){null!=this.layer&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){const e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,n={}){const r=t["layer"],s=VC(r,n);delete t["layer"];const a={layer:s};return Object.assign(a,t),new e(a)}}class BF extends PF{constructor(e){super(e),this.supportsMasking=!0}build(e){if(e=N$(e),e.length<3)throw new $S(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){e=N$(e);const t=[e[0]].concat(e.slice(2)),n=this.layer.computeOutputShape(t),r=e[1];return[n[0],r].concat(n.slice(1))}call(e,t){return uu((()=>{e=I$(e);const n=(e,n)=>{const r=I$(this.layer.call(e,t));return[r,[]]},r=RA(n,e,[],!1,null,null,!1,!0),s=r[1];return s}))}}function WF(e){jS(iT,"BidirectionalMergeMode",e)}BF.className="TimeDistributed",qu(BF);const VF="concat";class UF extends PF{constructor(e){super(e);const t=e.layer.getConfig(),n={};n["className"]=e.layer.getClassName(),n["config"]=t,this.forwardLayer=VC(n),t["goBackwards"]=!0!==t["goBackwards"];const r={};if(r["className"]=e.layer.getClassName(),r["config"]=t,this.backwardLayer=VC(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===e.mergeMode?VF:e.mergeMode,WF(this.mergeMode),e.weights)throw new CS("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,null!=this.forwardLayer&&(this.forwardLayer.trainable=e),null!=this.backwardLayer&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const t=e.length,n=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,n)),this.backwardLayer.setWeights(e.slice(n))}computeOutputShape(e){let t,n,r,s=this.forwardLayer.computeOutputShape(e);return Array.isArray(s)&&Array.isArray(s[0])||(s=[s]),this.returnState?(r=s.slice(1),t=s[0]):t=s[0],"concat"===this.mergeMode?(t[t.length-1]*=2,n=[t]):n=null==this.mergeMode?[t,t.slice()]:[t],this.returnState?null==this.mergeMode?n.concat(r).concat(r.slice()):[t].concat(r).concat(r.slice()):DS(n)}apply(e,t){let n=null==t?null:t["initialState"],r=null==t?null:t["constants"];null==t&&(t={});const s=EA(e,n,r,this.numConstants);if(e=s.inputs,n=s.initialState,r=s.constants,Array.isArray(e)&&(n=e.slice(1),e=e[0]),(null==n||0===n.length)&&null==r)return super.apply(e,t);const a=[],i=[];if(null!=n){const e=n.length;if(e%2>0)throw new $S("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t["initialState"]=n,a.push(...n);const r=n.map((e=>new A$({shape:e.shape})));this.forwardLayer.stateSpec=r.slice(0,e/2),this.backwardLayer.stateSpec=r.slice(e/2),i.push(...r)}if(null!=r)throw new CS("Support for constants in Bidirectional layers is not implemented yet.");const o=a[0]instanceof F$;for(const u of a)if(u instanceof F$!==o)throw new $S("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(o){const n=[e].concat(a),r=this.inputSpec.concat(i),s=this.inputSpec;this.inputSpec=r;const o=super.apply(n,t);return this.inputSpec=s,o}return super.apply(e,t)}call(e,t){return uu((()=>{const n=t["initialState"];let r,s,a,i;if(null==n)r=this.forwardLayer.call(e,t),s=this.backwardLayer.call(e,t);else{const a=n.slice(0,n.length/2),i=n.slice(n.length/2);r=this.forwardLayer.call(e,Object.assign(t,{initialState:a})),s=this.backwardLayer.call(e,Object.assign(t,{initialState:i}))}return this.returnState&&(Array.isArray(r)&&(a=r.slice(1).concat(s.slice(1))),r=r[0],s=s[0]),this.returnSequences&&(s=Eg(s,1)),"concat"===this.mergeMode?i=MT([r,s]):"sum"===this.mergeMode?i=ku(r,s):"ave"===this.mergeMode?i=Cu(.5,ku(r,s)):"mul"===this.mergeMode?i=Cu(r,s):null==this.mergeMode&&(i=[r,s]),this.returnState?null==this.mergeMode?i.concat(a):[i].concat(a):i}))}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){fT(this.forwardLayer.name,(()=>{this.forwardLayer.build(e)})),fT(this.backwardLayer.name,(()=>{this.backwardLayer.build(e)})),this.built=!0}computeMask(e,t){let n;if(Array.isArray(t)&&(t=t[0]),n=this.returnSequences?null==this.mergeMode?[t,t]:t:null==this.mergeMode?[null,null]:null,this.returnState){const e=this.forwardLayer.states,t=e.map((e=>null));return Array.isArray(n)?n.concat(t).concat(t):[n].concat(t).concat(t)}return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(e),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){const n=VC(t["layer"]);if(delete t["layer"],null!=t["numConstants"])throw new CS("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const r=t;return r["layer"]=n,new e(r)}}UF.className="Bidirectional",qu(UF);
/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
class GF extends M${constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){const e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return uu((()=>(e=I$(e),"float32"!==e.dtype&&(e=CT(e,"float32")),ku(Cu(e,this.scale),this.offset))))}}GF.className="Rescaling",qu(GF);
/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
const{resizeBilinear:HF,cropAndResize:jF}=Iw;class qF extends M${constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,n,r,s,a,i,o){return uu((()=>{let u,l=!1;const c=t/a,h=n/i,p=(r+t)/a,d=(s+n)/i,f=[c,h,p,d],m=[];3===e.rank?(l=!0,u=Sy([e])):u=e;for(let e=0;e<u.shape[0];e++)m.push(f);const g=Di(m,[m.length,4]),y=vg(0,m.length,1,"int32"),b=[r,s],x=jF(u,g,y,b,"nearest");return CT(l?I$(Ky(x)):x,o)}))}upsize(e,t,n,r){return uu((()=>{const s=HF(e,[t,n]);return CT(s,r)}))}call(e,t){return uu((()=>{const t=I$(e),n=t.dtype,r=t.shape,s=r[r.length-3],a=r[r.length-2];let i=0;s!==this.height&&(i=Math.floor((s-this.height)/2));let o=0;return a!==this.width&&(o=Math.floor((a-this.width)/2),0===o&&(o=1)),i>=0&&o>=0?this.centerCrop(t,i,o,this.height,this.width,s,a,n):this.upsize(e,this.height,this.width,n)}))}getConfig(){const e={height:this.height,width:this.width},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=N$(e);const t=e.length-3,n=e.length-2;return e[t]=this.height,e[n]=this.width,e}}
/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function KF(e,t,n,r){let s=I$(e);if("int32"!==s.dtype&&(s=CT(s,"int32")),"int"===t)return s;const a=s.shape;if(0===s.rank&&(s=rf(s,-1)),"oneHot"===t&&1!==s.shape[s.shape.length-1]&&(s=rf(s,-1)),s.rank>2)throw new $S(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${a} which would result in output rank ${s.rank}.`);const i=["multiHot","oneHot"].includes(t),o=s;let u;if(u=cd(o,"undefined"!==typeof r&&"count"===t?r:[],n,i),"tfIdf"!==t)return u;if(r)return Cu(u,r);throw new $S("When outputMode is 'tfIdf', weights must be provided.")}qF.className="CenterCrop",qu(qF);
/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
class XF extends M${constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){const e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return e=N$(e),null==e?[this.numTokens]:"oneHot"===this.outputMode&&1!==e[e.length-1]?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return uu((()=>{let n;if(e=I$(e),"int32"!==e.dtype&&(e=CT(e,"int32")),"undefined"!==typeof t["countWeights"]){if("count"!==this.outputMode)throw new $S(`countWeights is not used when outputMode !== count.\n              Received countWeights=${t["countWeights"]}`);n=I$(t["countWeights"])}const r=Gd(e),s=jd(e),a=gf(this.numTokens,r).bufferSync().get(0),i=bf(s,0).bufferSync().get(0);if(!a||!i)throw new $S(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return KF(e,this.outputMode,this.numTokens,n)}))}}XF.className="CategoryEncoding",qu(XF);
/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
const YF=["bilinear","nearest"],JF=new Set(YF);class ZF extends M${constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation){if(!JF.has(e.interpolation))throw new $S(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);this.interpolation=e.interpolation}else this.interpolation="bilinear";this.cropToAspectRatio=Boolean(e.cropToAspectRatio)}computeOutputShape(e){e=N$(e);const t=e[2];return[this.height,this.width,t]}getConfig(){const e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return uu((()=>{const t=[this.height,this.width];if("bilinear"===this.interpolation)return Iw.resizeBilinear(e,t,!this.cropToAspectRatio);if("nearest"===this.interpolation)return Iw.resizeNearestNeighbor(e,t,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...JF]} are supported`)}))}}ZF.className="Resizing",qu(ZF);
/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
class QF{constructor(e){this.seed=e}next(){if(void 0!==this.seed)return this.seed++}}QF.className="RandomSeed";
/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
class e_ extends M${constructor(e){super(e),this.randomGenerator=new QF(e.seed)}getConfig(){const e={seed:this.randomGenerator.seed},t=super.getConfig();return Object.assign(e,t),e}}e_.className="BaseRandomLayer";
/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
const t_=["bilinear","nearest"],n_=new Set(t_);class r_ extends e_{constructor(e){super(e);const{factor:t,interpolation:n="bilinear"}=e;if(this.factor=t,Array.isArray(this.factor)&&2===this.factor.length)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else{if(Array.isArray(this.factor)||!(this.factor>0))throw new $S(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);this.widthLower=-this.factor,this.widthUpper=this.factor}if(this.widthLower<-1||this.widthUpper<-1)throw new $S(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new $S(`factor cannot have upper bound less than lower bound.\n        Got upper bound: ${this.widthUpper}.\n        Got lower bound: ${this.widthLower}\n      `);if(n){if(!n_.has(n))throw new $S(`Invalid interpolation parameter: ${n} is not implemented`);this.interpolation=n}}getConfig(){const e={factor:this.factor,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=N$(e);const t=e[2];return[this.imgHeight,-1,t]}call(e,t){return uu((()=>{const t=I$(e);this.imgHeight=t.shape[t.shape.length-3];const n=t.shape[t.shape.length-2];this.widthFactor=bg([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let r=this.widthFactor.dataSync()[0]*n;r=Math.round(r);const s=[this.imgHeight,r];switch(this.interpolation){case"bilinear":return Iw.resizeBilinear(e,s);case"nearest":return Iw.resizeNearestNeighbor(e,s);default:throw new Error(`Interpolation is ${this.interpolation}\n          but only ${[...n_]} are supported`)}}))}}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function s_(e){return new V$(e)}function a_(e){return new aA(e)}function i_(e){return new nA(e)}function o_(e){return new rA(e)}function u_(e){return new sA(e)}function l_(e){return new oA(e)}function c_(e){return new iA(e)}function h_(e){return new NA(e)}function p_(e){return new bA(e)}function d_(e){return new wA(e)}function f_(e){return new xA(e)}function m_(e){return new vA(e)}function g_(e){return new IA(e)}function y_(e){return new SA(e)}function b_(e){return new TA(e)}function x_(e){return new CA(e)}function w_(e){return new XA(e)}function v_(e){return new qA(e)}function k_(e){return new HA(e)}function I_(e){return new jA(e)}function N_(e){return new KA(e)}function S_(e){return new YA(e)}function T_(e){return new JA(e)}function $_(e){return new ZA(e)}function C_(e){return new eF(e)}function E_(e){return new nF(e)}function R_(e){return new sF(e)}function A_(e){return new oF(e)}function F_(e){return new aF(e)}function __(e){return new iF(e)}function D_(e){return new rF(e)}function O_(e){return new cF(e)}function M_(e){return new bF(e)}function L_(e){return new xF(e)}function z_(e){return new vF(e)}function P_(e){return new TF(e)}function B_(e){return P_(e)}function W_(e){return P_(e)}function V_(e){return new EF(e)}function U_(e){return V_(e)}function G_(e){return V_(e)}function H_(e){return new FF(e)}function j_(e){return H_(e)}function q_(e){return H_(e)}function K_(e){return new DF(e)}function X_(e){return new LF(e)}function Y_(e){return new OF(e)}function J_(e){return new zF(e)}function Z_(e){return new SF(e)}function Q_(e){return new CF(e)}function eD(e){return new AF(e)}function tD(e){return new MA(e)}function nD(e){return new OA(e)}function rD(e){return new zA(e)}function sD(e){return new LA(e)}function aD(e){return new DA(e)}function iD(e){return new _A(e)}function oD(e){return new GA(e)}function uD(e){return new UA(e)}function lD(e){return new AA(e)}function cD(e){return new PA(e)}function hD(e){return new UF(e)}function pD(e){return new BF(e)}r_.className="RandomWidth",qu(r_);const dD=Y_,fD=J_,mD=Z_,gD=Q_;function yD(e){return new hF(e)}function bD(e){return new pF(e)}function xD(e){return new dF(e)}function wD(e){return new QA(e)}function vD(e){return new GF(e)}function kD(e){return new qF(e)}function ID(e){return new ZF(e)}function ND(e){return new XF(e)}function SD(e){return new r_(e)}function TD(e,t){return oE(e,t)}function $D(e,t){return fE(e,t)}function CD(e,t){return mE(e,t)}function ED(e,t){return uE(e,t)}function RD(e,t){return kE(e,t)}function AD(e,t){return pE(e,t)}function FD(e,t){return dE(e,t)}function _D(e,t){return sE(e,t)}function DD(e,t){return HC(e,t)}function OD(e,t){return jC(e,t)}function MD(e,t){return jC(e,t)}function LD(e,t){return jC(e,t)}function zD(e,t){return GC(e,t)}function PD(e,t){return GC(e,t)}function BD(e,t){return GC(e,t)}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function WD(e){return new XR(e)}function VD(e){return YR(e)}function UD(e){return JR(e)}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
class GD extends DC{constructor(){super(...arguments),this.model=null}setModel(e){if(!(e instanceof bR))throw new Error("model must be a LayersModel, not some other Container");this.model=e}}function HD(e,t){return e<t}function jD(e,t){return e>t}class qD extends GD{constructor(e){if(super(),null==e&&(e={}),e.restoreBestWeights)throw new CS("restoreBestWeights = True is not implemented in EarlyStopping yet.");this.monitor=e.monitor||"val_loss",this.minDelta=Math.abs(e.minDelta||0),this.patience=e.patience||0,this.verbose=e.verbose||0,this.mode=e.mode||"auto",this.baseline=e.baseline,-1===["auto","min","max"].indexOf(this.mode)&&(console.warn(`EarlyStopping mode '${this.mode}' is invalid. Falling back to mode 'auto'.`),this.mode="auto"),"min"===this.mode?this.monitorFunc=HD:"max"===this.mode||-1!==this.monitor.indexOf("acc")?this.monitorFunc=jD:this.monitorFunc=HD,this.monitorFunc===HD&&(this.minDelta*=-1)}async onTrainBegin(e){this.wait=0,this.stoppedEpoch=0,null!=this.baseline?this.best=this.baseline:this.best=this.monitorFunc===HD?1/0:-1/0}async onEpochEnd(e,t){await RC(t);const n=this.getMonitorValue(t);null!=n&&(this.monitorFunc(n-this.minDelta,this.best)?(this.best=n,this.wait=0):(this.wait++,this.wait>=this.patience&&(this.stoppedEpoch=e,this.model.stopTraining=!0)))}async onTrainEnd(e){this.stoppedEpoch>0&&this.verbose&&console.log(`Epoch ${this.stoppedEpoch}: early stopping.`)}getMonitorValue(e){null==e&&(e={});const t=e[this.monitor];return null==t&&console.warn(`Metric for EarlyStopping ${this.monitor} is not available. Available metrics are: ${Object.keys(e)}`),t}}function KD(e){return new qD(e)}const XD={earlyStopping:KD},YD=ht();
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
var JD,ZD;YD.registerFlag("KEEP_INTERMEDIATE_TENSORS",(()=>!1),(e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")})),function(e){e[e["DT_INVALID"]=0]="DT_INVALID",e[e["DT_FLOAT"]=1]="DT_FLOAT",e[e["DT_DOUBLE"]=2]="DT_DOUBLE",e[e["DT_INT32"]=3]="DT_INT32",e[e["DT_UINT8"]=4]="DT_UINT8",e[e["DT_INT16"]=5]="DT_INT16",e[e["DT_INT8"]=6]="DT_INT8",e[e["DT_STRING"]=7]="DT_STRING",e[e["DT_COMPLEX64"]=8]="DT_COMPLEX64",e[e["DT_INT64"]=9]="DT_INT64",e[e["DT_BOOL"]=10]="DT_BOOL",e[e["DT_QINT8"]=11]="DT_QINT8",e[e["DT_QUINT8"]=12]="DT_QUINT8",e[e["DT_QINT32"]=13]="DT_QINT32",e[e["DT_BFLOAT16"]=14]="DT_BFLOAT16",e[e["DT_QINT16"]=15]="DT_QINT16",e[e["DT_QUINT16"]=16]="DT_QUINT16",e[e["DT_UINT16"]=17]="DT_UINT16",e[e["DT_COMPLEX128"]=18]="DT_COMPLEX128",e[e["DT_HALF"]=19]="DT_HALF",e[e["DT_RESOURCE"]=20]="DT_RESOURCE",e[e["DT_VARIANT"]=21]="DT_VARIANT",e[e["DT_UINT32"]=22]="DT_UINT32",e[e["DT_UINT64"]=23]="DT_UINT64",e[e["DT_FLOAT_REF"]=101]="DT_FLOAT_REF",e[e["DT_DOUBLE_REF"]=102]="DT_DOUBLE_REF",e[e["DT_INT32_REF"]=103]="DT_INT32_REF",e[e["DT_UINT8_REF"]=104]="DT_UINT8_REF",e[e["DT_INT16_REF"]=105]="DT_INT16_REF",e[e["DT_INT8_REF"]=106]="DT_INT8_REF",e[e["DT_STRING_REF"]=107]="DT_STRING_REF",e[e["DT_COMPLEX64_REF"]=108]="DT_COMPLEX64_REF",e[e["DT_INT64_REF"]=109]="DT_INT64_REF",e[e["DT_BOOL_REF"]=110]="DT_BOOL_REF",e[e["DT_QINT8_REF"]=111]="DT_QINT8_REF",e[e["DT_QUINT8_REF"]=112]="DT_QUINT8_REF",e[e["DT_QINT32_REF"]=113]="DT_QINT32_REF",e[e["DT_BFLOAT16_REF"]=114]="DT_BFLOAT16_REF",e[e["DT_QINT16_REF"]=115]="DT_QINT16_REF",e[e["DT_QUINT16_REF"]=116]="DT_QUINT16_REF",e[e["DT_UINT16_REF"]=117]="DT_UINT16_REF",e[e["DT_COMPLEX128_REF"]=118]="DT_COMPLEX128_REF",e[e["DT_HALF_REF"]=119]="DT_HALF_REF",e[e["DT_RESOURCE_REF"]=120]="DT_RESOURCE_REF",e[e["DT_VARIANT_REF"]=121]="DT_VARIANT_REF",e[e["DT_UINT32_REF"]=122]="DT_UINT32_REF",e[e["DT_UINT64_REF"]=123]="DT_UINT64_REF"}(JD||(JD={})),function(e){let t;(function(e){e[e["LEGACY"]=0]="LEGACY",e[e["V1"]=1]="V1",e[e["V2"]=2]="V2"})(t=e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))}(ZD||(ZD={}));
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const QD={};function eO(e,t){const n={tfOpName:e,category:"custom",inputs:[],attrs:[],customExecutor:t};QD[e]=n}function tO(e){return QD[e]}function nO(e){delete QD[e]}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function rO(e,t,n,r,s){const a=t.inputParams[e];if(a&&void 0!==a.inputIndexStart){const e=a.inputIndexStart,i=0===a.inputIndexEnd?void 0:void 0===a.inputIndexEnd?e+1:a.inputIndexEnd,o=e<0?t.inputNames.length+e:e;if("tensor"===a.type)return sO(t.inputNames[o],n,r,s);if("tensors"===a.type){const a=t.inputs.slice(e,i),o=t.inputNames.slice(e,i).filter(((e,t)=>{var n;return"NoOp"!==(null===(n=a[t])||void 0===n?void 0:n.op)}));return o.map((e=>sO(e,n,r,s)))}const u=sO(t.inputNames[o],n,r,s),l=u.dataSync();return"number"===a.type?l[0]:Je(u.shape,l)}const i=t.attrParams[e];return i&&i.value}function sO(e,t,n,r){const[s,a]=uO(e,n);if(null!=r){const e=r.getHashTableHandleByName(s);if(null!=e)return e}const i=n.currentContextIds.find((e=>!!t[oO(s,e)]));return void 0!==i?t[oO(s,i)][a]:void 0}function aO(e,t,n){return t[oO(e,n.currentContextId)]}function iO(e,t){const[n,r,s]=uO(e,t);return[oO(n,t&&t.currentContextId),r,s]}function oO(e,t){return t?`${e}-${t}`:e}function uO(e,t){if(""===e)return["",0,void 0];const n=null!=t&&null!=t.parseNodeNameCache;if(n){const n=t.parseNodeNameCache.get(e);if(null!=n)return n}const r=e.split(":");let s;if(1===r.length)s=[e,0,void 0];else{const e=r[0],t=3===r.length?r[1]:void 0,n=Number(r[r.length-1]);s=[e,n,t]}return n&&t.parseNodeNameCache.set(e,s),s}function lO(e,t,n){let r=rO("pad",e,t,n);if("explicit"===r){r=rO("explicitPaddings",e,t,n);const s=[[0,0],[0,0],[0,0],[0,0]];for(let e=0;e<4;e++)s[e][0]=r[2*e],s[e][1]=r[2*e+1];return s}return r}function cO(e){return e.kept?e:Jo(e)}
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const hO=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],pO=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],dO=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],fO=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],mO=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],gO=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],yO=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],bO=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],xO=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],wO=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],vO=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],kO=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],IO=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],NO=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],SO=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],TO=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],$O=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],CO=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],EO=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class RO{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[S,T,$,C,E,R,A,F,_,D,O,M,L,z,P,B,W,V,U],t=[].concat(...e.map((e=>e.json)));this.opMappers=t.reduce(((e,t)=>(e[t.tfOpName]=t,e)),{})}transformGraph(e,t={}){const n=e.node,r=[],s=[],a=[],i=n.reduce(((e,t)=>(e[t.name]=this.mapNode(t),t.op.startsWith("Placeholder")?r.push(e[t.name]):"Const"===t.op?s.push(e[t.name]):null!=t.input&&0!==t.input.length||a.push(e[t.name]),e)),{});let o=[];const u=[];let l={},c={};null!=t&&(l=this.mapSignatureEntries(t.inputs),c=this.mapSignatureEntries(t.outputs));const h=Object.keys(i);h.forEach((e=>{const t=i[e];t.inputNames.forEach(((e,n)=>{const[r,,s]=iO(e),a=i[r];if(null!=a.outputs){const e=a.outputs.indexOf(s);if(-1!==e){const s=`${r}:${e}`;t.inputNames[n]=s}}t.inputs.push(a),a.children.push(t)}))})),0===Object.keys(c).length?h.forEach((e=>{const t=i[e];0===t.children.length&&u.push(t)})):Object.keys(c).forEach((e=>{const[t]=iO(e),n=i[t];null!=n&&(n.signatureKey=c[e],u.push(n))})),Object.keys(l).length>0?Object.keys(l).forEach((e=>{const[t]=iO(e),n=i[t];n&&(n.signatureKey=l[e],o.push(n))})):o=r;let p={};null!=e.library&&null!=e.library.function&&(p=e.library.function.reduce(((e,t)=>(e[t.signature.name]=this.mapFunction(t),e)),{}));const d={nodes:i,inputs:o,outputs:u,weights:s,placeholders:r,signature:t,functions:p};return a.length>0&&(d.initNodes=a),d}mapSignatureEntries(e){return Object.keys(e||{}).reduce(((t,n)=>(t[e[n].name]=n,t)),{})}mapNode(e){const t=tO(e.op)||this.opMappers[e.op]||{};null==e.attr&&(e.attr={});const n={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map((e=>e.startsWith("^")?e.slice(1):e)),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return null!=t.inputs&&(n.inputParams=t.inputs.reduce(((e,t)=>(e[t.name]={type:t.type,inputIndexStart:t.start,inputIndexEnd:t.end},e)),{})),null!=t.attrs&&(n.attrParams=t.attrs.reduce(((t,n)=>{const r=n.type;let s;switch(n.type){case"string":s=_O(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=_O(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"string[]":s=UO(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=UO(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number":s=OO(e.attr,n.tfName,n.defaultValue||0),void 0===s&&n.tfDeprecatedName&&(s=OO(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number[]":s=VO(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=VO(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool":s=DO(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=DO(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool[]":s=HO(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=HO(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape":s=WO(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=WO(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape[]":s=GO(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=GO(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype":s=zO(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=zO(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype[]":s=PO(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=PO(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"func":s=LO(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=LO(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${n.type} for op: ${e.op}`)}return t[n.name]={value:s,type:r},t}),{})),n}mapFunction(e){const t=e.nodeDef,n=[],r=[];let s={};null!=t&&(s=t.reduce(((e,t)=>(e[t.name]=this.mapNode(t),"Const"===t.op&&r.push(e[t.name]),e)),{}));const a=[],i=[];e.signature.inputArg.forEach((e=>{const[t]=iO(e.name),n={name:t,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:MO(e.type),type:"dtype"}},children:[]};n.signatureKey=e.name,a.push(n),s[t]=n}));const o=Object.keys(s);o.forEach((e=>{const t=s[e];t.inputNames.forEach(((e,n)=>{const[r,,a]=iO(e),i=s[r];if(null!=i.outputs){const e=i.outputs.indexOf(a);if(-1!==e){const s=`${r}:${e}`;t.inputNames[n]=s}}t.inputs.push(i),i.children.push(t)}))}));const u=e.ret;e.signature.outputArg.forEach((e=>{const[t,n]=iO(u[e.name]),r=s[t];null!=r&&(r.defaultOutput=n,i.push(r))}));const l=this.mapArgsToSignature(e);return{nodes:s,inputs:a,outputs:i,weights:r,placeholders:n,signature:l}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce(((e,t)=>(e[t.name]=this.mapArgToTensorInfo(t),e)),{}),outputs:e.signature.outputArg.reduce(((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n,e.ret),t)),{})}}mapArgToTensorInfo(e,t){let n=e.name;return null!=t&&(n=t[n]),{name:n,dtype:e.type}}}function AO(e){const t=ht().global;if("undefined"!==typeof t.atob)return t.atob(e);if("undefined"!==typeof Buffer)return new Buffer(e,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function FO(e,t){const n=Array.isArray(e)?String.fromCharCode.apply(null,e):AO(e);return t?n:n.toLowerCase()}function _O(e,t,n,r=!1){const s=e[t];return null!=s?FO(s.s,r):n}function DO(e,t,n){const r=e[t];return r?r.b:n}function OO(e,t,n){const r=e[t]||{},s=null!=r["i"]?r["i"]:null!=r["f"]?r["f"]:n;return"number"===typeof s?s:parseInt(s,10)}function MO(e){switch("string"===typeof e&&(e=JD[e]),e){case JD.DT_FLOAT:case JD.DT_HALF:return"float32";case JD.DT_INT32:case JD.DT_INT64:case JD.DT_INT8:case JD.DT_UINT8:return"int32";case JD.DT_BOOL:return"bool";case JD.DT_DOUBLE:return"float32";case JD.DT_STRING:return"string";default:return null}}function LO(e,t,n){const r=e[t];return r&&r.func?r.func.name:n}function zO(e,t,n){const r=e[t];return r&&r.type?MO(r.type):n}function PO(e,t,n){const r=e[t];return r&&r.list&&r.list.type?r.list.type.map((e=>MO(e))):n}function BO(e){if(!e.unknownRank)return null!=e.dim?e.dim.map((e=>"number"===typeof e.size?e.size:parseInt(e.size,10))):[]}function WO(e,t,n){const r=e[t];return r&&r.shape?BO(r.shape):n}function VO(e,t,n){const r=e[t];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map((e=>"number"===typeof e?e:parseInt(e,10))):n}function UO(e,t,n,r=!1){const s=e[t];return s&&s.list&&s.list.s?s.list.s.map((e=>FO(e,r))):n}function GO(e,t,n){const r=e[t];return r&&r.list&&r.list.shape?r.list.shape.map((e=>BO(e))):n}function HO(e,t,n){const r=e[t];return r&&r.list&&r.list.b?r.list.b:n}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class jO{constructor(e,t,n){this.node=e,this.tensorMap=t,this.context=n,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map((e=>this.getInput(e))),null!=e.rawAttrs&&(this.attrs=Object.keys(e.rawAttrs).reduce(((e,t)=>(e[t]=this.getAttr(t),e)),{}))}getInput(e){return sO(e,this.tensorMap,this.context)}getAttr(e,t){const n=this.node.rawAttrs[e];if(null!=n.tensor)return sO(e,this.tensorMap,this.context);if(null!=n.i||null!=n.f)return OO(this.node.rawAttrs,e,t);if(null!=n.s)return _O(this.node.rawAttrs,e,t);if(null!=n.b)return DO(this.node.rawAttrs,e,t);if(null!=n.shape)return WO(this.node.rawAttrs,e,t);if(null!=n.type)return zO(this.node.rawAttrs,e,t);if(null!=n.list){if(null!=n.list.i||null!=n.list.f)return VO(this.node.rawAttrs,e,t);if(null!=n.list.s)return UO(this.node.rawAttrs,e,t);if(null!=n.list.shape)return GO(this.node.rawAttrs,e,t);if(null!=n.list.b)return HO(this.node.rawAttrs,e,t);if(null!=n.list.type)return PO(this.node.rawAttrs,e,t)}return t}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const qO=(e,t,n,r=G)=>{switch(e.op){case"BiasAdd":case"AddV2":case"Add":return[r.add(rO("a",e,t,n),rO("b",e,t,n))];case"AddN":return[r.addN(rO("tensors",e,t,n))];case"FloorMod":case"Mod":return[r.mod(rO("a",e,t,n),rO("b",e,t,n))];case"Mul":return[r.mul(rO("a",e,t,n),rO("b",e,t,n))];case"RealDiv":case"Div":return[r.div(rO("a",e,t,n),rO("b",e,t,n))];case"DivNoNan":return[r.divNoNan(rO("a",e,t,n),rO("b",e,t,n))];case"FloorDiv":return[r.floorDiv(rO("a",e,t,n),rO("b",e,t,n))];case"Sub":return[r.sub(rO("a",e,t,n),rO("b",e,t,n))];case"Minimum":return[r.minimum(rO("a",e,t,n),rO("b",e,t,n))];case"Maximum":return[r.maximum(rO("a",e,t,n),rO("b",e,t,n))];case"Pow":return[r.pow(rO("a",e,t,n),rO("b",e,t,n))];case"SquaredDifference":return[r.squaredDifference(rO("a",e,t,n),rO("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},KO=(e,t,n,r=G)=>{switch(e.op){case"Abs":case"ComplexAbs":return[r.abs(rO("x",e,t,n))];case"Acos":return[r.acos(rO("x",e,t,n))];case"Acosh":return[r.acosh(rO("x",e,t,n))];case"Asin":return[r.asin(rO("x",e,t,n))];case"Asinh":return[r.asinh(rO("x",e,t,n))];case"Atan":return[r.atan(rO("x",e,t,n))];case"Atan2":return[r.atan2(rO("x",e,t,n),rO("y",e,t,n))];case"Atanh":return[r.atanh(rO("x",e,t,n))];case"Ceil":return[r.ceil(rO("x",e,t,n))];case"Complex":return[r.complex(rO("real",e,t,n),rO("imag",e,t,n))];case"Cos":return[r.cos(rO("x",e,t,n))];case"Cosh":return[r.cosh(rO("x",e,t,n))];case"Elu":return[r.elu(rO("x",e,t,n))];case"Erf":return[r.erf(rO("x",e,t,n))];case"Exp":return[r.exp(rO("x",e,t,n))];case"Expm1":return[r.expm1(rO("x",e,t,n))];case"Floor":return[r.floor(rO("x",e,t,n))];case"Log":return[r.log(rO("x",e,t,n))];case"Log1p":return[r.log1p(rO("x",e,t,n))];case"Imag":return[r.imag(rO("x",e,t,n))];case"Neg":return[r.neg(rO("x",e,t,n))];case"Reciprocal":return[r.reciprocal(rO("x",e,t,n))];case"Real":return[r.real(rO("x",e,t,n))];case"Relu":return[r.relu(rO("x",e,t,n))];case"Round":return[r.round(rO("x",e,t,n))];case"Selu":return[r.selu(rO("x",e,t,n))];case"Sigmoid":return[r.sigmoid(rO("x",e,t,n))];case"Sin":return[r.sin(rO("x",e,t,n))];case"Sign":return[r.sign(rO("x",e,t,n))];case"Sinh":return[r.sinh(rO("x",e,t,n))];case"Softplus":return[r.softplus(rO("x",e,t,n))];case"Sqrt":return[r.sqrt(rO("x",e,t,n))];case"Square":return[r.square(rO("x",e,t,n))];case"Tanh":return[r.tanh(rO("x",e,t,n))];case"Tan":return[r.tan(rO("x",e,t,n))];case"ClipByValue":return[r.clipByValue(rO("x",e,t,n),rO("clipValueMin",e,t,n),rO("clipValueMax",e,t,n))];case"Relu6":return[r.relu6(rO("x",e,t,n))];case"Rsqrt":return[r.rsqrt(sO(e.inputNames[0],t,n))];case"LeakyRelu":return[r.leakyRelu(rO("x",e,t,n),rO("alpha",e,t,n))];case"Prelu":return[r.prelu(rO("x",e,t,n),rO("alpha",e,t,n))];case"IsNan":return[r.isNaN(sO(e.inputNames[0],t,n))];case"IsInf":return[r.isInf(sO(e.inputNames[0],t,n))];case"IsFinite":return[r.isFinite(sO(e.inputNames[0],t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function XO(e,t,n=""){if("number"!==typeof e&&"number"!==typeof t){we(e.length===t.length,(()=>n+` Shapes ${e} and ${t} must match`));for(let r=0;r<e.length;r++){const s=e[r],a=t[r];we(s<0||a<0||s===a,(()=>n+` Shapes ${e} and ${t} must match`))}}}function YO(e){return"number"!==typeof e&&!e.some((e=>e<0))}function JO(e,t,n){let r=ZO(e,n);const s=!YO(r);if(s&&0===t.length)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(s&&t.forEach((e=>{r=ZO(e.shape,r)})),!YO(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function ZO(e,t){if("number"===typeof e)return t;if("number"===typeof t)return e;if(e.length!==t.length)throw new Error(`Incompatible ranks during merge: ${e} vs. ${t}`);const n=[];for(let r=0;r<e.length;++r){const s=e[r],a=t[r];if(s>=0&&a>=0&&s!==a)throw new Error(`Incompatible shape during merge: ${e} vs. ${t}`);n[r]=s>=0?s:a}return n}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class QO{constructor(e,t,n,r,s,a,i){this.name=e,this.dtype=t,this.maxSize=n,this.elementShape=r,this.identicalElementShapes=s,this.dynamicSize=a,this.clearAfterRead=i,this.tensors=[],this.closed_=!1,this.idTensor=Vu(0),cu(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach((t=>{null!=e&&e.has(t.tensor.id)||t.tensor.dispose()})),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map((e=>this.read(e)))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const n=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},\n          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0!==this.size()||null!=this.elementShape&&0!==this.elementShape.length||(this.elementShape=t.shape),XO(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);n.tensor=t,cu(t),n.written=!0,this.tensors[e]=n}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach(((e,n)=>this.write(e,t[n])))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let t=0;t<this.size();t++)e.push(t)}if(0===e.length)return Di([],[0].concat(this.elementShape));const n=this.readMany(e);return XO(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),Sy(n,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(0===this.size())return Di([],[0].concat(this.elementShape));const t=[];for(let r=0;r<this.size();r++)t.push(r);const n=this.readMany(t);return XO(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),tp(n,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const n=Math.max(...e);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(e,Ky(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let n=0;const r=e.map((e=>(n+=e,n)));if(n!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${n}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const s=0===n?0:t.size/n,a=[];uu((()=>{t=Xh(t,[1,n,s]);for(let n=0;n<e.length;++n){const i=0===n?0:r[n-1],o=[0,i,0],u=[1,e[n],s];a[n]=Xh(ap(t,o,u),this.elementShape)}return a}));const i=[];for(let o=0;o<e.length;o++)i[o]=o;this.writeMany(i,a)}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class eM{get id(){return this.idTensor.id}constructor(e,t,n,r=-1){this.tensors=e,this.elementShape=t,this.elementDtype=n,null!=e&&e.forEach((e=>{if(n!==e.dtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${e.dtype}`);XO(t,e.shape,"TensorList shape mismatch: "),cu(e)})),this.idTensor=Vu(0),this.maxNumElements=r,cu(this.idTensor)}copy(){return new eM([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach((t=>{null!=e&&e.has(t.id)||t.dispose()})),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,n=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(-1!==n&&this.tensors.length!==n)throw new Error(`Operation expected a list with ${n} elements but got a list with ${this.tensors.length} elements.`);XO(e,this.elementShape,"TensorList shape mismatch: ");const r=JO(this.elementShape,this.tensors,e);return uu((()=>{const e=this.tensors.map((e=>Xh(e,r)));return Sy(e,0)}))}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(0===this.size())throw new Error("Trying to pop from an empty list.");const n=JO(this.elementShape,this.tensors,e),r=this.tensors.pop();return r.kept=!1,XO(r.shape,e,"TensorList shape mismatch: "),Xh(r,n)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(XO(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");cu(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(-1!==this.maxNumElements&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);const t=new eM([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let n=0;n<Math.min(this.tensors.length,e);++n)t.tensors[n]=this.tensors[n];return t}getItem(e,t,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(null==this.tensors[e])throw new Error(`element at index ${e} is null.`);XO(this.tensors[e].shape,t,"TensorList shape mismatch: ");const r=JO(this.elementShape,this.tensors,t);return Xh(this.tensors[e],r)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||-1!==this.maxNumElements&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);XO(this.elementShape,t.shape,"TensorList shape mismatch: "),cu(t),null!=this.tensors[e]&&(this.tensors[e].kept=!1),this.tensors[e]=t}gather(e,t,n){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);XO(this.elementShape,n,"TensorList shape mismatch: "),e=e.slice(0,this.size());const r=JO(this.elementShape,this.tensors,n);return 0===e.length?Di([],[0].concat(r)):uu((()=>{const t=e.map((e=>Xh(this.tensors[e],r)));return Sy(t,0)}))}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);XO(this.elementShape,t,"TensorList shape mismatch: ");const n=JO(this.elementShape,this.tensors,t);return 0===this.size()?Di([],[0].concat(n)):uu((()=>{const e=this.tensors.map((e=>Xh(e,n)));return tp(e,0)}))}}function tM(e,t,n){const r=e.dtype;if(e.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${e.shape}`);if(e.dtype!==n)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${n}`);const s=e.shape.slice(1);XO(s,t,"TensorList shape mismatch: ");const a=Ky(e);return new eM(a,t,r)}function nM(e,t,n,r){return new eM([],e,t,r)}function rM(e,t,n,r){if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);const s=Math.max(...t);if(null!=r&&-1!==r&&s>=r)throw new Error(`Max index must be < array size (${s}  vs. ${r})`);const a=new eM([],n,e.dtype,r),i=Ky(e,0);return t.forEach(((e,t)=>{a.setItem(e,i[t])})),a}function sM(e,t,n){let r=0;const s=t.map((e=>(r+=e,r)));if(r!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${r}, and tensor's shape is: ${e.shape}`);const a=e.shape.slice(1),i=ZO(a,n),o=0===r?0:e.size/r,u=uu((()=>{const n=[];e=Xh(e,[1,r,o]);for(let r=0;r<t.length;++r){const a=0===r?0:s[r-1],u=[0,a,0],l=[1,t[r],o];n[r]=Xh(ap(e,u,l),i)}return e.dispose(),n})),l=new eM([],n,e.dtype,t.length);for(let c=0;c<u.length;c++)l.setItem(c,u[c]);return l}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const aM=async(e,t,n)=>{switch(e.op){case"If":case"StatelessIf":{const r=rO("thenBranch",e,t,n),s=rO("elseBranch",e,t,n),a=rO("cond",e,t,n),i=rO("args",e,t,n),o=await a.data();return o[0]?n.functionMap[r].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap):n.functionMap[s].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{const r=rO("body",e,t,n),s=rO("cond",e,t,n),a=rO("args",e,t,n),i=await n.functionMap[s].executeFunctionAsync(a,n.tensorArrayMap,n.tensorListMap),o=a.map((e=>e.id));let u=await i[0].data();i.forEach((e=>{e.kept||-1!==o.indexOf(e.id)||e.dispose()}));let l=a;while(u[0]){const e=l;l=await n.functionMap[r].executeFunctionAsync(l,n.tensorArrayMap,n.tensorListMap);const t=l.map((e=>e.id));e.forEach((e=>{e.kept||-1!==o.indexOf(e.id)||-1!==t.indexOf(e.id)||e.dispose()}));const a=await n.functionMap[s].executeFunctionAsync(l,n.tensorArrayMap,n.tensorListMap);u=await a[0].data(),a.forEach((e=>{e.kept||-1!==o.indexOf(e.id)||-1!==t.indexOf(e.id)||e.dispose()}))}return l}case"LoopCond":{const r=rO("pred",e,t,n);return[cO(r)]}case"Switch":{const r=rO("pred",e,t,n);let s=rO("data",e,t,n);return s.kept||(s=cO(s)),(await r.data())[0]?[void 0,s]:[s,void 0]}case"Merge":{const r=e.inputNames.find((e=>void 0!==sO(e,t,n)));if(r){const e=sO(r,t,n);return[cO(e)]}return}case"Enter":{const r=rO("frameName",e,t,n),s=rO("tensor",e,t,n);return n.enterFrame(r),[cO(s)]}case"Exit":{const r=rO("tensor",e,t,n);return n.exitFrame(),[cO(r)]}case"NextIteration":{const r=rO("tensor",e,t,n);return n.nextIteration(),[cO(r)]}case"TensorArrayV3":{const r=rO("size",e,t,n),s=rO("dtype",e,t,n),a=rO("elementShape",e,t,n),i=rO("dynamicSize",e,t,n),o=rO("clearAfterRead",e,t,n),u=rO("identicalElementShapes",e,t,n),l=rO("name",e,t,n),c=new QO(l,s,r,a,u,i,o);return n.addTensorArray(c),[c.idTensor,Vu(1)]}case"TensorArrayWriteV3":{const r=rO("tensorArrayId",e,t,n),s=rO("index",e,t,n),a=rO("tensor",e,t,n),i=n.getTensorArray(r.id);return i.write(s,a),[i.idTensor]}case"TensorArrayReadV3":{const r=rO("tensorArrayId",e,t,n),s=rO("index",e,t,n),a=n.getTensorArray(r.id);return[a.read(s)]}case"TensorArrayGatherV3":{const r=rO("tensorArrayId",e,t,n),s=rO("indices",e,t,n),a=rO("dtype",e,t,n),i=n.getTensorArray(r.id);return[i.gather(s,a)]}case"TensorArrayScatterV3":{const r=rO("tensorArrayId",e,t,n),s=rO("indices",e,t,n),a=rO("tensor",e,t,n),i=n.getTensorArray(r.id);return i.scatter(s,a),[i.idTensor]}case"TensorArrayConcatV3":{const r=rO("tensorArrayId",e,t,n),s=n.getTensorArray(r.id),a=rO("dtype",e,t,n);return[s.concat(a)]}case"TensorArraySplitV3":{const r=rO("tensorArrayId",e,t,n),s=rO("tensor",e,t,n),a=rO("lengths",e,t,n),i=n.getTensorArray(r.id);return i.split(a,s),[i.idTensor]}case"TensorArraySizeV3":{const r=rO("tensorArrayId",e,t,n),s=n.getTensorArray(r.id);return[Vu(s.size(),"int32")]}case"TensorArrayCloseV3":{const r=rO("tensorArrayId",e,t,n),s=n.getTensorArray(r.id);return s.clearAndClose(),[s.idTensor]}case"TensorListSetItem":{const r=rO("tensorListId",e,t,n),s=rO("index",e,t,n),a=rO("tensor",e,t,n),i=n.getTensorList(r.id);return i.setItem(s,a),[i.idTensor]}case"TensorListGetItem":{const r=rO("tensorListId",e,t,n),s=rO("index",e,t,n),a=rO("elementShape",e,t,n),i=rO("elementDType",e,t,n),o=n.getTensorList(r.id);return[o.getItem(s,a,i)]}case"TensorListScatterV2":case"TensorListScatter":{const r=rO("indices",e,t,n),s=rO("tensor",e,t,n),a=rO("elementShape",e,t,n),i=rO("numElements",e,t,n),o=rM(s,r,a,i);return n.addTensorList(o),[o.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const r=rO("elementShape",e,t,n),s=rO("elementDType",e,t,n);let a;a="TensorListReserve"===e.op?"numElements":"maxNumElements";const i=rO(a,e,t,n),o="TensorListReserve"===e.op?-1:i,u=nM(r,s,i,o);return n.addTensorList(u),[u.idTensor]}case"TensorListGather":{const r=rO("tensorListId",e,t,n),s=rO("indices",e,t,n),a=rO("elementShape",e,t,n),i=rO("elementDType",e,t,n),o=n.getTensorList(r.id);return[o.gather(s,i,a)]}case"TensorListStack":{const r=rO("tensorListId",e,t,n),s=rO("elementShape",e,t,n),a=rO("elementDType",e,t,n),i=rO("numElements",e,t,n),o=n.getTensorList(r.id);return[o.stack(s,a,i)]}case"TensorListFromTensor":{const r=rO("tensor",e,t,n),s=rO("elementShape",e,t,n),a=rO("elementDType",e,t,n),i=tM(r,s,a);return n.addTensorList(i),[i.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const r=rO("tensorListId",e,t,n),s=n.getTensorList(r.id),a=rO("dtype",e,t,n),i=rO("elementShape",e,t,n);return[s.concat(a,i)]}case"TensorListPushBack":{const r=rO("tensorListId",e,t,n),s=rO("tensor",e,t,n),a=n.getTensorList(r.id);return a.pushBack(s),[a.idTensor]}case"TensorListPopBack":{const r=rO("tensorListId",e,t,n),s=rO("elementShape",e,t,n),a=rO("elementDType",e,t,n),i=n.getTensorList(r.id);return[i.popBack(s,a)]}case"TensorListSplit":{const r=rO("tensor",e,t,n),s=rO("elementShape",e,t,n),a=rO("lengths",e,t,n),i=sM(r,a,s);return n.addTensorList(i),[i.idTensor]}case"TensorListLength":{const r=rO("tensorListId",e,t,n),s=n.getTensorList(r.id);return[Vu(s.size(),"int32")]}case"TensorListResize":{const r=rO("tensorListId",e,t,n),s=rO("size",e,t,n),a=n.getTensorList(r.id),i=a.resize(s);return n.addTensorList(i),[i.idTensor]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function iM(e,t,n){const[r,s]=rO("fusedOps",e,t,n),a="biasadd"===r,i=!a,o="prelu"===s,u="fusedbatchnorm"===r,l=rO("numArgs",e,t,n);if(a){if(o&&2!==l)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&a&&1!==l)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(u)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const c=rO("strides",e,t,n),h=lO(e,t,n),p=rO("dataFormat",e,t,n).toUpperCase(),d=rO("dilations",e,t,n);let[f,m]=rO("args",e,t,n);i&&(m=f,f=void 0);const g=rO("leakyreluAlpha",e,t,n);return{stride:c,pad:h,dataFormat:p,dilations:d,biasArg:f,preluArg:m,activationFunc:s,leakyreluAlpha:g}}const oM=(e,t,n,r=G)=>{switch(e.op){case"Conv1D":{const s=rO("stride",e,t,n),a=rO("pad",e,t,n),i=rO("dataFormat",e,t,n).toUpperCase(),o=rO("dilation",e,t,n);return[r.conv1d(rO("x",e,t,n),rO("filter",e,t,n),s,a,i,o)]}case"Conv2D":{const s=rO("strides",e,t,n),a=lO(e,t,n),i=rO("dataFormat",e,t,n).toUpperCase(),o=rO("dilations",e,t,n);return[r.conv2d(rO("x",e,t,n),rO("filter",e,t,n),[s[1],s[2]],a,i,[o[1],o[2]])]}case"_FusedConv2D":{const{stride:s,pad:a,dataFormat:i,dilations:o,biasArg:u,preluArg:l,activationFunc:c,leakyreluAlpha:h}=iM(e,t,n);return[r.fused.conv2d({x:rO("x",e,t,n),filter:rO("filter",e,t,n),strides:[s[1],s[2]],pad:a,dataFormat:i,dilations:[o[1],o[2]],bias:u,activation:c,preluActivationWeights:l,leakyreluAlpha:h})]}case"FusedDepthwiseConv2dNative":{const{stride:s,pad:a,dataFormat:i,dilations:o,biasArg:u,preluArg:l,activationFunc:c,leakyreluAlpha:h}=iM(e,t,n);return[r.fused.depthwiseConv2d({x:rO("x",e,t,n),filter:rO("filter",e,t,n),strides:[s[1],s[2]],pad:a,dataFormat:i,dilations:[o[1],o[2]],bias:u,activation:c,preluActivationWeights:l,leakyreluAlpha:h})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const s=rO("outputShape",e,t,n),a=rO("strides",e,t,n),i=lO(e,t,n);return[r.conv2dTranspose(rO("x",e,t,n),rO("filter",e,t,n),s,[a[1],a[2]],i)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const s=rO("strides",e,t,n),a=lO(e,t,n),i=rO("dilations",e,t,n),o=rO("dataFormat",e,t,n).toUpperCase();return[r.depthwiseConv2d(rO("input",e,t,n),rO("filter",e,t,n),[s[1],s[2]],a,o,[i[1],i[2]])]}case"Conv3D":{const s=rO("strides",e,t,n),a=rO("pad",e,t,n),i=rO("dataFormat",e,t,n).toUpperCase(),o=rO("dilations",e,t,n);return[r.conv3d(rO("x",e,t,n),rO("filter",e,t,n),[s[1],s[2],s[3]],a,i,[o[1],o[2],o[3]])]}case"AvgPool":{const s=rO("strides",e,t,n),a=rO("pad",e,t,n),i=rO("kernelSize",e,t,n);return[r.avgPool(rO("x",e,t,n),[i[1],i[2]],[s[1],s[2]],a)]}case"MaxPool":{const s=rO("strides",e,t,n),a=rO("pad",e,t,n),i=rO("kernelSize",e,t,n);return[r.maxPool(rO("x",e,t,n),[i[1],i[2]],[s[1],s[2]],a)]}case"MaxPoolWithArgmax":{const s=rO("strides",e,t,n),a=rO("pad",e,t,n),i=rO("kernelSize",e,t,n),o=rO("includeBatchInIndex",e,t,n),{result:u,indexes:l}=r.maxPoolWithArgmax(rO("x",e,t,n),[i[1],i[2]],[s[1],s[2]],a,o);return[u,l]}case"AvgPool3D":{const s=rO("strides",e,t,n),a=rO("pad",e,t,n),i=rO("kernelSize",e,t,n);return[r.avgPool3d(rO("x",e,t,n),[i[1],i[2],i[3]],[s[1],s[2],s[3]],a)]}case"MaxPool3D":{const s=rO("strides",e,t,n),a=rO("pad",e,t,n),i=rO("kernelSize",e,t,n);return[r.maxPool3d(rO("x",e,t,n),[i[1],i[2],i[3]],[s[1],s[2],s[3]],a)]}case"Dilation2D":{const s=rO("strides",e,t,n),a=rO("pad",e,t,n),i=rO("dilations",e,t,n),o=s[1],u=s[2],l=i[1],c=i[2];return[r.dilation2d(rO("x",e,t,n),rO("filter",e,t,n),[o,u],a,[l,c],"NHWC")]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},uM=(e,t,n,r=G)=>{switch(e.op){case"Fill":{const s=rO("shape",e,t,n),a=rO("dtype",e,t,n),i=rO("value",e,t,n);return[r.fill(s,i,a)]}case"LinSpace":{const s=rO("start",e,t,n),a=rO("stop",e,t,n),i=rO("num",e,t,n);return[r.linspace(s,a,i)]}case"Multinomial":{const s=rO("logits",e,t,n),a=rO("numSamples",e,t,n),i=rO("seed",e,t,n);return[r.multinomial(s,a,i)]}case"OneHot":{const s=rO("indices",e,t,n),a=rO("depth",e,t,n),i=rO("onValue",e,t,n),o=rO("offValue",e,t,n),u=rO("dtype",e,t,n);return[r.oneHot(s,a,i,o,u)]}case"Ones":return[r.ones(rO("shape",e,t,n),rO("dtype",e,t,n))];case"OnesLike":return[r.onesLike(rO("x",e,t,n))];case"RandomStandardNormal":return[r.randomStandardNormal(rO("shape",e,t,n),rO("dtype",e,t,n),rO("seed",e,t,n))];case"RandomUniform":return[r.randomUniform(rO("shape",e,t,n),rO("minval",e,t,n),rO("maxval",e,t,n),rO("dtype",e,t,n))];case"RandomUniformInt":return[r.randomUniformInt(rO("shape",e,t,n),rO("minval",e,t,n),rO("maxval",e,t,n),rO("seed",e,t,n))];case"Range":{const s=rO("start",e,t,n),a=rO("stop",e,t,n),i=rO("step",e,t,n);return[r.range(s,a,i,rO("dtype",e,t,n))]}case"TruncatedNormal":{const s=rO("shape",e,t,n),a=rO("mean",e,t,n),i=rO("stdDev",e,t,n),o=rO("seed",e,t,n);return[r.truncatedNormal(s,a,i,rO("dtype",e,t,n),o)]}case"Zeros":return[r.zeros(rO("shape",e,t,n),rO("dtype",e,t,n))];case"ZerosLike":return[r.zerosLike(rO("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function lM(e,t,n){const r=rO("boxes",e,t,n),s=rO("scores",e,t,n),a=rO("maxOutputSize",e,t,n),i=rO("iouThreshold",e,t,n),o=rO("scoreThreshold",e,t,n),u=rO("softNmsSigma",e,t,n);return{boxes:r,scores:s,maxOutputSize:a,iouThreshold:i,scoreThreshold:o,softNmsSigma:u}}const cM=async(e,t,n,r,s=G)=>{switch(e.op){case"NonMaxSuppressionV5":{const{boxes:r,scores:a,maxOutputSize:i,iouThreshold:o,scoreThreshold:u,softNmsSigma:l}=lM(e,t,n),c=await s.image.nonMaxSuppressionWithScoreAsync(r,a,i,o,u,l);return[c.selectedIndices,c.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:r,scores:a,maxOutputSize:i,iouThreshold:o,scoreThreshold:u}=lM(e,t,n),l=rO("padToMaxOutputSize",e,t,n),c=await s.image.nonMaxSuppressionPaddedAsync(r,a,i,o,u,l);return[c.selectedIndices,c.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:r,scores:a,maxOutputSize:i,iouThreshold:o,scoreThreshold:u}=lM(e,t,n);return[await s.image.nonMaxSuppressionAsync(r,a,i,o,u)]}case"Where":{const r=s.cast(rO("condition",e,t,n),"bool"),a=[await s.whereAsync(r)];return r.dispose(),a}case"ListDiff":return s.setdiff1dAsync(rO("x",e,t,n),rO("y",e,t,n));default:throw TypeError(`Node type ${e.op} is not implemented`)}},hM=(e,t,n,r=G)=>{switch(e.op){case"LowerBound":{const s=rO("sortedSequence",e,t,n),a=rO("values",e,t,n);return[r.lowerBound(s,a)]}case"TopKV2":{const s=rO("x",e,t,n),a=rO("k",e,t,n),i=rO("sorted",e,t,n),o=r.topk(s,a,i);return[o.values,o.indices]}case"UpperBound":{const s=rO("sortedSequence",e,t,n),a=rO("values",e,t,n);return[r.upperBound(s,a)]}case"Unique":{const s=rO("x",e,t,n),a=r.unique(s);return[a.values,a.indices]}case"UniqueV2":{const s=rO("x",e,t,n),a=rO("axis",e,t,n),i=r.unique(s,a);return[i.values,i.indices]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},pM=(e,t,n,r=G)=>{switch(e.op){case"Const":return t[e.name];case"PlaceholderWithDefault":const s=rO("default",e,t,n);return[sO(e.name,t,n)||s];case"Placeholder":return[sO(e.name,t,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const r=rO("x",e,t,n);return[cO(r)]}case"IdentityN":return rO("x",e,t,n).map((e=>cO(e)));case"Snapshot":const a=rO("x",e,t,n);return[cO(a)];case"Shape":return[r.tensor1d(rO("x",e,t,n).shape,"int32")];case"ShapeN":return rO("x",e,t,n).map((e=>r.tensor1d(e.shape)));case"Size":return[r.scalar(rO("x",e,t,n).size,"int32")];case"Rank":return[r.scalar(rO("x",e,t,n).rank,"int32")];case"NoOp":return[r.scalar(1)];case"Print":const i=rO("x",e,t,n),o=rO("data",e,t,n),u=rO("message",e,t,n),l=rO("summarize",e,t,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(u);for(let e=0;e<o.length;e++)console.log(Array.prototype.slice.call(o[e].dataSync()).slice(0,l));return[i];default:throw TypeError(`Node type ${e.op} is not implemented`)}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class dM{get id(){return this.handle.id}constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=Vu(0),this.tensorMap=new Map,cu(this.handle)}clearAndClose(){this.tensorMap.forEach((e=>e.dispose())),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return Vu(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);const n=await e.data();return this.tensorMap.forEach((e=>e.dispose())),this.tensorMap.clear(),uu((()=>{const e=Ky(t),r=n.length,s=e.length;we(r===s,(()=>`The number of elements doesn't match, keys has ${r} elements, the values has ${s} elements.`));for(let t=0;t<r;t++){const r=n[t],s=e[t];cu(s),this.tensorMap.set(r,s)}return this.handle}))}async find(e,t){this.checkKeyAndValueTensor(e,t);const n=await e.data();return uu((()=>{const e=[];for(let r=0;r<n.length;r++){const s=n[r],a=this.findWithDefault(s,t);e.push(a)}return Sy(e)}))}findWithDefault(e,t){const n=this.tensorMap.get(e);return null!=n?n:t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const fM=async(e,t,n,r)=>{switch(e.op){case"HashTable":case"HashTableV2":{const s=r.getHashTableHandleByName(e.name);if(null!=s)return[s];{const s=rO("keyDType",e,t,n),a=rO("valueDType",e,t,n),i=new dM(s,a);return r.addHashTable(e.name,i),[i.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const s=rO("tableHandle",e,t,n,r),a=rO("keys",e,t,n),i=rO("values",e,t,n),o=r.getHashTableById(s.id);return[await o.import(a,i)]}case"LookupTableFind":case"LookupTableFindV2":{const s=rO("tableHandle",e,t,n,r),a=rO("keys",e,t,n),i=rO("defaultValue",e,t,n),o=r.getHashTableById(s.id);return[await o.find(a,i)]}case"LookupTableSize":case"LookupTableSizeV2":{const s=rO("tableHandle",e,t,n,r),a=r.getHashTableById(s.id);return[a.tensorSize()]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},mM=(e,t,n,r=G)=>{switch(e.op){case"ResizeBilinear":{const s=rO("images",e,t,n),a=rO("size",e,t,n),i=rO("alignCorners",e,t,n),o=rO("halfPixelCenters",e,t,n);return[r.image.resizeBilinear(s,[a[0],a[1]],i,o)]}case"ResizeNearestNeighbor":{const s=rO("images",e,t,n),a=rO("size",e,t,n),i=rO("alignCorners",e,t,n),o=rO("halfPixelCenters",e,t,n);return[r.image.resizeNearestNeighbor(s,[a[0],a[1]],i,o)]}case"CropAndResize":{const s=rO("image",e,t,n),a=rO("boxes",e,t,n),i=rO("boxInd",e,t,n),o=rO("cropSize",e,t,n),u=rO("method",e,t,n),l=rO("extrapolationValue",e,t,n);return[r.image.cropAndResize(s,a,i,o,u,l)]}case"ImageProjectiveTransformV3":{const s=rO("images",e,t,n),a=rO("transforms",e,t,n),i=rO("outputShape",e,t,n),o=rO("fillValue",e,t,n),u=rO("interpolation",e,t,n),l=rO("fillMode",e,t,n);return[r.image.transform(s,a,u.toLowerCase(),l.toLowerCase(),o,i)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},gM=(e,t,n,r=G)=>{switch(e.op){case"Equal":return[r.equal(rO("a",e,t,n),rO("b",e,t,n))];case"NotEqual":return[r.notEqual(rO("a",e,t,n),rO("b",e,t,n))];case"Greater":return[r.greater(rO("a",e,t,n),rO("b",e,t,n))];case"GreaterEqual":return[r.greaterEqual(rO("a",e,t,n),rO("b",e,t,n))];case"Less":return[r.less(rO("a",e,t,n),rO("b",e,t,n))];case"LessEqual":return[r.lessEqual(rO("a",e,t,n),rO("b",e,t,n))];case"LogicalAnd":return[r.logicalAnd(rO("a",e,t,n),rO("b",e,t,n))];case"LogicalNot":return[r.logicalNot(rO("a",e,t,n))];case"LogicalOr":return[r.logicalOr(rO("a",e,t,n),rO("b",e,t,n))];case"Select":case"SelectV2":return[r.where(rO("condition",e,t,n),rO("a",e,t,n),rO("b",e,t,n))];case"BitwiseAnd":return[r.bitwiseAnd(rO("a",e,t,n),rO("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},yM=(e,t,n,r=G)=>{switch(e.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[r.matMul(rO("a",e,t,n),rO("b",e,t,n),rO("transposeA",e,t,n),rO("transposeB",e,t,n))];case"Einsum":return[r.einsum(rO("equation",e,t,n),...rO("tensors",e,t,n))];case"Transpose":return[r.transpose(rO("x",e,t,n),rO("perm",e,t,n))];case"_FusedMatMul":const[s,a]=rO("fusedOps",e,t,n),i="biasadd"===s,o="prelu"===a,u=rO("numArgs",e,t,n),l=rO("leakyreluAlpha",e,t,n);if(i){if(o&&2!==u)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&1!==u)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[c,h]=rO("args",e,t,n);return[r.fused.matMul({a:rO("a",e,t,n),b:rO("b",e,t,n),transposeA:rO("transposeA",e,t,n),transposeB:rO("transposeB",e,t,n),bias:c,activation:a,preluActivationWeights:h,leakyreluAlpha:l})];case"MatrixBandPart":return[r.linalg.bandPart(rO("a",e,t,n),rO("numLower",e,t,n),rO("numUpper",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},bM=(e,t,n,r=G)=>{switch(e.op){case"EuclideanNorm":return[r.euclideanNorm(rO("x",e,t,n),rO("axis",e,t,n),rO("keepDims",e,t,n))];case"FusedBatchNorm":case"FusedBatchNormV2":return[r.batchNorm(rO("x",e,t,n),rO("mean",e,t,n),rO("variance",e,t,n),rO("offset",e,t,n),rO("scale",e,t,n),rO("epsilon",e,t,n))];case"FusedBatchNormV3":return[r.batchNorm(rO("x",e,t,n),rO("mean",e,t,n),rO("variance",e,t,n),rO("offset",e,t,n),rO("scale",e,t,n),rO("epsilon",e,t,n))];case"LRN":return[r.localResponseNormalization(rO("x",e,t,n),rO("radius",e,t,n),rO("bias",e,t,n),rO("alpha",e,t,n),rO("beta",e,t,n))];case"Softmax":return[r.softmax(rO("x",e,t,n))];case"LogSoftmax":return[r.logSoftmax(rO("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},xM=(e,t,n,r=G)=>{switch(e.op){case"RaggedGather":{const{outputNestedSplits:s,outputDenseValues:a}=r.raggedGather(rO("paramsNestedSplits",e,t,n),rO("paramsDenseValues",e,t,n),rO("indices",e,t,n),rO("outputRaggedRank",e,t,n));return s.concat(a)}case"RaggedRange":{const{rtNestedSplits:s,rtDenseValues:a}=r.raggedRange(rO("starts",e,t,n),rO("limits",e,t,n),rO("splits",e,t,n));return[s,a]}case"RaggedTensorToTensor":return[r.raggedTensorToTensor(rO("shape",e,t,n),rO("values",e,t,n),rO("defaultValue",e,t,n),rO("rowPartitionTensors",e,t,n),rO("rowPartitionTypes",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},wM=(e,t,n,r=G)=>{switch(e.op){case"Max":{const s=rO("axis",e,t,n),a=rO("keepDims",e,t,n);return[r.max(rO("x",e,t,n),s,a)]}case"Mean":{const s=rO("axis",e,t,n),a=rO("keepDims",e,t,n);return[r.mean(rO("x",e,t,n),s,a)]}case"Min":{const s=rO("axis",e,t,n),a=rO("keepDims",e,t,n);return[r.min(rO("x",e,t,n),s,a)]}case"Sum":{const s=rO("axis",e,t,n),a=rO("keepDims",e,t,n);return[r.sum(rO("x",e,t,n),s,a)]}case"All":{const s=rO("axis",e,t,n),a=rO("keepDims",e,t,n);return[r.all(rO("x",e,t,n),s,a)]}case"Any":{const s=rO("axis",e,t,n),a=rO("keepDims",e,t,n);return[r.any(rO("x",e,t,n),s,a)]}case"ArgMax":{const s=rO("axis",e,t,n);return[r.argMax(rO("x",e,t,n),s)]}case"ArgMin":{const s=rO("axis",e,t,n);return[r.argMin(rO("x",e,t,n),s)]}case"Prod":{const s=rO("axis",e,t,n),a=rO("keepDims",e,t,n);return[r.prod(rO("x",e,t,n),s,a)]}case"Cumprod":{const s=rO("axis",e,t,n),a=rO("exclusive",e,t,n),i=rO("reverse",e,t,n);return[r.cumprod(rO("x",e,t,n),s,a,i)]}case"Cumsum":{const s=rO("axis",e,t,n),a=rO("exclusive",e,t,n),i=rO("reverse",e,t,n);return[r.cumsum(rO("x",e,t,n),s,a,i)]}case"Bincount":const s=rO("x",e,t,n),a=rO("weights",e,t,n),i=rO("size",e,t,n);return[r.bincount(s,a,i)];case"DenseBincount":{const s=rO("x",e,t,n),a=rO("weights",e,t,n),i=rO("size",e,t,n),o=rO("binaryOutput",e,t,n);return[r.denseBincount(s,a,i,o)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},vM=(e,t,n,r=G)=>{switch(e.op){case"ConcatV2":case"Concat":{const s=rO("n",e,t,n),a=rO("axis",e,t,n);let i=rO("tensors",e,t,n);return i=i.slice(0,s),[r.concat(i,a)]}case"Gather":{const s=rO("x",e,t,n),a=rO("indices",e,t,n);return[r.gather(s,r.cast(a,"int32"),0)]}case"GatherV2":{const s=rO("axis",e,t,n),a=rO("batchDims",e,t,n),i=rO("x",e,t,n),o=rO("indices",e,t,n);return[r.gather(i,r.cast(o,"int32"),s,a)]}case"Reverse":{const s=rO("dims",e,t,n),a=[];for(let e=0;e<s.length;e++)s[e]&&a.push(e);const i=rO("x",e,t,n);return[r.reverse(i,a)]}case"ReverseV2":{const s=rO("axis",e,t,n),a=rO("x",e,t,n);return[r.reverse(a,s)]}case"Slice":{const s=rO("begin",e,t,n),a=rO("size",e,t,n);return[r.slice(rO("x",e,t,n),s,a)]}case"StridedSlice":{const s=rO("begin",e,t,n),a=rO("end",e,t,n),i=rO("strides",e,t,n),o=rO("beginMask",e,t,n),u=rO("endMask",e,t,n),l=rO("ellipsisMask",e,t,n),c=rO("newAxisMask",e,t,n),h=rO("shrinkAxisMask",e,t,n),p=rO("x",e,t,n);return[r.stridedSlice(p,s,a,i,o,u,l,c,h)]}case"Pack":return uu((()=>{const s=rO("axis",e,t,n),a=rO("tensors",e,t,n),i=a[0].shape,o=r.squeeze(a[0]).shape,u=a.map((e=>{const t=Te(e.shape,i);if(!t&&!Te(r.squeeze(e).shape,o))throw new Error("the input tensors shape does not match");return t?e:r.reshape(e,i)}));return[r.stack(u,s)]}));case"Unpack":{const s=rO("axis",e,t,n),a=rO("tensor",e,t,n);return r.unstack(a,s)}case"Tile":{const s=rO("reps",e,t,n);return[r.tile(rO("x",e,t,n),s)]}case"Split":case"SplitV":{const s=rO("axis",e,t,n),a=rO("numOrSizeSplits",e,t,n),i=rO("x",e,t,n);return r.split(i,a,s)}case"ScatterNd":{const s=rO("indices",e,t,n),a=rO("values",e,t,n),i=rO("shape",e,t,n);return[r.scatterND(s,a,i)]}case"GatherNd":{const s=rO("x",e,t,n),a=rO("indices",e,t,n);return[r.gatherND(s,a)]}case"SparseToDense":{const s=rO("sparseIndices",e,t,n),a=rO("outputShape",e,t,n),i=rO("sparseValues",e,t,n),o=rO("defaultValue",e,t,n);return[r.sparseToDense(s,i,a,i.dtype===o.dtype?o:r.cast(o,i.dtype))]}case"TensorScatterUpdate":{const s=rO("indices",e,t,n),a=rO("values",e,t,n),i=rO("tensor",e,t,n);return[r.tensorScatterUpdate(i,s,a)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},kM=(e,t,n,r=G)=>{switch(e.op){case"SparseFillEmptyRows":{const{outputIndices:s,outputValues:a,emptyRowIndicator:i,reverseIndexMap:o}=r.sparse.sparseFillEmptyRows(rO("indices",e,t,n),rO("values",e,t,n),rO("denseShape",e,t,n),rO("defaultValue",e,t,n));return[s,a,i,o]}case"SparseReshape":{const{outputIndices:s,outputShape:a}=r.sparse.sparseReshape(rO("inputIndices",e,t,n),rO("inputShape",e,t,n),rO("newShape",e,t,n));return[s,a]}case"SparseSegmentMean":{const s=r.sparse.sparseSegmentMean(rO("data",e,t,n),rO("indices",e,t,n),rO("segmentIds",e,t,n));return[s]}case"SparseSegmentSum":{const s=r.sparse.sparseSegmentSum(rO("data",e,t,n),rO("indices",e,t,n),rO("segmentIds",e,t,n));return[s]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},IM=(e,t,n,r=G)=>{switch(e.op){case"FFT":return[r.fft(rO("x",e,t,n))];case"IFFT":return[r.ifft(rO("x",e,t,n))];case"RFFT":return[r.rfft(rO("x",e,t,n))];case"IRFFT":return[r.irfft(rO("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},NM=(e,t,n,r=G)=>{switch(e.op){case"StaticRegexReplace":return[r.string.staticRegexReplace(rO("input",e,t,n),rO("pattern",e,t,n),rO("rewrite",e,t,n),rO("replaceGlobal",e,t,n))];case"StringNGrams":{const{nGrams:s,nGramsSplits:a}=r.string.stringNGrams(rO("data",e,t,n),rO("dataSplits",e,t,n),rO("separator",e,t,n),rO("nGramWidths",e,t,n),rO("leftPad",e,t,n),rO("rightPad",e,t,n),rO("padWidth",e,t,n),rO("preserveShortSequences",e,t,n));return[s,a]}case"StringSplit":{const{indices:s,values:a,shape:i}=r.string.stringSplit(rO("input",e,t,n),rO("delimiter",e,t,n),rO("skipEmpty",e,t,n));return[s,a,i]}case"StringToHashBucketFast":{const s=r.string.stringToHashBucketFast(rO("input",e,t,n),rO("numBuckets",e,t,n));return[s]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},SM=(e,t,n,r=G)=>{switch(e.op){case"Cast":return[r.cast(rO("x",e,t,n),rO("dtype",e,t,n))];case"ExpandDims":{const s=rO("axis",e,t,n);return[r.expandDims(rO("x",e,t,n),s)]}case"Squeeze":{const s=rO("axis",e,t,n);return[r.squeeze(rO("x",e,t,n),s)]}case"Reshape":return[r.reshape(rO("x",e,t,n),rO("shape",e,t,n))];case"EnsureShape":return[r.ensureShape(rO("x",e,t,n),rO("shape",e,t,n))];case"MirrorPad":return[r.mirrorPad(rO("x",e,t,n),rO("padding",e,t,n),rO("mode",e,t,n))];case"PadV2":case"Pad":return[r.pad(rO("x",e,t,n),rO("padding",e,t,n),rO("constantValue",e,t,n))];case"SpaceToBatchND":{const s=rO("blockShape",e,t,n),a=rO("paddings",e,t,n);return[r.spaceToBatchND(rO("x",e,t,n),s,a)]}case"BatchToSpaceND":{const s=rO("blockShape",e,t,n),a=rO("crops",e,t,n);return[r.batchToSpaceND(rO("x",e,t,n),s,a)]}case"DepthToSpace":{const s=rO("blockSize",e,t,n),a=rO("dataFormat",e,t,n).toUpperCase();return[r.depthToSpace(rO("x",e,t,n),s,a)]}case"BroadcastTo":return[r.broadcastTo(rO("x",e,t,n),rO("shape",e,t,n))];case"BroadcastArgs":return[r.broadcastArgs(rO("s0",e,t,n),rO("s1",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function TM(e,t,n,r,s=uu){const a=((e,t,n)=>{switch(e.category){case"arithmetic":return s((()=>qO(e,t,n)));case"basic_math":return s((()=>KO(e,t,n)));case"control":return aM(e,t,n);case"convolution":return s((()=>oM(e,t,n)));case"creation":return s((()=>uM(e,t,n)));case"dynamic":return cM(e,t,n);case"evaluation":return s((()=>hM(e,t,n)));case"image":return s((()=>mM(e,t,n)));case"graph":return s((()=>pM(e,t,n)));case"logical":return s((()=>gM(e,t,n)));case"matrices":return s((()=>yM(e,t,n)));case"normalization":return s((()=>bM(e,t,n)));case"ragged":return s((()=>xM(e,t,n)));case"reduction":return s((()=>wM(e,t,n)));case"slice_join":return s((()=>vM(e,t,n)));case"sparse":return s((()=>kM(e,t,n)));case"spectral":return s((()=>IM(e,t,n)));case"string":return s((()=>NM(e,t,n)));case"transformation":return s((()=>SM(e,t,n)));case"hash_table":return fM(e,t,n,r);case"custom":const a=tO(e.op);if(a&&a.customExecutor)return a.customExecutor(new jO(e,t,n));throw TypeError(`Custom op ${e.op} is not registered.`);default:throw TypeError(`Unknown op '${e.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(e,t,n);return at(a)?a.then((e=>[].concat(e))):[].concat(a)}class $M{constructor(e={},t={},n={},r={},s){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=n,this.functionMap=r,this.parseNodeNameCache=s,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const n=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(n))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map((e=>0===e.id&&0===e.iterationId?"":`${e.frameName}-${e.iterationId}`)).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function CM(e,t,n,r){const s=new Set,a=[];let i=null,o=null;const u=new Set,l=new Set(Object.keys(e).map((e=>uO(e)[0])));r=r||[];const c=new Set(r.map((e=>uO(e.name)[0]))),h=[...t];while(h.length>0){const e=h.pop();(LM(e)||zM(e)||PM(e))&&null==i&&(i=e,o=i.children.map((e=>e.name)).filter((e=>s.has(e)))),s.add(e.name),null==n[e.name]&&(l.has(e.name)||c.has(e.name)||(0!==e.inputs.length?e.inputs.forEach((e=>{u.has(e.name)||(u.add(e.name),h.push(e))})):a.push(e.name)))}return{inputs:e,outputs:t,usedNodes:s,missingInputs:a,dynamicNode:i,syncInputs:o}}function EM(e,t){const{usedNodes:n,inputs:r}=t,s=Object.keys(r).map((e=>uO(e)[0])).map((t=>e.nodes[t])),a=e.initNodes||[],i=e=>n.has("string"===typeof e?e:e.name);function o(e){return[...new Map(e.map((e=>[e.name,e]))).values()]}const u=o([...s,...e.weights,...a]).filter(i),l=o([...u,...Object.values(e.nodes)]).filter(i),c=new Map(l.map((e=>[e.name,e]))),h={};for(const g of l){h[g.name]=h[g.name]||0;for(const e of g.children)i(e)||(h[e.name]=Number.POSITIVE_INFINITY),h[e.name]=(h[e.name]||0)+1}const p=Object.entries(h).filter((([,e])=>0===e)).map((([e])=>e)),d=[...p];while(p.length>0){const e=p.pop(),t=c.get(e);for(const n of t.children.filter(i))0===--h[n.name]&&(d.push(n.name),p.push(n.name))}const f=d.map((e=>c.get(e))),m=RM(f,u);return FM(m,u),m}function RM(e,t){const n=new Map(e.map((e=>[e.name,e]))),r=t.map((e=>e.name)),s=new Set(r);while(r.length>0){const e=r.pop(),t=n.get(e);for(const a of t.children)n.has(a.name)&&!s.has(a.name)&&(s.add(a.name),r.push(a.name))}const a=e.filter((e=>s.has(e.name)));return a}class AM extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}}function FM(e,t){const n=new Map(e.map(((e,t)=>[e.name,t]))),r=new Set(t.map((e=>e.name))),s=e=>r.has("string"===typeof e?e:e.name),a=new Set(e.map((e=>e.name))),i=e=>a.has("string"===typeof e?e:e.name);for(const o of e){for(const e of o.children.filter(i)){if(!n.has(e.name))throw new AM(`Child ${e.name} of node ${o.name} is unreachable.`);if(n.get(o.name)>n.get(e.name))throw new AM(`Node ${o.name} is scheduled to run after its child ${e.name}.`)}if(!s(o))for(const e of o.inputs){if(!n.has(e.name))throw new AM(`Input ${e.name} of node ${o.name} is unreachable.`);if(n.get(e.name)>n.get(o.name))throw new AM(`Node ${o.name} is scheduled to run before its input ${e.name}.`)}}}function _M(e){const t=new Map(e.map(((e,t)=>[e.name,t]))),n=Number.MAX_SAFE_INTEGER,r=e.map(((e,t)=>LM(e)?n:t)),s=e=>{const n=r[t.get(e.name)];return null==n?-1:n},a=e.map(((e,t)=>e.children.map(s).reduce(((e,t)=>Math.max(e,t)),r[t]))),i=new Map;for(let o=0;o<e.length;++o){const t=a[o];if(t===n)continue;const r=e[o],s=e[t];i.has(s.name)||i.set(s.name,[]),i.get(s.name).push(r)}return i}const DM=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),OM=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),MM=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function LM(e){return DM.has(e.op)}function zM(e){return OM.has(e.op)}function PM(e){return MM.has(e.op)}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class BM{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map((t=>e[t].map((e=>e.id))));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map((e=>({name:e.name,shape:e.attrParams["shape"]?e.attrParams["shape"].value:void 0,dtype:e.attrParams["dtype"]?e.attrParams["dtype"].value:void 0})))}get outputs(){return this._outputs.map((e=>({name:e.name,shape:e.attrParams["shape"]?e.attrParams["shape"].value:void 0,dtype:e.attrParams["dtype"]?e.attrParams["dtype"].value:void 0})))}get inputNodes(){return this._inputs.map((e=>e.signatureKey||e.name))}get outputNodes(){return this._outputs.map((e=>{const t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t}))}get functions(){return Object.keys(this._functions).reduce(((e,t)=>(e[t]=this._functions[t].signature,e)),{})}constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,null!=e.functions&&Object.keys(e.functions).forEach((t=>{this._functionExecutorMap[t]=new BM(e.functions[t],this)}))}getCompilationKey(e,t){const n=e.map((e=>e.name)).sort(),r=t.map((e=>e.name)).sort();return n.join(this.SEPARATOR)+"--"+r.join(this.SEPARATOR)}compile(e,t){const n=CM(e,t,this.weightMap,this._initNodes),{missingInputs:r,dynamicNode:s,syncInputs:a}=n;if(null!=s)throw new Error(`This execution contains the node '${s.name}', which has the dynamic op '${s.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${a}]`);if(r.length>0){const n=t.map((e=>e.name)),s=Object.keys(e);throw new Error(`Cannot compute the outputs [${n}] from the provided inputs [${s}]. Missing the following inputs: [${r}]`)}const i=EM(this.graph,n),o=_M(i);return{orderedNodes:i,nodeLiveUntilMap:o}}cloneAndKeepTensor(e){if(null==e)return null;const t=e.clone();return cu(t),t}cloneTensorList(e){if(!e)return null;const t=e.map((e=>this.cloneAndKeepTensor(e)));return t}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map((([e,t])=>[e,this.cloneTensorList(t)])))}execute(e,t){this.disposeIntermediateTensors(),e=this.mapInputs(e);const n=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);const r=n.map((e=>this.graph.nodes[uO(e)[0]])),s=t.map((e=>uO(e)[0])),a=new Set(s);let i=s.map((e=>this.graph.nodes[e]));0===i.length&&(i=this._outputs);const o=this.getCompilationKey(r,i);let u=this.compiledMap.get(o);null==u&&(u=this.compile(e,i),this.compiledMap.set(o,u));try{this.keepIntermediateTensors=ht().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(h){this.keepIntermediateTensors=!1,console.warn(h.message)}const l={},c={};return uu((()=>{const n=new $M(this.weightMap,l,c,this.functionExecutorMap,this.parseNodeNameCache),r=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach((t=>{const[s,a]=uO(t,n),i=[];i[a]=e[t],r[s]=i,this.keepIntermediateTensors&&(this.clonedTensorsMap[s]=this.cloneTensorList(i))}));const s=this.getFrozenTensorIds(r),{orderedNodes:i,nodeLiveUntilMap:o}=u;for(const e of i){if(r[e.name])continue;const t=TM(e,r,n,this._resourceManager);if(at(t))throw new Error(`The execution of the op '${e.op}' returned a promise. Please use model.executeAsync() instead.`);r[e.name]=t,this.keepIntermediateTensors&&(this.clonedTensorsMap[e.name]=this.cloneTensorList(t)),this.checkTensorForDisposalWithNodeLiveUntilInfo(e,r,n,s,a,o.get(e.name))}return null==this.parent&&n.dispose(s),t.map((e=>sO(e,r,n)))}))}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map((t=>e[t])).map((e=>e.map((e=>e.id)))));return new Set(t)}checkTensorForDisposal(e,t,n,r,s,a,i){if(!LM(t)&&!a.has(e)){for(const r of n[e])null!=r&&(i[r.id]=(i[r.id]||0)+t.children.length);for(const e of t.inputs){if(LM(e))continue;const t=aO(e.name,n,r);if(null!=t)for(const e of t){if(!e||e.kept||s.has(e.id))continue;const t=i[e.id];1===t?(e.dispose(),delete i[e.id]):null!=t&&i[e.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(e,t,n,r,s,a){function i(e){return LM(e)||s.has(e.name)}if(!LM(e)&&null!=a)for(const o of a){if(i(o))continue;const e=aO(o.name,t,n);for(const t of e)!t||t.kept||r.has(t.id)||t.dispose()}}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach((e=>{for(const t of e)t&&!t.isDisposed&&t.dispose()})),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,t,n=!1,r={},s={}){this.disposeIntermediateTensors(),n||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepIntermediateTensors=ht().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(h){this.keepIntermediateTensors=!1,console.warn(h.message)}const a=new $M(this.weightMap,r,s,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const i=await this.executeWithControlFlow(e,a,t,n),o=t.map((e=>sO(e,i,a))),u=o.map((e=>e.id)),l=Object.keys(e).map((t=>e[t].id)),c=new Set([...u,...l,...this.weightIds]);return Object.values(i).forEach((e=>{e.forEach((e=>{!e||e.isDisposed||c.has(e.id)||e.dispose()}))})),null==this.parent&&a.dispose(c),o}async executeFunctionAsync(e,t,n){const r=e.reduce(((e,t,n)=>(e[this.inputs[n].name]=t,e)),{});return this._executeAsync(r,this.outputNodes,!0,t,n)}async executeWithControlFlow(e,t,n,r){const s=Object.keys(e),a=s.map((e=>this.graph.nodes[uO(e)[0]])),i=n.map((e=>uO(e)[0])),o=new Set(i);let u=i.map((e=>this.graph.nodes[e]));0===u.length&&(u=this._outputs);const{usedNodes:l,missingInputs:c,dynamicNode:h,syncInputs:p}=CM(e,u,this.weightMap,this._initNodes),d=[...a,...this.graph.weights,...this._initNodes||[]].map((e=>({node:e,contexts:t.currentContext}))),f=Object.assign({},this.weightMap);Object.keys(e).forEach((t=>{const[n,r]=uO(t),s=[];s[r]=e[t],f[n]=s}));const m={},g=this.getFrozenTensorIds(f),y={};while(d.length>0){const e=this.processStack(a,d,t,f,y,g,o,m,l);await Promise.all(e)}null!=h||r||console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const b=u.filter((e=>!LM(e)&&!sO(e.name,f,t))).map((e=>e.name));if(b.length>0){let e="";throw null!=h&&(e=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${p}]`),new Error(`Cannot compute the outputs [${b}] from the provided inputs [${s}]. Consider providing the following inputs: [${c}]. ${e}`)}return f}processStack(e,t,n,r,s,a,i,o,u){const l=[];while(t.length>0){const e=t.pop();n.currentContext=e.contexts;let c="";if("Enter"===e.node.op&&rO("isConstant",e.node,r,n)&&([c]=iO(e.node.name,n)),null==r[e.node.name]){const h=TM(e.node,r,n,this._resourceManager);c||([c]=iO(e.node.name,n));const p=n.currentContext;at(h)?l.push(h.then((l=>(r[c]=l,this.keepIntermediateTensors&&(this.clonedTensorsMap[c]=this.cloneTensorList(l)),n.currentContext=p,this.checkTensorForDisposal(c,e.node,r,n,a,i,o),this.processChildNodes(e.node,t,n,r,s,u),l)))):(r[c]=h,this.keepIntermediateTensors&&(this.clonedTensorsMap[c]=this.cloneTensorList(h)),this.checkTensorForDisposal(c,e.node,r,n,a,i,o),this.processChildNodes(e.node,t,n,r,s,u))}else this.processChildNodes(e.node,t,n,r,s,u)}return l}processChildNodes(e,t,n,r,s,a){e.children.forEach((e=>{const[i]=iO(e.name,n);!s[i]&&a.has(e.name)&&("Merge"===e.op?e.inputNames.some((e=>!!sO(e,r,n)))&&(s[i]=!0,t.push({contexts:n.currentContext,node:e})):e.inputNames.every((e=>!!sO(e,r,n)))&&(s[i]=!0,t.push({contexts:n.currentContext,node:e})))}))}dispose(){Object.keys(this.weightMap).forEach((e=>this.weightMap[e].forEach((e=>e.dispose()))))}checkInputShapeAndType(e){Object.keys(e).forEach((t=>{const n=e[t],[r]=uO(t),s=this.graph.nodes[r];if(s.attrParams["shape"]&&s.attrParams["shape"].value){const e=s.attrParams["shape"].value,t=e.length===n.shape.length&&n.shape.every(((t,n)=>-1===e[n]||e[n]===t));we(t,(()=>`The shape of dict['${s.name}'] provided in model.execute(dict) must be [${e}], but was [${n.shape}]`))}s.attrParams["dtype"]&&s.attrParams["dtype"].value&&we(n.dtype===s.attrParams["dtype"].value,(()=>`The dtype of dict['${s.name}'] provided in model.execute(dict) must be ${s.attrParams["dtype"].value}, but was ${n.dtype}`))}))}mapInputs(e){var t,n;const r={};for(const s in e){const a=null===(n=null===(t=this._signature)||void 0===t?void 0:t.inputs)||void 0===n?void 0:n[s];null!=a?r[a.name]=e[s]:r[s]=e[s]}return r}checkInputs(e){const t=Object.keys(e).filter((e=>{const[t]=uO(e);return null==this.graph.nodes[t]}));if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map((e=>{var t,n;const r=null===(n=null===(t=this._signature)||void 0===t?void 0:t.outputs)||void 0===n?void 0:n[e];return null!=r?r.name:e}),{})}checkOutputs(e){e.forEach((e=>{const[t]=uO(e);if(!this.graph.nodes[t])throw new Error(`The output '${e}' is not found in the graph`)}))}}class WM{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const VM="?tfjs-format=file",UM="model.json";class GM{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e,t={},n=u){this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=n,null==t&&(this.loadOptions={}),this.resourceManager=new WM}findIOHandler(){const e=this.modelUrl;if(null!=e.load)this.handler=e;else if(null!=this.loadOptions.requestInit)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{const t=this.io.getLoadHandlers(e,this.loadOptions);if(0===t.length)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=this.handler.load();return at(e)?e.then((e=>this.loadSync(e))):this.loadSync(e)}loadSync(e){this.artifacts=e;const t=this.artifacts.modelTopology;let n=this.artifacts.signature;if(null!=this.artifacts.userDefinedMetadata){const e=this.artifacts.userDefinedMetadata;null!=e.signature&&(n=e.signature),null!=e.structuredOutputKeys&&(this.structuredOutputKeys=e.structuredOutputKeys)}this.signature=n,this.version=`${t.versions.producer}.${t.versions.minConsumer}`;const r=this.io.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new BM(RO.Instance.transformGraph(t,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(r),this.executor.resourceManager=this.resourceManager,null!=e.modelInitializer&&null!=e.modelInitializer.node){const t=RO.Instance.transformGraph(e.modelInitializer);this.initializer=new BM(t),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if("string"===typeof e){const t=this.io.getSaveHandlers(e);if(0===t.length)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(t.length>1)throw new Error(`Found more than one (${t.length}) save handlers for URL '${e}'`);e=t[0]}if(null==e.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){const t=e instanceof ja?[e]:e,n={};return t.forEach(((e,t)=>n[this.structuredOutputKeys[t]]=e)),n}return e}predict(e,t){const n=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(n)}async predictAsync(e,t){const n=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(n)}normalizeInputs(e){var t;if(!(e instanceof ja)&&!Array.isArray(e)){const n=null===(t=this.signature)||void 0===t?void 0:t.inputs;if(null!=n)for(const t in n){const r=n[t];null!=r.resourceId&&(e[t]=this.resourceIdToCapturedInput[r.resourceId])}return e}e=Array.isArray(e)?e:[e];const n=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+n!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-n} non-resource placeholders, while there are ${e.length} input tensors provided.`);let r=0;return this.inputNodes.reduce(((t,n)=>{var s,a,i;const o=null===(i=null===(a=null===(s=this.signature)||void 0===s?void 0:s.inputs)||void 0===a?void 0:a[n])||void 0===i?void 0:i.resourceId;return t[n]=null!=o?this.resourceIdToCapturedInput[o]:e[r++],t}),{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return null==this.initializer?[]:null==this.initializerSignature?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return null==this.initializer?[]:null==this.initializerSignature?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){const t=this.initializerSignature.outputs,n=Object.keys(t);for(let r=0;r<n.length;r++){const s=n[r],a=t[s];this.resourceIdToCapturedInput[a.resourceId]=e[r]}}}execute(e,t){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const n=this.executor.execute(e,t);return n.length>1?n:n[0]}async executeAsync(e,t){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const n=await this.executor.executeAsync(e,t);return n.length>1?n:n[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce(((t,n)=>(t[n]=[e[n]],t)),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&lu(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}async function HM(e,t={},n=u){if(null==e)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==t&&(t={}),t.fromTFHub&&"string"===typeof e&&(e=qM(e));const r=new GM(e,t,n);return await r.load(),r}function jM(e){if(null==e)throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");let t;if(e instanceof Array){const[n,r]=e;if(!n)throw new Error("modelJSON must be the first element of the array");if(!r||!(r instanceof ArrayBuffer))throw new Error("An ArrayBuffer of weights must be the second element of the array");if(!("modelTopology"in n))throw new Error("Model JSON is missing 'modelTopology'");if(!("weightsManifest"in n))throw new Error("Model JSON is missing 'weightsManifest'");const s=Zi(n.weightsManifest),a=Xi(n,s,r);t=Vl(a)}else if("load"in e)t=e;else{if(!("modelTopology"in e&&"weightSpecs"in e&&"weightData"in e))throw new Error("Unknown model format");t=Vl(e)}const n=new GM(t);return n.load(),n}function qM(e){return e.endsWith("/")||(e+="/"),`${e}${UM}${VM}`}
/** @license See the LICENSE file. */
const KM="4.11.0";
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
function XM(e,t){return YM(e,t)}function YM(e,t,n=new Map,r=new Set){if(null==e)return null;if("function"===typeof Blob&&e instanceof Blob)return e.slice();if(r.has(e))throw new Error("Circular references are not supported.");if(n.has(e))return n.get(e);const s=t(e);if(s.recurse&&null!==s.value)throw new Error("A deep map function may not return both a value and recurse=true.");if(s.recurse){if(tL(e)){const s=Array.isArray(e)?[]:{};r.add(e);for(const a in e){const i=e[a],o=YM(i,t,n,r);s[a]=o}return r.delete(e),e.__proto__&&(s.__proto__=e.__proto__),s}throw new Error(`Can't recurse into non-iterable type: ${e}`)}return n.set(e,s.value),s.value}function JM(e,t=QM){return ZM(e,t)}function ZM(e,t,n=new Set){const r=e[0];if(n.has(r))throw new Error("Circular references are not supported.");const s=t(e);if(s.recurse&&null!==s.value)throw new Error("A deep zip function may not return both a value and recurse=true.");if(s.recurse){if(tL(r)){const s=Array.isArray(r)?[]:{};n.add(r);for(const a in r){const r=e.map((e=>e[a])),i=ZM(r,t,n);s[a]=i}return n.delete(r),s}throw new Error(`Can't recurse into non-iterable type: ${r}`)}return s.value}function QM(e){return null===e?null:tL(e[0])?{value:null,recurse:!0}:{value:e,recurse:!1}}async function eL(e,t){const n=new Map;YM(e,t,n);for(const s of Array.from(n.keys())){const e=n.get(s);if(at(e)){const t=await e;n.set(s,t)}}const r=YM(e,t,n);return r}function tL(e){let t=!1;if(ht().get("IS_BROWSER"))t=e instanceof TextDecoder;else{const{StringDecoder:r}=n(80551);t=e instanceof r}return null!=e&&!ArrayBuffer.isView(e)&&(Array.isArray(e)||"object"===typeof e&&!(e instanceof ja)&&!(e instanceof Promise)&&!t)}function nL(e){return null==e||rL(e)||Array.isArray(e)||"object"===typeof e&&e instanceof ja||Ia(e)}function rL(e){return null===e||"object"!==typeof e&&"function"!==typeof e}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
function sL(e){return XM(e,aL)}function aL(e){return e instanceof ja?{value:e.clone(),recurse:!1}:tL(e)?{value:null,recurse:!0}:{value:e,recurse:!1}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
class iL{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,null==e)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){while(e<0)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return 0===this.length()}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(const t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);const e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const t=this.wrap(this.begin+e),n=this.get(t);return this.set(t,this.pop()),n}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
class oL extends iL{constructor(){super(oL.INITIAL_CAPACITY)}isFull(){return!1}push(e){super.isFull()&&this.expand(),super.push(e)}unshift(e){super.isFull()&&this.expand(),super.unshift(e)}expand(){const e=2*this.capacity,t=new Array(e),n=this.length();for(let r=0;r<n;r++)t[r]=this.get(this.wrap(this.begin+r));this.data=t,this.capacity=e,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=n}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
function uL(e){return new dL(e)}function lL(e){return new fL(e)}function cL(e,t){return new SL(e,t)}function hL(e,t=TL.FAIL){return new $L(e,t)}oL.INITIAL_CAPACITY=32;class pL{async toArray(){const e=[];let t=await this.next();while(!t.done)e.push(t.value),t=await this.next();return e}async toArrayForTest(){const e=this.prefetch(100),t=[];let n=await e.next();while(!n.done)t.push(n.value),n=await e.next();return t}async resolveFully(){let e=await this.next();while(!e.done)e=await this.next()}async resolveWhile(e){let t=await this.next(),n=e(t.value);while(!t.done&&n)t=await this.next(),n=e(t.value)}handleErrors(e){return new vL(this,e)}filter(e){return new xL(this,e)}map(e){return new wL(this,e)}mapAsync(e){return new kL(this,e)}serialMapAsync(e){return new kL(this,e).serial()}flatmap(e){return new NL(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile((e=>!0===e))}rowMajorBatch(e,t=!0){return new bL(this,e,t)}columnMajorBatch(e,t=!0,n=QM){const r=this.rowMajorBatch(e,t);return r.map((e=>JM(e,n)))}concatenate(e,t){return new SL(uL([this,e]),t)}take(e){return e<0||null==e?this:new yL(this,e)}skip(e){return e<0||null==e?this:new gL(this,e)}prefetch(e){return new CL(this,e)}shuffle(e,t){return new EL(this,e,t)}serial(){return new mL(this)}}class dL extends pL{constructor(e){super(),this.items=e,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};const e=this.items[this.trav];return this.trav++,{value:sL(e),done:!1}}}class fL extends pL{constructor(e){super(),this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(e){throw e.message=`Error thrown while iterating through a dataset: ${e.message}`,e}}}class mL extends pL{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){return this.upstream.next()}}class gL extends pL{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){while(this.count++<this.maxCount){const e=await this.upstream.next();if(e.done)return e;lu(e.value)}return this.upstream.next()}}class yL extends pL{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}}class bL extends pL{constructor(e,t,n=!0){super(),this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){const e=[];while(e.length<this.batchSize){const t=await this.upstream.next();if(t.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(t.value)}return{value:e,done:!1}}}class xL extends pL{constructor(e,t){super(),this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){while(1){const e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;lu(e.value)}}}class wL extends pL{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Map`}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=ui(e.value),n=this.transform(e.value),r=ui(n);for(const s of t)oi(s,r)||s.dispose();return{value:n,done:!1}}}class vL extends pL{constructor(e,t){super(),this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){while(1)try{return await this.upstream.next()}catch(e){if(!this.handler(e))return{value:null,done:!0}}}}class kL extends pL{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=ui(e.value),n=await this.transform(e.value),r=ui(n);for(const s of t)oi(s,r)||s.dispose();return{value:n,done:!1}}}class IL extends pL{constructor(){super(),this.outputQueue=new oL,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){while(0===this.outputQueue.length())if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}}class NL extends IL{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){const e=await this.upstream.next();if(e.done)return!1;const t=ui(e.value),n=this.transform(e.value),r=ui(n);this.outputQueue.pushAll(n);for(const s of t)oi(s,r)||s.dispose();return!0}}class SL extends pL{constructor(e,t){super(),this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){const e="TODO: fill in upstream of chained summaries";return`${e} -> Chained`}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,null==this.iterator){const e=await this.moreIterators.next();if(e.done)return{value:null,done:!0};this.iterator=e.value,null!=this.baseErrorHandler&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}const t=await this.iterator.next();return t.done?(this.iterator=null,this.readFromChain(e)):t}}var TL;(function(e){e[e["FAIL"]=0]="FAIL",e[e["SHORTEST"]=1]="SHORTEST",e[e["LONGEST"]=2]="LONGEST"})(TL||(TL={}));class $L extends pL{constructor(e,t=TL.FAIL){super(),this.iterators=e,this.mismatchMode=t,this.count=0,this.currentPromise=null}summary(){const e="TODO: fill in upstream of zip summaries";return`{${e}} -> Zip`}async nextState(e){await e;let t=0,n=0;function r(e){if(e instanceof pL){const r=e.next();return{value:r.then((e=>(t++,e.done&&n++,e.value))),recurse:!1}}return{value:null,recurse:!0}}const s=await eL(this.iterators,r);if(t===n)return{value:null,done:!0};if(n>0)switch(this.mismatchMode){case TL.FAIL:throw new Error(`Zipped streams should have the same length. Mismatched at element ${this.count}.`);case TL.SHORTEST:return{value:null,done:!0};case TL.LONGEST:default:}return this.count++,{value:s,done:!1}}async next(){return this.currentPromise=this.nextState(this.currentPromise),this.currentPromise}}class CL extends pL{constructor(e,t){super(),this.upstream=e,this.bufferSize=t,this.buffer=new iL(t)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){while(!this.buffer.isFull()){const e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}}class EL extends CL{constructor(e,t,n){super(e,t),this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=og.alea(n||xa().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){this.upstreamExhausted||this.refill();while(!this.buffer.isEmpty()){const e=this.chooseIndex(),t=await this.buffer.shuffleExcise(e);if(!t.done)return this.refill(),t;this.upstreamExhausted=!0}return{value:null,done:!0}}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
class RL{constructor(){this.size=null}batch(e,t=!0){const n=this;let r;return we(e>0,(()=>`batchSize needs to be positive, but it is\n      ${e}`)),r=this.size===1/0||null==this.size?this.size:t?Math.ceil(this.size/e):Math.floor(this.size/e),AL((async()=>(await n.iterator()).columnMajorBatch(e,t,DL)),r)}concatenate(e){const t=this;let n;return n=this.size===1/0||e.size===1/0?1/0:null!=this.size&&null!=e.size?this.size+e.size:null,AL((async()=>(await t.iterator()).concatenate(await e.iterator())),n)}filter(e){const t=this;let n;return n=this.size===1/0?1/0:null,AL((async()=>(await t.iterator()).filter((t=>uu((()=>e(t)))))),n)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){const t=this;return AL((async()=>(await t.iterator()).map((t=>uu((()=>e(t)))))),this.size)}mapAsync(e){const t=this;return AL((async()=>(await t.iterator()).mapAsync(e)),this.size)}prefetch(e){if(null==e)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");const t=this;return AL((async()=>(await t.iterator()).prefetch(e)),this.size)}repeat(e){const t=this;let n;return n=null!=this.size&&e>0?this.size*e:0===e?0:null!=this.size&&(void 0===e||e<0)?1/0:null,AL((async()=>{const n=lL((async()=>({value:await t.iterator(),done:!1})));return cL(n.take(e))}),n)}skip(e){const t=this;let n;return n=null!=this.size&&e>=0&&this.size>=e?this.size-e:null!=this.size&&(this.size<e||void 0===e||e<0)?0:null,AL((async()=>(await t.iterator()).skip(e)),n)}shuffle(e,t,n=!0){if(null==e||e<0)throw null==this.size?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);const r=this,s=og.alea(t||xa().toString());return AL((async()=>{let t=s.int32();return n&&(t+=s.int32()),(await r.iterator()).shuffle(e,t.toString())}),this.size)}take(e){const t=this;let n;return n=null!=this.size&&this.size>e?e:null!=this.size&&this.size<=e?this.size:null,AL((async()=>(await t.iterator()).take(e)),n)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}}function AL(e,t=null){return new class extends RL{constructor(){super(...arguments),this.size=t}async iterator(){return e()}}}function FL(e){return AL((async()=>uL(e)),e.length)}function _L(e){if(!tL(e))throw new Error("The argument to zip() must be an object or array.");let t;if(Array.isArray(e))for(let n=0;n<e.length;n++)t=null==t?e[n].size:Math.min(t,e[n].size);else if(e instanceof Object)for(const n in e)t=null==t?e[n].size:Math.min(t,e[n].size);return AL((async()=>{const t=await eL(e,(e=>{if(e instanceof RL)return{value:e.iterator(),recurse:!1};if(tL(e))return{value:null,recurse:!0};throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")}));return hL(t,TL.SHORTEST)}),t)}function DL(e){if(null===e)return null;const t=e[0];if(nL(t)){const t=OL(e);return{value:t,recurse:!1}}return{value:null,recurse:!0}}function OL(e){if(0===e.length)throw new Error("Can't make a batch of zero elements.");return e[0]instanceof ja?Sy(e):Di(e)}RL.MAX_BUFFER_SIZE=1e4;
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
class ML extends RL{constructor(e){super(),this.input=e}async iterator(){const e=await this.input.iterator(),t=e.decodeUTF8(),n=t.split("\n").map((e=>(e.endsWith("\r")&&(e=e.slice(0,-1)),e)));return n}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
const LL='"',zL=Symbol("out"),PL=Symbol("field"),BL=Symbol("quote"),WL=Symbol("quoteafterquote"),VL=Symbol("quoteinquote");class UL extends RL{async columnNames(){return this.columnNamesValidated||await this.setColumnNames(),this.configuredColumnsOnly?Object.keys(this.columnConfigs):this.fullColumnNames}async setColumnNames(){const e=await this.maybeReadHeaderLine();if(!this.fullColumnNames&&!e)throw new Error("Column names must be provided if there is no header line.");this.fullColumnNames&&e&&we(e.length===this.fullColumnNames.length,(()=>"The length of provided columnNames ("+this.fullColumnNames.length.toString()+") does not match the length of the header line read from file ("+e.length.toString()+").")),this.fullColumnNames||(this.fullColumnNames=e);const t=this.fullColumnNames.reduce(((e,t)=>(e[t]=e[t]+1||1,e)),{}),n=Object.keys(t).filter((e=>t[e]>1));if(we(0===n.length,(()=>"Duplicate column names found: "+n.toString())),this.columnConfigs)for(const r of Object.keys(this.columnConfigs)){const e=this.fullColumnNames.indexOf(r);if(-1===e)throw new Error('The key "'+r+'" provided in columnConfigs does not match any of the column names ('+this.fullColumnNames.toString()+").")}this.columnNamesValidated=!0}async maybeReadHeaderLine(){if(this.hasHeader){const e=await this.base.iterator(),t=await e.next();if(t.done)throw new Error("No data was found for CSV parsing.");const n=t.value,r=this.parseRow(n,!1);return r}return null}constructor(e,t){super(),this.input=e,this.hasHeader=!0,this.fullColumnNames=null,this.columnNamesValidated=!1,this.columnConfigs=null,this.configuredColumnsOnly=!1,this.delimiter=",",this.delimWhitespace=!1,this.base=new ML(e),t||(t={}),this.hasHeader=!1!==t.hasHeader,this.fullColumnNames=t.columnNames,this.columnConfigs=t.columnConfigs,this.configuredColumnsOnly=t.configuredColumnsOnly,t.delimWhitespace?(we(null==t.delimiter,(()=>"Delimiter should not be provided when delimWhitespace is true.")),this.delimWhitespace=!0,this.delimiter=" "):this.delimiter=t.delimiter?t.delimiter:","}async iterator(){this.columnNamesValidated||await this.setColumnNames();let e=await this.base.iterator();return this.hasHeader&&(e=e.skip(1)),e.map((e=>this.makeDataElement(e)))}makeDataElement(e){const t=this.parseRow(e),n={},r={};for(let s=0;s<this.fullColumnNames.length;s++){const a=this.fullColumnNames[s],i=this.columnConfigs?this.columnConfigs[a]:null;if(!this.configuredColumnsOnly||i){const o=t[s];let u=null;if(""===o)if(i&&void 0!==i.default)u=i.default;else{if(i&&(i.required||i.isLabel))throw new Error(`Required column ${a} is empty in this line: ${e}`);u=void 0}else{const e=Number(o);if(isNaN(e))u=i&&"bool"===i.dtype?this.getBoolean(o):o;else if(i&&i.dtype)switch(i.dtype){case"float32":u=e;break;case"int32":u=Math.floor(e);break;case"bool":u=this.getBoolean(o);break;default:u=e}else u=e}i&&i.isLabel?r[a]=u:n[a]=u}}return 0===Object.keys(r).length?n:{xs:n,ys:r}}getBoolean(e){return"1"===e||"true"===e.toLowerCase()?1:0}parseRow(e,t=!0){const n=[];let r=0;const s=e.length;let a=zL;for(let i=0;i<s;i++)switch(a){case zL:switch(e.charAt(i)){case LL:r=i+1,a=BL;break;case this.delimiter:if(r=i+1," "===this.delimiter&&this.delimWhitespace)break;n.push(""),a=zL;break;default:a=PL,r=i;break}break;case PL:switch(e.charAt(i)){case this.delimiter:n.push(e.substring(r,i)),a=zL,r=i+1;break;default:}break;case BL:switch(e.charAt(i)){case LL:a=WL;break;default:}break;case WL:switch(e.charAt(i)){case this.delimiter:n.push(e.substring(r,i-1)),a=zL,r=i+1;break;case LL:a=BL;break;default:a=VL;break}break;case VL:switch(e.charAt(i)){case LL:a=BL;break;default:}break;default:}if(a===WL?n.push(e.substring(r,s-1)):n.push(e.substring(r)),t&&n.length!==this.fullColumnNames.length)throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${n}`);return n}}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
class GL extends pL{constructor(e){super(),this.microphoneConfig=e,this.isClosed=!1,this.fftSize=e.fftSize||1024;const t=Math.log2(this.fftSize);if(this.fftSize<0||t<4||t>14||!Number.isInteger(t))throw new Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${this.fftSize}`);if(this.numFrames=e.numFramesPerSpectrogram||43,this.sampleRateHz=e.sampleRateHz,this.columnTruncateLength=e.columnTruncateLength||this.fftSize,this.audioTrackConstraints=e.audioTrackConstraints,this.smoothingTimeConstant=e.smoothingTimeConstant||0,this.includeSpectrogram=!1!==e.includeSpectrogram,this.includeWaveform=!0===e.includeWaveform,!this.includeSpectrogram&&!this.includeWaveform)throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.")}summary(){return"microphone"}static async create(e={}){if(!ht().get("IS_BROWSER"))throw new Error("microphone API is only supported in browser environment.");const t=new GL(e);return await t.start(),t}async start(){try{this.stream=await navigator.mediaDevices.getUserMedia({audio:null==this.audioTrackConstraints||this.audioTrackConstraints,video:!1})}catch(n){throw new Error(`Error thrown while initializing video stream: ${n.message}`)}if(!this.stream)throw new Error("Could not obtain audio from microphone.");const e=window.AudioContext||window.webkitAudioContext;if(this.audioContext=new e,this.sampleRateHz){if(this.audioContext.sampleRate!==this.sampleRateHz)throw new Error(`Mismatch in sampling rate: Expected: ${this.sampleRateHz}; Actual: ${this.audioContext.sampleRate}`)}else this.sampleRateHz=this.audioContext.sampleRate;const t=this.audioContext.createMediaStreamSource(this.stream);this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=2*this.fftSize,this.analyser.smoothingTimeConstant=this.smoothingTimeConstant,t.connect(this.analyser),this.freqData=new Float32Array(this.fftSize),this.timeData=new Float32Array(this.fftSize)}async next(){if(this.isClosed)return{value:null,done:!0};let e,t;const n=await this.getAudioData();if(this.includeSpectrogram){const t=this.flattenQueue(n.freqDataQueue);e=this.getTensorFromAudioDataArray(t,[this.numFrames,this.columnTruncateLength,1])}if(this.includeWaveform){const e=this.flattenQueue(n.timeDataQueue);t=this.getTensorFromAudioDataArray(e,[this.numFrames*this.fftSize,1])}return{value:{spectrogram:e,waveform:t},done:!1}}async capture(){return(await this.next()).value}async getAudioData(){const e=[],t=[];let n=0;return new Promise((r=>{const s=setInterval((()=>{this.includeSpectrogram&&(this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-1/0&&r({freqDataQueue:e,timeDataQueue:t}),e.push(this.freqData.slice(0,this.columnTruncateLength))),this.includeWaveform&&(this.analyser.getFloatTimeDomainData(this.timeData),t.push(this.timeData.slice())),++n===this.numFrames&&(clearInterval(s),r({freqDataQueue:e,timeDataQueue:t}))}),this.fftSize/this.sampleRateHz*1e3)}))}stop(){this.isClosed||(this.isClosed=!0,this.analyser.disconnect(),this.audioContext.close(),null!=this.stream&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop())}toArray(){throw new Error("Can not convert infinite audio stream to array.")}getSampleRate(){return this.sampleRateHz}flattenQueue(e){const t=e[0].length,n=new Float32Array(e.length*t);return e.forEach(((e,r)=>n.set(e,r*t))),n}getTensorFromAudioDataArray(e,t){const n=new Float32Array(Ie(t));return n.set(e,n.length-e.length),Di(n,t)}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
class HL extends pL{constructor(e,t){if(super(),this.webcamVideoElement=e,this.webcamConfig=t,this.isClosed=!0,this.resize=!1,this.needToResize())if(this.resize=!0,this.cropSize=[this.webcamConfig.resizeHeight,this.webcamConfig.resizeWidth],this.cropBoxInd=Fy([0],"int32"),this.webcamConfig.centerCrop){const e=1*this.webcamConfig.resizeWidth/this.webcamVideoElement.width,t=1*this.webcamConfig.resizeHeight/this.webcamVideoElement.height,n=(1-e)/2,r=(1-t)/2,s=n+e,a=t+r;this.cropBox=_y([r,n,a,s],[1,4])}else this.cropBox=_y([0,0,1,1],[1,4])}summary(){return"webcam"}static async create(e,t={}){if(!ht().get("IS_BROWSER"))throw new Error("tf.data.webcam is only supported in browser environment.");if(!e){if(e=document.createElement("video"),!t.resizeWidth||!t.resizeHeight)throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");e.width=t.resizeWidth,e.height=t.resizeHeight}const n=new HL(e,t);return await n.start(),n}async start(){this.webcamConfig.facingMode&&we("user"===this.webcamConfig.facingMode||"environment"===this.webcamConfig.facingMode,(()=>`Invalid webcam facing mode: ${this.webcamConfig.facingMode}. Please provide 'user' or 'environment'`));try{this.stream=await navigator.mediaDevices.getUserMedia({video:{deviceId:this.webcamConfig.deviceId,facingMode:this.webcamConfig.facingMode?this.webcamConfig.facingMode:"user",width:this.webcamVideoElement.width,height:this.webcamVideoElement.height}})}catch(e){throw e.message=`Error thrown while initializing video stream: ${e.message}`,e}if(!this.stream)throw new Error("Could not obtain video from webcam.");try{this.webcamVideoElement.srcObject=this.stream}catch(t){console.log(t),this.webcamVideoElement.src=window.URL.createObjectURL(this.stream)}return this.webcamVideoElement.play(),this.isClosed=!1,new Promise((e=>{this.webcamVideoElement.onloadedmetadata=()=>{e()}}))}async next(){if(this.isClosed)return{value:null,done:!0};let e;try{e=bc(this.webcamVideoElement)}catch(t){throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(t)}`)}if(!this.resize)return{value:e,done:!1};try{return{value:this.cropAndResizeFrame(e),done:!1}}catch(t){throw new Error(`Error thrown cropping the video: ${t.message}`)}finally{e.dispose()}}needToResize(){return!(!this.webcamConfig.resizeWidth||!this.webcamConfig.resizeHeight||this.webcamVideoElement.width===this.webcamConfig.resizeWidth&&this.webcamVideoElement.height===this.webcamConfig.resizeHeight)}cropAndResizeFrame(e){return uu((()=>{const t=rf(Xo(e,"float32"),0);let n;n=Iw.cropAndResize(t,this.cropBox,this.cropBoxInd,this.cropSize,"bilinear");const r=n.shape;return Xh(n,r.slice(1))}))}async capture(){return(await this.next()).value}stop(){const e=this.stream.getTracks();e.forEach((e=>e.stop()));try{this.webcamVideoElement.srcObject=null}catch(t){console.log(t),this.webcamVideoElement.src=null}this.isClosed=!0}toArray(){throw new Error("Can not convert infinite video stream to array.")}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
class jL{}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
class qL extends pL{split(e){return new KL(this,e)}}class KL extends qL{constructor(e,t){super(),this.upstream=e,this.impl=new XL(e,t)}summary(){return this.impl.summary()}async next(){return this.impl.next()}}class XL extends IL{constructor(e,t){super(),this.upstream=e,this.separator=t,this.carryover=""}summary(){return`${this.upstream.summary()} -> Split('${this.separator}')`}async pump(){const e=await this.upstream.next();if(e.done)return""!==this.carryover&&(this.outputQueue.push(this.carryover),this.carryover="",!0);const t=e.value.split(this.separator);t[0]=this.carryover+t[0];for(const n of t.slice(0,-1))this.outputQueue.push(n);return this.carryover=t[t.length-1],!0}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
class YL extends pL{decodeUTF8(){return new JL(this)}}class JL extends qL{constructor(e){super(),this.upstream=e,this.impl=new ZL(e)}summary(){return this.impl.summary()}async next(){return this.impl.next()}}class ZL extends IL{constructor(e){if(super(),this.upstream=e,ht().get("IS_BROWSER"))this.decoder=new TextDecoder("utf-8");else{const{StringDecoder:e}=n(4530);this.decoder=new e("utf8")}}summary(){return`${this.upstream.summary()} -> Utf8`}async pump(){const e=await this.upstream.next();let t,n;return!e.done&&(t=e.value,n=ht().get("IS_BROWSER")?this.decoder.decode(t,{stream:!0}):this.decoder.write(Buffer.from(t.buffer)),this.outputQueue.push(n),!0)}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
class QL extends YL{constructor(e,t={}){super(),this.file=e,this.options=t,we(e instanceof Uint8Array||!!ht().get("IS_BROWSER")&&(e instanceof File||e instanceof Blob),(()=>"FileChunkIterator only supports File, Blob and Uint8Array right now.")),this.offset=t.offset||0,this.chunkSize=t.chunkSize||1048576}summary(){return`FileChunks ${this.file}`}async next(){if(this.offset>=(this.file instanceof Uint8Array?this.file.byteLength:this.file.size))return{value:null,done:!0};const e=new Promise(((e,t)=>{const n=this.offset+this.chunkSize;if(this.file instanceof Uint8Array)e(new Uint8Array(this.file.slice(this.offset,n)));else{const r=new FileReader;r.onload=n=>{let s=r.result;if(s instanceof ArrayBuffer&&(s=new Uint8Array(s)),!(s instanceof Uint8Array))return t(new TypeError("FileReader returned unknown type."));e(s)},r.onabort=e=>t(new Error("Aborted")),r.onerror=e=>t(new Error(e.type));const s=this.file.slice(this.offset,n);r.readAsArrayBuffer(s)}this.offset=n}));return{value:await e,done:!1}}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
async function ez(e,t={},n){let r,s;"string"===typeof e?r=e:(r=e.url,s=tz(e));const a=await(n||wa)(r,s);if(a.ok){const e=new Uint8Array(await a.arrayBuffer());return new QL(e,t)}throw new Error(a.statusText)}const tz=e=>{const t={method:e.method,headers:e.headers,body:e.body,mode:e.mode,credentials:e.credentials,cache:e.cache,redirect:e.redirect,referrer:e.referrer,integrity:e.integrity};return t};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
function nz(e){return"string"===typeof e&&"file://"===e.slice(0,7)}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
class rz extends jL{constructor(e,t={}){super(),this.input=e,this.options=t}async iterator(){if(nz(this.input)&&ht().get("IS_NODE")){const e=n(8108);this.input=e.readFileSync(this.input.slice(7))}return new QL(this.input,this.options)}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
class sz extends jL{constructor(e,t={}){super(),this.url=e,this.fileOptions=t}async iterator(){return nz(this.url)?new rz(this.url,this.fileOptions).iterator():ez(this.url,this.fileOptions)}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
function az(e,t={}){return new UL(new sz(e),t)}function iz(e){const t=lL(e);return AL((async()=>t))}function oz(e){return AL((async()=>{const t=await e();return lL((()=>t.next()))}))}async function uz(e,t){return HL.create(e,t)}async function lz(e){return GL.create(e)}
/** @license See the LICENSE file. */
const cz="4.11.0";
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function hz(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&we("complex64"!==e.dtype,(()=>`${t} does not support complex64 tensors in the CPU backend.`))}))}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const pz=Jy;class dz extends ce{nextDataId(){return dz.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new le(this,au())}write(e,t,n){this.firstUse&&(this.firstUse=!1,ht().get("IS_NODE")&&Ls("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));const r={id:this.nextDataId()};return this.data.set(r,{values:e,dtype:n,refCount:1}),r}makeTensorInfo(e,t,n){let r;if("string"===t&&null!=n&&n.length>0&&Ue(n[0])){const s=n.map((e=>va(e)));r=this.write(s,e,t)}else r=this.write(n,e,t);return{dataId:r,shape:e,dtype:t}}refCount(e){if(this.data.has(e)){const t=this.data.get(e);return t.refCount}return 0}incRef(e){const t=this.data.get(e);t.refCount++}decRef(e){if(this.data.has(e)){const t=this.data.get(e);t.refCount--}}move(e,t,n,r,s){this.data.set(e,{values:t,dtype:r,refCount:s})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:t,complexTensorInfos:n}=this.data.get(e);if("complex64"===t){const e=this.readSync(n.real.dataId),t=this.readSync(n.imag.dataId);return ev(e,t)}return Ze(this.data.get(e).values,t)}bufferSync(e){const t=this.readSync(e.dataId);if("string"===e.dtype)try{const n=t.map((e=>ka(e)));return qo(e.shape,e.dtype,n)}catch(n){throw new Error("Failed to decode encoded string bytes into utf-8")}return qo(e.shape,e.dtype,t)}makeOutput(e,t,n){return au().makeTensorFromTensorInfo(this.makeTensorInfo(t,n,e),this)}disposeData(e,t=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:n}=this.data.get(e);null!=n&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){const t=xa();e();const n=xa()-t;return{kernelMs:n}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){hz([e],"where");const t=this.readSync(e.dataId);return pz(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function fz(e){const t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}dz.nextDataId=0;const mz=e=>{const{x:t}=e.inputs,n=e.backend;hz(t,"abs");let r=new Float32Array(Ie(t.shape));const s=n.data.get(t.dataId).values;return r=fz(s),n.makeOutput(r,t.shape,t.dtype)},gz={kernelName:bt,backendName:"cpu",kernelFunc:mz};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function yz(e){return(t,n,r,s,a)=>{const i=ul(t,n),o=i.length,u=Xe(i),l=Ie(i),c=Me(a,l),h=t.length,p=n.length,d=Xe(t),f=Xe(n),m=il(t,i),g=il(n,i);if(m.length+g.length===0)for(let y=0;y<c.length;++y)c[y]=e(r[y%r.length],s[y%s.length]);else for(let y=0;y<c.length;++y){const t=st(y,o,u),n=t.slice(-h);m.forEach((e=>n[e]=0));const a=rt(n,h,d),i=t.slice(-p);g.forEach((e=>i[e]=0));const l=rt(i,p,f);c[y]=e(r[a],s[l])}return[c,i]}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function bz(e){const{inputs:t,backend:n}=e,{real:r,imag:s}=t,a=n.data.get(r.dataId).values,i=n.data.get(s.dataId).values,o=n.makeTensorInfo(r.shape,"complex64"),u=n.data.get(o.dataId);return u.complexTensorInfos={real:n.makeTensorInfo(r.shape,"float32",a),imag:n.makeTensorInfo(s.shape,"float32",i)},o}const xz={kernelName:Ht,backendName:"cpu",kernelFunc:bz};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function wz(e,t,n="float32"){if("complex64"===n){const n=wz(e,t,"float32"),r=wz(e,t,"float32");return bz({inputs:{real:n,imag:r},backend:e})}const r=et(Ie(t),n);return e.makeTensorInfo(t,n,r)}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function vz(e){const{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const kz={kernelName:On,backendName:"cpu",kernelFunc:vz};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Iz(e){const{inputs:t,backend:n}=e,{input:r}=t,s=n.data.get(r.dataId).complexTensorInfos.real,a=n.data.get(s.dataId).values;return n.makeTensorInfo(s.shape,s.dtype,a)}const Nz={kernelName:_r,backendName:"cpu",kernelFunc:Iz};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Sz(e,t,n,r){if("int32"===r){const n=Int32Array.from(e);return[t,"int32",n]}if("bool"===r){const r=ba([0],n),[s,a]=yz(((e,t)=>e!==t?1:0))(t,[],e,r,"bool");return[a,"bool",s]}throw new Error(`Error in Cast: failed to cast ${n} to ${r}`)}function Tz(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dtype:a}=r;if("complex64"===a){if("complex64"===s.dtype)return vz({inputs:{x:s},backend:n});const e=wz(n,s.shape,s.dtype),t=Tz({inputs:{x:s},backend:n,attrs:{dtype:"float32"}}),r=bz({inputs:{real:t,imag:e},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),r}if("complex64"===s.dtype){const e=Iz({inputs:{input:s},backend:n}),t=Tz({inputs:{x:e},backend:n,attrs:{dtype:a}});return n.disposeIntermediateTensorInfo(e),t}if(!Be(s.dtype,a)){const e=vz({inputs:{x:s},backend:n});return{dataId:e.dataId,shape:e.shape,dtype:a}}const i=n.data.get(s.dataId).values,[o,u,l]=Sz(i,s.shape,s.dtype,a);return n.makeTensorInfo(o,u,l)}const $z={kernelName:Vt,backendName:"cpu",kernelFunc:Tz};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Cz(e,t,n,r){return null==n?({inputs:n,backend:s})=>{const{a:a,b:i}=n,o=s;hz([a,i],e);const u=o.data.get(a.dataId).values,l=o.data.get(i.dataId).values,c="string"===a.dtype?Dv(u):u,h="string"===a.dtype?Dv(l):l,p=r||a.dtype,[d,f]=t(a.shape,i.shape,c,h,p);return o.makeTensorInfo(f,p,d)}:({inputs:e,backend:s})=>{const{a:a,b:i}=e,o=s;if("complex64"===a.dtype||"complex64"===i.dtype){const e=Tz({inputs:{x:a},backend:o,attrs:{dtype:"complex64"}}),t=o.data.get(e.dataId),r=t.complexTensorInfos.real,s=t.complexTensorInfos.imag,u=o.data.get(r.dataId).values,l=o.data.get(s.dataId).values,c=Tz({inputs:{x:i},backend:o,attrs:{dtype:"complex64"}}),h=o.data.get(c.dataId),p=h.complexTensorInfos.real,d=h.complexTensorInfos.imag,f=o.data.get(p.dataId).values,m=o.data.get(d.dataId).values,[g,y,b]=n(a.shape,i.shape,u,l,f,m),x=o.makeTensorInfo(b,"float32",g),w=o.makeTensorInfo(b,"float32",y),v=bz({inputs:{real:x,imag:w},backend:o});return o.disposeIntermediateTensorInfo(e),o.disposeIntermediateTensorInfo(c),o.disposeIntermediateTensorInfo(x),o.disposeIntermediateTensorInfo(w),v}{const e=o.data.get(a.dataId).values,n=o.data.get(i.dataId).values,s=r||a.dtype,[u,l]=t(a.shape,i.shape,e,n,s);return o.makeTensorInfo(l,s,u)}}}function Ez(e){return(t,n,r,s,a,i)=>{const o=ul(t,n),u=Ie(o),l=o.length,c=Xe(o),h=Me("float32",u),p=Me("float32",u),d=il(t,o),f=il(n,o),m=ev(r,s),g=ev(a,i),y=t.length,b=Xe(t),x=n.length,w=Xe(n);if(d.length+f.length===0)for(let v=0;v<h.length;v++){const t=v%m.length,n=v%g.length,r=e(m[2*t],m[2*t+1],g[2*n],g[2*n+1]);h[v]=r.real,p[v]=r.imag}else for(let v=0;v<h.length;v++){const t=st(v,l,c),n=t.slice(-y);d.forEach((e=>n[e]=0));const r=rt(n,y,b),s=t.slice(-x);f.forEach((e=>s[e]=0));const a=rt(s,x,w),i=e(m[2*r],m[2*r+1],g[2*a],g[2*a+1]);h[v]=i.real,p[v]=i.imag}return[h,p,o]}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Rz=yz(((e,t)=>e+t)),Az=Ez(((e,t,n,r)=>({real:e+n,imag:t+r}))),Fz=Cz(vt,Rz,Az),_z={kernelName:vt,backendName:"cpu",kernelFunc:Fz};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Dz(e,t,n,r,s){const a=Ie(r),i=et(s,n);for(let o=0;o<e.length;o++){const n=e[o];if(n<0)throw new Error("Input x must be non-negative!");n>=s||(i[n]+=a>0?t[o]:1)}return i}function Oz(e,t,n,r=!1){const s=e.shape[0],a=e.shape[1],i=qo([s,n],t.dtype);for(let o=0;o<s;o++)for(let s=0;s<a;s++){const a=e.get(o,s);if(a<0)throw new Error("Input x must be non-negative!");a>=n||(r?i.set(1,o,a):t.size>0?i.set(i.get(o,a)+t.get(o,s),o,a):i.set(i.get(o,a)+1,o,a))}return i}
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Mz=yz(((e,t)=>e&t)),Lz=Cz(Pt,Mz),zz={kernelName:Pt,backendName:"cpu",kernelFunc:Lz};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Pz(e){return(t,n,r)=>{const s=Le(n,t.length);for(let a=0;a<t.length;++a)s[a]=e(t[a],r);return s}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Bz(e,t,n){const r=Pz(t);return Wz(e,r,n)}function Wz(e,t,n){return({inputs:r,attrs:s,backend:a})=>{const{x:i}=r;hz(i,e);const o=a,u=o.data.get(i.dataId).values;let l;if("string"===i.dtype){if(!Array.isArray(u))throw new Error("String tensor's value was not an instance of Array");l=Dv(u)}else l=u;const c=n||i.dtype,h=t(l,c,s);return o.makeTensorInfo(i.shape,c,h)}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Vz=Pz((e=>Math.ceil(e))),Uz=Wz(Ut,Vz),Gz={kernelName:Ut,backendName:"cpu",kernelFunc:Uz};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Hz(e,t,n,r){const s=Le(n,Ie(t));if(r&&"string"!==n){let t=0;e.forEach((e=>{const n=Ie(e.shape);s.set(e.vals,t),t+=n}))}else{let r=0;e.forEach((e=>{const a="string"===n?Dv(e.vals):e.vals;let i=0;for(let n=0;n<e.shape[0];++n){const o=n*t[1]+r;for(let t=0;t<e.shape[1];++t)s[o+t]=a[i++]}r+=e.shape[1]}))}return s}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const jz=yz(((e,t)=>e===t?1:0)),qz=Cz(vn,jz,null,"bool"),Kz={kernelName:vn,backendName:"cpu",kernelFunc:qz},Xz=Pz((e=>Math.exp(e))),Yz=Wz(kn,Xz,"float32"),Jz={kernelName:kn,backendName:"cpu",kernelFunc:Yz},Zz=Pz((e=>Math.expm1(e))),Qz=Wz(Nn,Zz),eP={kernelName:Nn,backendName:"cpu",kernelFunc:Qz},tP=Pz((e=>Math.floor(e))),nP=Wz(Cn,tP),rP={kernelName:Cn,backendName:"cpu",kernelFunc:nP},sP=yz(((e,t)=>Math.floor(e/t))),aP=Cz(En,sP,null,"int32"),iP={kernelName:En,backendName:"cpu",kernelFunc:aP};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function oP(e,t,n,r,s,a,i,o,u){const l=qo([r,a],n);for(let c=0;c<r;c++){const n=[];let r=0;for(let t=0;t<s;t++){const a=e[c*s+t];r+=a*i[t],n.push(a)}if(r<0||r>=u/a)throw new Error(`Invalid indices: ${n} does not index into ${o}`);for(let e=0;e<a;e++)l.values[c*a+e]=t.get(...t.indexToLoc(r*a+e))}return l}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function uP(e,t,n){const r=qo(n,e.dtype);for(let s=0;s<r.size;++s){const n=r.indexToLoc(s),a=n.slice(),i=a[0],o=a[2],u=t.locToIndex([i,o]);a[2]=t.values[u];const l=e.locToIndex(a);0<=l&&l<e.values.length&&(r.values[s]=e.values[l])}return r}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const lP=yz(((e,t)=>e>t?1:0)),cP=Cz(_n,lP,null,"bool"),hP={kernelName:_n,backendName:"cpu",kernelFunc:cP},pP=yz(((e,t)=>e>=t?1:0)),dP=Cz(Dn,pP,null,"bool"),fP={kernelName:Dn,backendName:"cpu",kernelFunc:dP},mP=yz(((e,t)=>e<t?1:0)),gP=Cz(Vn,mP,null,"bool"),yP={kernelName:Vn,backendName:"cpu",kernelFunc:gP},bP=yz(((e,t)=>e<=t?1:0)),xP=Cz(Un,bP,null,"bool"),wP={kernelName:Un,backendName:"cpu",kernelFunc:xP};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function vP(e,t,n){const r=(t-e)/(n-1),s=et(n,"float32");s[0]=e;for(let a=1;a<s.length;a++)s[a]=s[a-1]+r;return s}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const kP=Pz((e=>Math.log(e))),IP=Wz(Hn,kP),NP={kernelName:Hn,backendName:"cpu",kernelFunc:IP};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function SP(e,t,n,r){const s=Me(r,Ie(n));for(let a=0;a<s.length;++a){const n=a*t;let r=e[n];for(let s=0;s<t;++s){const t=e[n+s];(Number.isNaN(t)||t>r)&&(r=t)}s[a]=r}return s}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const TP=yz(((e,t)=>Math.max(e,t))),$P=Cz(rr,TP),CP={kernelName:rr,backendName:"cpu",kernelFunc:$P},EP=yz(((e,t)=>Math.min(e,t))),RP=Cz(hr,EP),AP={kernelName:hr,backendName:"cpu",kernelFunc:RP},FP=yz(((e,t)=>e*t)),_P=Ez(((e,t,n,r)=>({real:e*n-t*r,imag:e*r+t*n}))),DP=Cz(mr,FP,_P),OP={kernelName:mr,backendName:"cpu",kernelFunc:DP};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function MP(e,t,n){const r=ga(-1,n);return FP([],t,r,e,n)}function LP(e){const{inputs:t,backend:n}=e,{x:r}=t;hz(r,"neg");const s=n.data.get(r.dataId).values,[a,i]=MP(s,r.shape,r.dtype);return n.makeTensorInfo(i,r.dtype,a)}const zP={kernelName:gr,backendName:"cpu",kernelFunc:LP},PP=yz(((e,t)=>e!==t?1:0)),BP=Cz(yr,PP,null,"bool"),WP={kernelName:yr,backendName:"cpu",kernelFunc:BP};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function VP(e,t,n,r,s){const a=t.length,i=Ie(t),o=Xe(t),u=Xe(s),l=Me(n,Ie(s));for(let c=0;c<i;++c){const t=st(c,a,o),n=new Array(t.length);for(let e=0;e<n.length;e++)n[e]=t[r[e]];const s=rt(n,a,u);l[s]=e[c]}return l}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function UP(e){const{inputs:t,attrs:n,backend:r}=e,{x:s}=t,{perm:a}=n;hz(s,"transpose");const i=s.shape.length,o=new Array(i);for(let h=0;h<o.length;h++)o[h]=s.shape[a[h]];const u=r.data.get(s.dataId).values,l=VP(u,s.shape,s.dtype,a,o),c=r.write(l,o,s.dtype);return{dataId:c,shape:o,dtype:s.dtype}}const GP={kernelName:Ss,backendName:"cpu",kernelFunc:UP};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function HP(e,t,n,r){const[s,a]=Ld(e,r),i=ti(t,"int32"),o=et(Ie(s),i),u=Ie(a);for(let l=0;l<o.length;++l){const e=l*u;let t=1;for(let r=0;r<u;++r)t*=n[e+r];o[l]=t}return{outVals:o,outShape:s,outDtype:i}}function jP(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;hz(s,"prod");const o=s.shape.length,u=De(a,s.shape),l=Bd(u,o);let c=u,h=s;const p=[];null!=l&&(h=UP({inputs:{x:s},backend:n,attrs:{perm:l}}),p.push(h),c=Vd(c.length,o));const d=n.data.get(h.dataId).values,{outVals:f,outShape:m,outDtype:g}=HP(h.shape,h.dtype,d,c);let y=m;return i&&(y=zd(m,u)),p.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(y,g,f)}const qP={kernelName:Cr,backendName:"cpu",kernelFunc:jP};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function KP(e,t,n){e.forEach(((e,r)=>{if(e<0||e>=n){const s=st(r,t.length,Xe(t)).join(",");throw new Error(`indices[${s}] = ${e} is not in [0, ${n})`)}}))}function XP(e,t){for(let n=0;n<e.length;++n){const r=e[n],s=n===e.length-1?t:e[n+1].length;if(0===r.length)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>s)throw new Error("Ragged splits must not point past values");for(let e=1;e<r.length;++e)if(r[e-1]>r[e])throw new Error("Ragged splits must be sorted in ascending order")}}function YP(e,t,n,r){const s=[];let a=0;const i=t.length-1+n.length,o=new Array(i).fill(null).map((()=>[0]));XP(n,r);let u=1;for(let l=0;l<t.length-1;++l){u*=t[l];const e=t[l+1];for(let t=1;t<u+1;++t)o[l].push(t*e)}for(let l=0;l<e.length;++l){let r=e[l],i=e[l]+1;for(let e=0;e<n.length;++e){const s=n[e],a=e+t.length-1;if(a>=0){const e=o[a],t=e[e.length-1]-s[r];for(let n=r;n<i;++n)o[a].push(s[n+1]+t)}r=s[r],i=s[i]}i!==r&&(s.push([r,i]),a+=i-r)}return{outSplits:o,valueSlices:s,numValues:a}}function JP(e){const t=[];for(let n=0;n<e.length;++n){const r=e[n].length,s=Le("int32",r);t.push(s),e[n].forEach(((e,t)=>s[t]=e))}return t}function ZP(e,t){const n=e.slice(0,t);while(n.length<t)n.push(1);for(let r=t;r<e.length;r++)n[t-1]*=e[r];return n}function QP(e,t,n,r,s,a){const i=ZP(t,2)[1],o=ZP(a,2)[1];let u=0;for(const l of n)for(let t=l[0];t<l[1];++t){for(let n=0;n<r;++n)s[u*o+n]=e[t*i+n];++u}}function eB(e,t,n,r,s){const a=t.slice();a[0]=s;const i=Le(n,Ie(a)),o=e.length,u=0===o?0:o/t[0];return QP(e,t,r,u,i,a),[i,a]}function tB(e,t,n,r,s,a,i,o){if(0===e.length)throw new Error("paramsNestedSplits must be non empty");if(0===t[0].length)throw new Error("Split tensors must not be scalars");const u=t[0][0]-1;if(KP(a,i,u),0===r.length)throw new Error("params.rank must be nonzero");const l=r[0],{outSplits:c,valueSlices:h,numValues:p}=YP(a,i,e,l),d=JP(c),f=eB(n,r,s,h,p);return[d,f[0],f[1]]}
/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const nB=2147483647;function rB(e,t,n,r,s,a,i){if(t.length>1)throw new Error("starts must be a scalar or vector");if(s.length>1)throw new Error("limits must be a scalar or vector");if(i.length>1)throw new Error("deltas must be a scalar or vector");const o=0===t.length,u=0===s.length,l=0===i.length,c=[];o||c.push(t[0]),u||c.push(s[0]),l||c.push(i[0]);for(let g=1;g<c.length;++g)if(c[g]!==c[g-1])throw new Error("starts, limits, and deltas must have the same shape");const h=0===c.length?1:c[0],p=Le("int32",h+1);p[0]=0;for(let g=0;g<h;++g){const t=o?e[0]:e[g],n=u?r[0]:r[g],s=l?a[0]:a[g];if(0===s)throw new Error("Requires delta != 0");let i;if(s>0&&n<t||s<0&&n>t)i=0;else if(i=Math.ceil(Math.abs((n-t)/s)),i>nB)throw new Error(`Requires ((limit - start) / delta) <= ${nB}`);p[g+1]=p[g]+i}const d=p[h],f=Le(n,d);let m=0;for(let g=0;g<h;++g){const t=p[g+1]-p[g];let n=o?e[0]:e[g];const r=l?a[0]:a[g];for(let e=0;e<t;++e)f[m++]=n,n+=r}return[p,f]}
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var sB=_w;class aB{constructor(e,t,n,r,s,a,i,o,u,l){this.shape=e,this.shapeShape=t,this.values=n,this.valuesShape=r,this.valuesDType=s,this.defaultValue=a,this.defaultValueShape=i,this.rowPartitionValues=o,this.rowPartitionValuesShapes=u,this.rowPartitionTypes=Ow(l),this.raggedRank=Mw(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===sB.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===sB.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case sB.VALUE_ROWIDS:return aB.getMaxWidthValueRowID(t);case sB.ROW_SPLITS:return aB.getMaxWidthRowSplit(t);default:throw new Error(`Cannot handle partition type ${sB[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){const t=e.length;if(0===t||1===t)return 0;let n=0;for(let r=0;r<t-1;++r){const t=e[r+1]-e[r];t>n&&(n=t)}return n}static getMaxWidthValueRowID(e){const t=e.length;if(0===t)return 0;let n=0,r=e[0],s=0;for(let a=1;a<t;++a){const t=e[a];t!==r&&(r=t,s=Math.max(a-n,s),n=a)}return Math.max(t-n,s)}tensorShapeFromTensor(e,t,n=!0){if(0===t.length){if(-1===e[0])return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return oB(e,n)}calculateOutputSize(e){const t=this.valuesShape,n=this.defaultValueShape;Lw(n,t);const r=this.tensorShapeFromTensor(this.shape,this.shapeShape),s=Dw(this.raggedRank,r,t),a=s;a[0]<0&&(a[0]=e);for(let i=1;i<=this.raggedRank;++i)a[i]<0&&(a[i]=this.getMaxWidth(i));return a}calculateFirstParentOutputIndex(e,t,n){const r=Math.min(e,n),s=[];let a=0;for(let i=0;i<r;++i,a+=t)s.push(a);for(let i=r;i<e;++i)s.push(-1);return we(s.length===e,(()=>"Final length of result must be equal to firstDimension.")),s}calculateOutputIndexRowSplit(e,t,n,r){const s=e.length,a=[];for(let i=0;i<s-1;++i){const s=e[i+1]-e[i];let o=Math.min(r,s),u=t[i];-1===u&&(o=0);for(let e=0;e<o;++e)a.push(u),u+=n;for(let e=0;e<s-o;++e)a.push(-1)}if(s>0&&a.length!==e[s-1])throw new Error("Invalid row split size.");return a}calculateOutputIndexValueRowID(e,t,n,r){const s=e.length,a=[];if(0===s)return[];let i=0,o=e[0];if(o>=t.length)throw new Error(`Got currentValueRowId=${o}, which is not less than ${t.length}`);let u=t[o];a.push(u);for(let l=1;l<s;++l){const s=e[l];if(s===o)u>=0&&(++i,i<r?u+=n:u=-1);else{if(i=0,o=s,s>=t.length)throw new Error(`Got nextValueRowId=${s} which is not less than ${t.length}`);u=t[s]}a.push(u)}if(a.length!==e.length)throw new Error("Invalid row ids.");return a}calculateOutputIndex(e,t,n,r){const s=this.getRowPartitionTensor(e),a=this.getRowPartitionTypeByDimension(e);switch(a){case sB.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(s,t,n,r);case sB.ROW_SPLITS:if(s.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${s.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(s,t,n,r);default:throw new Error(`Unsupported partition type: ${sB[a]}`)}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw new Error("No row_partition_types given.");const t=this.rowPartitionTypes[0];switch(t){case sB.FIRST_DIM_SIZE:return e[0];case sB.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case sB.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${sB[t]}`)}}compute(){const e=this.rowPartitionValues[0];if(e.length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const t=this.getFirstDimensionSize(),n=this.calculateOutputSize(t),r=new Array(this.raggedRank+1);r[r.length-1]=1;for(let o=r.length-2;o>=0;--o)r[o]=r[o+1]*n[o+1];const s=oB(n,!1),a=Le(this.valuesDType,Ie(s)),i=r[0]*n[0];if(i>0){let e=this.calculateFirstParentOutputIndex(t,r[0],n[0]);for(let t=1;t<=this.raggedRank;++t){const s=this.calculateOutputIndex(t-1,e,r[t],n[t]);e=s}this.setOutput(this.raggedRank,e,a,s)}return[s,a]}setOutput(e,t,n,r){if(0===n.length)return;const s=this.values,a=n;let i=r.slice();i=i.slice(e+1);const o=Ie(i),u=t.length;let l=this.defaultValue;if(l.length!==o&&1!==l.length){const e=this.defaultValueShape;uu((()=>{const t=Xh(l,e),n=Cp(t,i);l=n.dataSync()}))}let c=0,h=0,p=0;for(let d=0;d<=u;++d){let e=d<u?t[d]:-1;if(e!==p){if(h<p){const e=s.subarray(c*o),t=a.subarray(h*o),n=(p-h)*o;iB(t,e,n)}if(d>=u){const t=n.length;e=Math.floor(t/o)}if(e>p)if(1===this.defaultValue.length)a.subarray(p*o,e*o).fill(this.defaultValue[0]),p=e;else while(e>p){const e=a.slice(p*o);iB(e,l,o),++p}e<0?(c=d+1,h=p):(c=d,h=p,p=h+1)}else++p}}}function iB(e,t,n){for(let r=0;r<n;r++)e[r]=t[r]}function oB(e,t){const n=[];for(let r of e){if(r<0){if(!t)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}n.push(r)}return n}function uB(e,t,n,r,s,a,i,o,u,l){return new aB(e,t,n,r,s,a,i,o,u,l).compute()}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function lB(e,t,n,r){const s=e===t,a=e<t&&n<0,i=t<e&&n>1;if(s||a||i)return et(0,r);const o=Math.abs(Math.ceil((t-e)/n)),u=et(o,r);t<e&&1===n&&(n=-1),u[0]=e;for(let l=1;l<u.length;l++)u[l]=u[l-1]+n;return u}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const cB=Pz((e=>1/Math.sqrt(e))),hB=Wz(Gr,cB),pB={kernelName:Gr,backendName:"cpu",kernelFunc:hB};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function dB(e,t,n,r,s,a,i,o,u,l){const c=[r/s,s],h=e.values,p=t.values;if(0===r)return qo(n,t.dtype);const d=u instanceof Pa?u:qo(c,t.dtype);"string"===typeof u||"number"===typeof u?d.values.fill(u):"boolean"===typeof u&&d.values.fill(+u);for(let f=0;f<a;f++){const e=[];let a=0;for(let t=0;t<i;t++){const n=h[f*i+t];e.push(n),a+=n*o[t]}if(a<0||a>=r/s)throw new Error(`Invalid indices: ${e} does not index into ${n}`);for(let n=0;n<s;n++)l?d.values[a*s+n]+=p[f*s+n]:d.values[a*s+n]=0===t.rank?p[0]:p[f*s+n]}return d}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const fB=Pz((e=>1/(1+Math.exp(-e)))),mB=Bz(es,(e=>1/(1+Math.exp(-e)))),gB={kernelName:es,backendName:"cpu",kernelFunc:mB};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function yB(e,t,n,r,s){const a=Lc(r,t,n),i=Ie(n),o=Xe(r);if(a){const n=zc(t,o);return"string"===s?e.slice(n,n+i):e.subarray(n,n+i)}const u="string"===s?Dv(e):e,l=qo(r,s,u),c=qo(n,s);for(let h=0;h<c.size;++h){const e=c.indexToLoc(h),n=e.map(((e,n)=>e+t[n]));c.set(l.get(...n),...e)}return"string"===s?Ov(c.values):c.values}function bB(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,size:i}=r;hz(s,"slice");const[o,u]=Pc(s,a,i);Sc(s,o,u);const l=n.data.get(s.dataId).values,c=yB(l,o,u,s.shape,s.dtype);return n.makeTensorInfo(u,s.dtype,c)}const xB={kernelName:Yr,backendName:"cpu",kernelFunc:bB};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function wB(e,t,n,r,s,a,i){const o=t[0],u=a[0],l=new Array(u),c=new Array(o),h=t[1];if(0===u){if(0!==o)throw new Error(xv(o));const e=Le(n,0),t=Le(s,0);return[e,[0,h],t,l,c]}let p=!0,d=0;const f=new Array(u).fill(0);for(let g=0;g<o;++g){const t=e[g*h];if(t<0)throw new Error(wv(g,t));if(t>=u)throw new Error(vv(g,t,u));++f[t],p=p&&t>=d,d=t}let m=!0;for(let g=0;g<u;++g){const e=0===f[g];l[g]=e,m=m&&!e,f[g]=Math.max(f[g],1),g>0&&(f[g]+=f[g-1])}if(m&&p){const t=e,n=r;for(let e=0;e<o;++e)c[e]=e;return[t,[o,h],n,l,c]}{const t=f[u-1],a=Le(n,t*h),p=Le(s,t),d=new Array(u).fill(0);for(let n=0;n<o;++n){const t=e[n*h],s=d[t],i=(0===t?0:f[t-1])+s;d[t]++;for(let r=0;r<h;++r)a[i*h+r]=e[n*h+r];p[i]=r[n],c[n]=i}for(let e=0;e<u;++e){const t=d[e];if(0===t){const t=0===e?0:f[e-1];a[t*h+0]=e;for(let e=1;e<h;++e)a[t*h+e]=0;p[t]=i}}return[a,[t,h],p,l,c]}}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function vB(e,t,n,r,s){const a=Ie(r),i=t[0],o=s.length,u=[];let l=1,c=-1;for(let g=0;g<o;++g){const e=s[g];if(-1===e){if(-1!==c)throw new Error(kv(c,g));c=g,u.push(1)}else{if(e<0)throw new Error(Iv(g,e));l*=e,u.push(e)}}if(-1!==c){if(l<=0)throw new Error(Nv());const e=Math.trunc(a/l);if(l*e!==a)throw new Error(Sv(r,u));u[c]=e}const h=Ie(u);if(h!==a)throw new Error(Tv(r,u));const p=r.length,d=[];if(p>0){d[p-1]=1;for(let e=p-2;e>=0;--e)d[e]=d[e+1]*r[e+1]}const f=[];if(o>0){f[o-1]=1;for(let e=o-2;e>=0;--e)f[e]=f[e+1]*u[e+1]}const m=Le(n,i*o);for(let g=0;g<i;++g){let t=0;for(let n=0;n<p;++n)t+=e[g*p+n]*d[n];for(let e=0;e<o;++e)m[g*o+e]=Math.trunc(t/f[e]),t%=f[e]}return[m,[i,o],u]}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function kB(e,t,n,r,s,a=!1,i=0){const o=r.length,u=[t[0],e.length/t[0]],l=u[1],c=o>0?s[o-1]+1:0,h=c;if(h<0)throw new Error($v());const p=t.slice();p[0]=h;const d=p.reduce(((e,t)=>e*t),1),f=Le(n,d);if(0===o)return h>0&&f.fill(i),[f,p];if(h<=0)throw new Error($v());let m=0,g=1,y=0,b=s[m];while(1){let t=0;if(g<o){if(t=s[g],b===t){++g;continue}if(b>=t)throw new Error(Cv())}if(b<0||b>=h)throw new Error(Ev(b,h));b>y&&f.fill(i,y*l,b*l);for(let n=m;n<g;++n){const t=r[n];if(t<0||t>=u[0])throw new Error(Rv(n,r[n],u[0]));for(let n=0;n<l;n++)f[b*l+n]+=e[t*l+n]}if(a)for(let e=0;e<l;e++)f[b*l+e]/=g-m;if(m=g,++g,y=b+1,b=t,g>o)break}return y<h&&f.fill(i,y*l,h*l),[f,p]}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const IB=Pz((e=>Math.sqrt(e))),NB=Bz(ns,(e=>Math.sqrt(e))),SB={kernelName:ns,backendName:"cpu",kernelFunc:NB},TB=yz(((e,t)=>{const n=e-t;return n*n})),$B=Cz(ps,TB),CB={kernelName:ps,backendName:"cpu",kernelFunc:$B},EB=Pz(((e,t)=>{const{pattern:n,replaceGlobal:r,rewrite:s}=t;return e.replace(new RegExp(n,r?"g":""),s)})),RB=Wz(fs,EB),AB={kernelName:fs,backendName:"cpu",kernelFunc:RB};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function FB(e,t,n,r){const s=qo(e,t.dtype);for(let a=0;a<s.size;a++){const e=s.indexToLoc(a),i=new Array(e.length);for(let t=0;t<i.length;t++)i[t]=e[t]*n[t]+r[t];s.set(t.get(...i),...e)}return s}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class _B{constructor(e,t,n,r,s,a){this.separator=va(e),this.nGramWidths=t,this.leftPad=va(n),this.rightPad=va(r),this.padWidth=s,this.preserveShort=a}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,r,s,a){for(let i=0;i<s;++i){const o=this.getPadWidth(a),u=Math.max(0,o-i),l=Math.max(0,o-(s-(i+1))),c=a-(u+l),h=t+(u>0?0:i-o);let p=0;p+=u*this.leftPad.length;for(let t=0;t<c;++t)p+=e[h+t].length;p+=l*this.rightPad.length;const d=u+l+c-1;p+=d*this.separator.length,n[r+i]=new Uint8Array(p);const f=n[r+i];let m=0;const g=e=>e.forEach((e=>f[m++]=e));for(let e=0;e<u;++e)g(this.leftPad),g(this.separator);for(let t=0;t<c-1;++t)g(e[h+t]),g(this.separator);if(c>0){g(e[h+c-1]);for(let e=0;e<l;++e)g(this.separator),g(this.rightPad)}else{for(let e=0;e<l-1;++e)g(this.rightPad),g(this.separator);g(this.rightPad)}}}compute(e,t){const n=e.length,r=t.length;if(r>0){let e=t[0];if(0!==e)throw new Error(`First split value must be 0, got ${e}`);for(let s=1;s<r;++s){let r=t[s]>=e;if(r=r&&t[s]<=n,!r)throw new Error(`Invalid split value ${t[s]}, must be in [${e}, ${n}]`);e=t[s]}if(e!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${e}`)}const s=r-1,a=Le("int32",r);if(0===n||0===r){const e=new Array(n);for(let t=0;t<=s;++t)a[t]=0;return[e,a]}a[0]=0;for(let o=1;o<=s;++o){const e=t[o]-t[o-1];let n=0;this.nGramWidths.forEach((t=>{n+=this.getNumNGrams(e,t)})),this.preserveShort&&e>0&&0===n&&(n=1),a[o]=a[o-1]+n}const i=new Array(a[s]);for(let o=0;o<s;++o){const n=t[o];let r=a[o];if(this.nGramWidths.forEach((s=>{const a=t[o+1]-t[o],u=this.getNumNGrams(a,s);this.createNGrams(e,n,i,r,u,s),r+=u})),this.preserveShort&&r===a[o]){const s=t[o+1]-t[o];if(0===s)continue;const a=s+2*this.padWidth,u=1;this.createNGrams(e,n,i,r,u,a)}}return[i,a]}}function DB(e,t,n,r,s,a,i,o){return new _B(n,r,s,a,i,o).compute(e,t)}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function OB(e,t,n,r){if(!e.length)return;if(0===t.length){for(let t=0;t<e.length;++t)r.push(e.subarray(t,t+1));return}if(1===t.length){const s=t[0];let a=e.indexOf(s);while(-1!==a){const t=e.subarray(0,a);n&&0===t.length||r.push(t),e=e.subarray(a+1),a=e.indexOf(s)}return void(n&&0===e.length||r.push(e))}let s=0;for(let a=0;a<e.length+1;a++)if(a===e.length||-1!==t.indexOf(e[a])){const t=e.subarray(s,a);n&&0===t.length||r.push(t),s=a+1}}function MB(e,t,n){const r=e.length,s=[];let a=0,i=0;const o=new Array(r);for(let p=0;p<r;++p){const r=s.length;OB(e[p],t,n,s);const u=s.length-r;o[p]=u,a+=u,i=Math.max(i,u)}const u=Le("int32",2*a),l=new Array(a),c=[r,i];let h=0;for(let p=0;p<r;++p)for(let e=0;e<o[p];++e)u[2*h]=p,u[2*h+1]=e,l[h]=s[h],++h;return[u,l,c]}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function LB(e,t){const n=Le("int32",e.length);for(let r=0;r<e.length;++r)n[r]=ma(e[r]).modulo(t).getLowBitsUnsigned();return n}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const zB=yz(((e,t)=>e-t)),PB=Ez(((e,t,n,r)=>({real:e-n,imag:t-r}))),BB=Cz(xs,zB,PB),WB={kernelName:xs,backendName:"cpu",kernelFunc:BB};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function VB(e,t){const n=new Array(e.rank);for(let s=0;s<n.length;s++)n[s]=e.shape[s]*t[s];const r=qo(n,e.dtype);for(let s=0;s<r.values.length;++s){const t=r.indexToLoc(s),n=new Array(e.rank);for(let r=0;r<n.length;r++)n[r]=t[r]%e.shape[r];const a=e.locToIndex(n);r.values[s]=e.values[a]}return r}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const UB=(e,t)=>{const n=t.value-e.value;return 0===n?e.index-t.index:n};function GB(e,t,n=0,r=e.length-1){while(r>n){if(r-n>600){const s=r-n+1,a=t-n+1,i=Math.log(s),o=.5*Math.exp(2*i/3),u=.5*Math.sqrt(i*o*(s-o)/s)*Math.sign(a-s/2),l=Math.max(n,Math.floor(t-a*o/s+u)),c=Math.min(r,Math.floor(t+(s-a)*o/s+u));GB(e,t,l,c)}const s=e[t];let a=n,i=r;ge(e,n,t),UB(e[r],s)>0&&ge(e,n,r);while(a<i){ge(e,a,i),a++,i--;while(UB(e[a],s)<0)a+=1;while(UB(e[i],s)>0)i-=1}0===UB(e[n],s)?ge(e,n,i):(i+=1,ge(e,i,r)),i<=t&&(n=i+1),t<=i&&(r=i-1)}}function HB(e,t,n,r,s){const a=t[t.length-1],[i,o]=[e.length/a,a],u=Me(n,i*r),l=Me("int32",i*r);for(let h=0;h<i;h++){const t=h*o,n=e.subarray(t,t+o);let a=new Array(n.length);n.forEach(((e,t)=>a[t]={value:e,index:t})),r<a.length&&(GB(a,r),a=a.slice(0,r)),s&&a.sort(UB);const i=h*r,c=u.subarray(i,i+r),p=l.subarray(i,i+r);for(let e=0;e<r;e++)c[e]=a[e].value,p[e]=a[e].index}const c=t.slice();return c[c.length-1]=r,[qo(c,n,u),qo(c,"int32",l)]}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function jB(e,t,n,r){const s=De(t,n)[0],a=[1,n[0],1];for(let f=0;f<s;f++)a[0]*=n[f];a[1]=n[s];for(let f=s+1;f<n.length;f++)a[2]*=n[f];const i=new Map,o=new Int32Array(n[s]),u=new Pa(a,r,e),l=[],c=1===a[0]&&1===a[2];for(let f=0;f<n[s];f++){let t;if(c)t=e[f].toString();else{const e=[];for(let t=0;t<a[0];t++)for(let n=0;n<a[2];n++)e.push(u.get(t,f,n));t=e.join(",")}const n=i.get(t);if(null!=n)o[f]=n;else{const e=i.size;i.set(t,e),o[f]=e,l.push(f)}}const h=a.slice();h[1]=i.size;const p=new Pa(h,r);l.forEach(((e,t)=>{for(let n=0;n<a[0];n++)for(let r=0;r<a[2];r++)p.set(u.get(n,e,r),n,t,r)}));const d=n.slice();return d[s]=h[1],{outputValues:p.values,outputShape:d,indices:o}}
/** @license See the LICENSE file. */
const qB="4.11.0";
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
bu("cpu",(()=>new dz),1);
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const KB=Bz(bn,(e=>e>=0?e:Math.exp(e)-1)),XB={kernelName:bn,backendName:"cpu",kernelFunc:KB};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function YB(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{alpha:a}=r;hz([s],"leakyRelu");const i=Ie(s.shape),o=n.data.get(s.dataId).values,u=Me("float32",i);for(let l=0;l<o.length;l++)u[l]=o[l]<0?a*o[l]:o[l];return n.makeTensorInfo(s.shape,"float32",u)}const JB={kernelName:Wn,backendName:"cpu",kernelFunc:YB},ZB=yz(((e,t)=>e<0?t*e:e));function QB(e){const{inputs:t,backend:n}=e,{x:r,alpha:s}=t;hz([r,s],"prelu");const a=n.data.get(r.dataId).values,i=n.data.get(s.dataId).values,[o,u]=ZB(r.shape,s.shape,a,i,"float32");return n.makeTensorInfo(u,"float32",o)}const eW={kernelName:$r,backendName:"cpu",kernelFunc:QB},tW=Bz(Or,(e=>Math.max(0,e))),nW={kernelName:Or,backendName:"cpu",kernelFunc:tW},rW=Bz(Wr,(e=>Math.min(Math.max(0,e),6))),sW={kernelName:Wr,backendName:"cpu",kernelFunc:rW};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function aW(e,t,n,r,s){if("linear"===n)return vz({inputs:{x:t},backend:e});if("relu"===n)return tW({inputs:{x:t},backend:e});if("elu"===n)return KB({inputs:{x:t},backend:e});if("relu6"===n)return rW({inputs:{x:t},backend:e});if("prelu"===n)return QB({inputs:{x:t,alpha:r},backend:e});if("leakyrelu"===n)return YB({inputs:{x:t},backend:e,attrs:{alpha:s}});if("sigmoid"===n)return mB({inputs:{x:t},backend:e});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function iW(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{shape:a}=r,i=Ie(s.shape),o=_e(a,i),u=Ie(o);we(i===u,(()=>`The new shape (${o}) has ${u} elements and the old shape (${s.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`)),n.incRef(s.dataId);const l=n.data.get(s.dataId);if(null!=l.complexTensorInfos){const e=l.complexTensorInfos.real,t=l.complexTensorInfos.imag;e.shape=o,t.shape=o}return{dataId:s.dataId,shape:o,dtype:s.dtype}}const oW={kernelName:Mr,backendName:"cpu",kernelFunc:iW};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function uW(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:a}=t,{transposeA:i,transposeB:o}=r;hz([s,a],"matMul");const u=s.shape.length,l=a.shape.length,c=i?s.shape[u-2]:s.shape[u-1],h=o?a.shape[l-1]:a.shape[l-2],p=i?s.shape[u-1]:s.shape[u-2],d=o?a.shape[l-2]:a.shape[l-1],f=s.shape.slice(0,-2),m=a.shape.slice(0,-2),g=Ie(f),y=Ie(m),b=ul(s.shape.slice(0,-2),a.shape.slice(0,-2)),x=b.concat([p,d]);we(c===h,(()=>`Error in matMul: inner shapes (${c}) and (${h}) of Tensors with shapes ${s.shape} and ${a.shape} and transposeA=${i} and transposeB=${o} must match.`));const w=i?[g,c,p]:[g,p,c],v=o?[y,d,h]:[y,h,d],k=iW({inputs:{x:s},backend:n,attrs:{shape:w}}),I=iW({inputs:{x:a},backend:n,attrs:{shape:v}}),N=i?k.shape[1]:k.shape[2],S=i?k.shape[2]:k.shape[1],T=o?I.shape[1]:I.shape[2],$=Math.max(g,y),C=n.data.get(k.dataId).values,E=n.data.get(I.dataId).values,R=Xe(k.shape),A=Xe(I.shape),[F,_,D]=i?[R[0],1,R[1]]:[R[0],R[1],1],[O,M,L]=o?[1,A[1],A[0]]:[A[1],1,A[0]],z=S*T,P=qo([$,S,T],k.dtype),B=P.values,W=n.blockSize;for(let V=0;V<$;V++){const e=V%g,t=V%y;for(let n=0;n<S;n+=W){const r=Math.min(n+W,S);for(let s=0;s<T;s+=W){const a=Math.min(s+W,T);for(let i=0;i<N;i+=W){const o=Math.min(i+W,N);for(let u=n;u<r;u++)for(let n=s;n<a;n++){let r=0;for(let s=i;s<o;s++){const a=C[e*F+u*_+s*D],i=E[s*O+n*M+t*L];r+=a*i}B[V*z+(u*T+n)]+=r}}}}}return n.disposeIntermediateTensorInfo(k),n.disposeIntermediateTensorInfo(I),n.makeTensorInfo(x,P.dtype,P.values)}const lW={kernelName:Mt,backendName:"cpu",kernelFunc:uW};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function cW(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:a,bias:i,preluActivationWeights:o}=t,{transposeA:u,transposeB:l,activation:c,leakyreluAlpha:h}=r;let p,d,f;const m=[],g=uW({inputs:{a:s,b:a},attrs:{transposeA:u,transposeB:l},backend:n});p=g,i&&(d=Fz({inputs:{a:p,b:i},backend:n}),m.push(p),p=d),c&&(f=aW(n,p,c,o,h),m.push(p),p=f);for(const y of m)n.disposeIntermediateTensorInfo(y);return p}const hW={kernelName:Ds,backendName:"cpu",kernelFunc:cW},pW=Bz(xt,(e=>Math.acos(e))),dW={kernelName:xt,backendName:"cpu",kernelFunc:pW},fW=Bz(wt,(e=>Math.acosh(e))),mW={kernelName:wt,backendName:"cpu",kernelFunc:fW};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function gW(e){const{inputs:t,backend:n}=e,r=t;hz(t,"addN");const s=r.map((e=>n.data.get(e.dataId).values)),a=qo(r[0].shape,r[0].dtype),i=a.values;for(let o=0;o<r.length;o++){const e=s[o];for(let t=0;t<i.length;t++)i[t]+=e[t]}return n.makeTensorInfo(a.shape,a.dtype,a.values)}const yW={kernelName:kt,backendName:"cpu",kernelFunc:gW};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function bW(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;hz(s,"all");const o=De(a,s.shape);let u=o;const l=Bd(u,s.shape.length);let c=s;null!=l&&(c=UP({inputs:{x:s},backend:n,attrs:{perm:l}}),u=Vd(u.length,s.shape.length)),Pd("all",u,c.shape.length);const[h,p]=Ld(c.shape,u),d=Ie(p),f=et(Ie(h),c.dtype),m=n.data.get(c.dataId).values;for(let y=0;y<f.length;++y){const e=y*d;let t=m[e];for(let n=0;n<d;++n){const r=m[e+n];t=t&&r}f[y]=t}null!=l&&n.disposeIntermediateTensorInfo(c);const g=n.makeTensorInfo(h,c.dtype,f);if(i){const e=zd(h,o),t=iW({inputs:{x:g},backend:n,attrs:{shape:e}});return n.disposeIntermediateTensorInfo(g),t}return g}const xW={kernelName:It,backendName:"cpu",kernelFunc:bW};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function wW(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;hz(s,"any");const o=De(a,s.shape);let u=o;const l=Bd(u,s.shape.length);let c=s;null!=l&&(c=UP({inputs:{x:s},backend:n,attrs:{perm:l}}),u=Vd(u.length,s.shape.length)),Pd("any",u,c.shape.length);const[h,p]=Ld(c.shape,u),d=Ie(p),f=et(Ie(h),c.dtype),m=n.data.get(c.dataId).values;for(let y=0;y<f.length;++y){const e=y*d;let t=m[e];for(let n=0;n<d;++n){const r=m[e+n];t=t||r}f[y]=t}null!=l&&n.disposeIntermediateTensorInfo(c);const g=n.makeTensorInfo(h,c.dtype,f);if(i){const e=zd(h,o),t=iW({inputs:{x:g},backend:n,attrs:{shape:e}});return n.disposeIntermediateTensorInfo(g),t}return g}const vW={kernelName:Nt,backendName:"cpu",kernelFunc:wW};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function kW(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r;hz(s,"argMax");let i=De(a,s.shape);const o=Bd(i,s.shape.length);let u=s;const l=[];null!=o&&(u=UP({inputs:{x:s},backend:n,attrs:{perm:o}}),l.push(u),i=Vd(i.length,u.shape.length)),i=[i[0]],Pd("argMax",i,u.shape.length);const[c,h]=Ld(u.shape,i),p=Ie(c),d=et(p,"int32"),f=Ie(h),m=n.data.get(u.dataId).values;for(let g=0;g<d.length;++g){const e=g*f;let t=m[e],n=0;for(let r=0;r<f;++r){const s=m[e+r];s>t&&(t=s,n=r)}d[g]=n}return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(c,"int32",d)}const IW={kernelName:St,backendName:"cpu",kernelFunc:kW};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function NW(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r;hz(s,"argMin");let i=De(a,s.shape);const o=Bd(i,s.shape.length);let u=s;const l=[];null!=o&&(u=UP({inputs:{x:s},backend:n,attrs:{perm:o}}),l.push(u),i=Vd(i.length,u.shape.length)),i=[i[0]],Pd("argMin",i,u.shape.length);const[c,h]=Ld(u.shape,i),p=Ie(c),d=et(p,"int32"),f=Ie(h),m=n.data.get(u.dataId).values;for(let g=0;g<d.length;++g){const e=g*f;let t=m[e],n=0;for(let r=0;r<f;++r){const s=m[e+r];s<t&&(t=s,n=r)}d[g]=n}return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(c,"int32",d)}const SW={kernelName:Tt,backendName:"cpu",kernelFunc:NW},TW=Bz($t,(e=>Math.asin(e))),$W={kernelName:$t,backendName:"cpu",kernelFunc:TW},CW=Bz(Ct,(e=>Math.asinh(e))),EW={kernelName:Ct,backendName:"cpu",kernelFunc:CW},RW=Bz(Et,(e=>Math.atan(e))),AW={kernelName:Et,backendName:"cpu",kernelFunc:RW},FW=yz(((e,t)=>Math.atan2(e,t))),_W=Cz(At,FW),DW={kernelName:At,backendName:"cpu",kernelFunc:_W},OW=Bz(Rt,(e=>Math.atanh(e))),MW={kernelName:Rt,backendName:"cpu",kernelFunc:OW};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function LW(e,t,n,r,s,a){const i=s.strideHeight,o=s.strideWidth,u=s.dilationHeight,l=s.dilationWidth,c=s.effectiveFilterHeight,h=s.effectiveFilterWidth,p=s.padInfo.top,d=s.padInfo.left,f="max"===a?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=qo(s.outShape,n),g=m.values,y=s.outShape[1]*s.outShape[2]*s.outShape[3],b=s.outShape[2]*s.outShape[3],x=s.outShape[3];for(let w=0;w<s.batchSize;++w){const t=w*y,n=w*r[0];for(let m=0;m<s.inChannels;++m)for(let y=0;y<s.outHeight;++y){const w=y*i-p,v=Math.max(0,w),k=Math.min(s.inHeight,c+w),I=t+y*b;for(let t=0;t<s.outWidth;++t){const i=t*o-d,c=Math.max(0,i),p=Math.min(s.inWidth,h+i);let y=f,b=0,w=0;for(let t=v;t<k;t+=u){const s=n+t*r[1];for(let t=c;t<p;t+=l){const n=s+t*r[2],i=e[n+m];"max"===a&&i>y?y=i:"avg"===a&&(b+=i,w++)}if(isNaN(y))break}const N=I+t*x+m;g[N]="avg"===a?b/w:y}}}return m}function zW(e,t,n,r,s=!1,a=!1){const i=qo(r.outShape,"int32"),o=r.strideHeight,u=r.strideWidth,l=r.dilationHeight,c=r.dilationWidth,h=r.effectiveFilterHeight,p=r.effectiveFilterWidth,d=r.padInfo.top,f=r.padInfo.left,m=qo(t,n,e);for(let g=0;g<r.batchSize;++g)for(let e=0;e<r.inChannels;++e)for(let t=0;t<r.outHeight;++t){const n=t*o-d;let y=n;while(y<0)y+=l;const b=Math.min(r.inHeight,h+n);for(let o=0;o<r.outWidth;++o){const h=o*u-f;let d=h;while(d<0)d+=c;const x=Math.min(r.inWidth,p+h);let w=Number.NEGATIVE_INFINITY,v=-1;for(let t=y;t<b;t+=l){const i=t-n;for(let n=d;n<x;n+=c){const o=n-h,u=m.get(g,t,n,e);u>w&&(w=u,v=s?a?((g*r.inHeight+t)*r.inWidth+n)*r.inChannels+e:(t*r.inWidth+n)*r.inChannels+e:i*p+o)}}i.set(v,g,t,o,e)}}return i}function PW(e,t,n,r,s,a){const i=s.strideDepth,o=s.strideHeight,u=s.strideWidth,l=s.dilationDepth,c=s.dilationHeight,h=s.dilationWidth,p=s.effectiveFilterDepth,d=s.effectiveFilterHeight,f=s.effectiveFilterWidth,m=s.padInfo.front,g=s.padInfo.top,y=s.padInfo.left,b="max"===a?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,x=qo(s.outShape,n),w=x.values,v=s.outShape[1]*s.outShape[2]*s.outShape[3]*s.outShape[4],k=s.outShape[2]*s.outShape[3]*s.outShape[4],I=s.outShape[3]*s.outShape[4],N=s.outShape[4];for(let S=0;S<s.batchSize;++S){const t=S*v,n=S*r[0];for(let x=0;x<s.inChannels;++x)for(let v=0;v<s.outDepth;++v){const S=v*i-m;let T=S;while(T<0)T+=l;const $=Math.min(s.inDepth,p+S),C=t+v*k;for(let t=0;t<s.outHeight;++t){const i=t*o-g;let p=i;while(p<0)p+=c;const m=Math.min(s.inHeight,d+i),v=C+t*I;for(let t=0;t<s.outWidth;++t){const i=t*u-y;let o=i;while(o<0)o+=h;const d=Math.min(s.inWidth,f+i),g=v+t*N;let k=b,I=0,S=0;for(let t=T;t<$;t+=l){const s=n+t*r[1];for(let t=p;t<m;t+=c){const n=s+t*r[2];for(let t=o;t<d;t+=h){const s=n+t*r[3],i=e[s+x];if("max"===a&&i>k?k=i:"avg"===a&&(I+=i,S++),isNaN(k))break}if(isNaN(k))break}if(isNaN(k))break}const C=g+x;w[C]="avg"===a?I/Math.max(S,1):k}}}}return x}function BW(e,t){const n=qo(t.outShape,"int32"),r=t.strideDepth,s=t.strideHeight,a=t.strideWidth,i=t.dilationDepth,o=t.dilationHeight,u=t.dilationWidth,l=t.effectiveFilterDepth,c=t.effectiveFilterHeight,h=t.effectiveFilterWidth,p=t.padInfo.front,d=t.padInfo.top,f=t.padInfo.left;for(let m=0;m<t.batchSize;++m)for(let g=0;g<t.inChannels;++g)for(let y=0;y<t.outDepth;++y){const b=y*r-p;let x=b;while(x<0)x+=i;const w=Math.min(t.inDepth,l+b);for(let r=0;r<t.outHeight;++r){const l=r*s-d;let p=l;while(p<0)p+=o;const v=Math.min(t.inHeight,c+l);for(let s=0;s<t.outWidth;++s){const d=s*a-f;let k=d;while(k<0)k+=u;const I=Math.min(t.inWidth,h+d);let N=Number.NEGATIVE_INFINITY,S=-1;for(let t=x;t<w;t+=i){const n=t-b;for(let r=p;r<v;r+=o){const s=r-l;for(let a=k;a<I;a+=u){const i=a-d,o=e.get(m,t,r,a,g);o>=N&&(N=o,S=n*c*h+s*c+i)}}}n.set(S,m,y,r,s,g)}}}return n}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function WW(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;hz(s,"avgPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:u}=r,l=1;we(Gh(i,l),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${l}'`));const c=Rh(s.shape,a,i,l,o,u);let h;if(1===c.filterWidth&&1===c.filterHeight&&Te(c.inShape,c.outShape))h=vz({inputs:{x:s},backend:n});else{const e=n.data.get(s.dataId).values,t=Xe(s.shape),r=LW(e,s.shape,s.dtype,t,c,"avg");h=n.makeTensorInfo(c.outShape,s.dtype,r.values)}return h}const VW={kernelName:Ft,backendName:"cpu",kernelFunc:WW};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function UW(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:u,dataFormat:l}=r;hz(s,"avgPool3d");const c=Ah(s.shape,a,i,1,o,u,l),h=n.data.get(s.dataId).values,p=PW(h,s.shape,s.dtype,Xe(s.shape),c,"avg");return n.makeTensorInfo(p.shape,"float32",p.values)}const GW={kernelName:Dt,backendName:"cpu",kernelFunc:UW};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function HW(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,{filterSize:i,strides:o,pad:u,dimRoundingMode:l}=r;hz([s,a],"avgPool3DGrad");const c=Ah(a.shape,i,o,1,u,l),h=c.strideDepth,p=c.strideHeight,d=c.strideWidth,f=c.filterDepth,m=c.filterHeight,g=c.filterWidth,y=c.dilationDepth,b=c.dilationHeight,x=c.dilationWidth,w=c.effectiveFilterDepth,v=c.effectiveFilterHeight,k=c.effectiveFilterWidth,I=w-1-c.padInfo.front,N=k-1-c.padInfo.left,S=v-1-c.padInfo.top,T=qo(a.shape,"float32"),$=1/(f*m*g),C=n.bufferSync(s);for(let E=0;E<c.batchSize;++E)for(let e=0;e<c.inChannels;++e)for(let t=0;t<c.inDepth;++t)for(let n=0;n<c.inHeight;++n)for(let r=0;r<c.inWidth;++r){const s=t-I,a=n-S,i=r-N;let o=0;for(let t=0;t<w;t+=y){const n=(s+t)/h;if(!(n<0||n>=c.outDepth||Math.floor(n)!==n))for(let t=0;t<v;t+=b){const r=(a+t)/p;if(!(r<0||r>=c.outHeight||Math.floor(r)!==r))for(let t=0;t<k;t+=x){const s=(i+t)/d;if(s<0||s>=c.outWidth||Math.floor(s)!==s)continue;const a=C.get(E,n,r,s,e);o+=a}}}T.set(o*$,E,t,n,r,e)}return n.makeTensorInfo(T.shape,T.dtype,T.values)}const jW={kernelName:Ot,backendName:"cpu",kernelFunc:HW};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function qW(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a;hz([s,a],"avgPoolGrad");const{filterSize:o,strides:u,pad:l}=r,c=Rh(i.shape,o,u,1,l),h=c.strideHeight,p=c.strideWidth,d=c.filterHeight,f=c.filterWidth,m=c.dilationHeight,g=c.dilationWidth,y=c.effectiveFilterHeight,b=c.effectiveFilterWidth,x=b-1-c.padInfo.left,w=y-1-c.padInfo.top,v=qo(i.shape,"float32"),k=1/(d*f),I=n.data.get(s.dataId).values,N=qo(s.shape,"float32",I);for(let S=0;S<c.batchSize;++S)for(let e=0;e<c.inChannels;++e)for(let t=0;t<c.inHeight;++t)for(let n=0;n<c.inWidth;++n){const r=t-w,s=n-x;let a=0;for(let t=0;t<y;t+=m){const n=(r+t)/h;if(!(n<0||n>=c.outHeight||Math.floor(n)!==n))for(let t=0;t<b;t+=g){const r=(s+t)/p;if(r<0||r>=c.outWidth||Math.floor(r)!==r)continue;const i=N.get(S,n,r,e);a+=i}}v.set(a*k,S,t,n,e)}return n.makeTensorInfo(v.shape,v.dtype,v.values)}const KW={kernelName:_t,backendName:"cpu",kernelFunc:qW};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function XW(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,scale:a,offset:i,mean:o,variance:u}=t;we(o.shape.length===u.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),we(null==i||o.shape.length===i.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),we(null==a||o.shape.length===a.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks.")),hz([s,o,u,a,i],"batchNorm");let{varianceEpsilon:l}=r;null==l&&(l=.001);const c=n.data.get(s.dataId).values,h=n.data.get(o.dataId).values,p=n.data.get(u.dataId).values,d=a?n.data.get(a.dataId).values:new Float32Array([1]),f=i?n.data.get(i.dataId).values:new Float32Array([0]),m=new Float32Array(c.length),g=f.length,y=d.length,b=p.length,x=h.length;let w=0,v=0,k=0,I=0;for(let N=0;N<c.length;++N)m[N]=f[w++]+(c[N]-h[v++])*d[k++]/Math.sqrt(p[I++]+l),w>=g&&(w=0),v>=x&&(v=0),k>=y&&(k=0),I>=b&&(I=0);return n.makeTensorInfo(s.shape,s.dtype,m)}const YW={kernelName:Rn,backendName:"cpu",kernelFunc:XW};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function JW(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,crops:i}=r;hz([s],"batchToSpaceND");const o=a.reduce(((e,t)=>e*t)),u=Ww(s.shape,a,o),l=Vw(u.length,a.length),c=Uw(s.shape,a,o),h=Gw(i,a.length),p=Hw(c,i,a.length),d=iW({inputs:{x:s},backend:n,attrs:{shape:u}}),f=UP({inputs:{x:d},backend:n,attrs:{perm:l}}),m=iW({inputs:{x:f},backend:n,attrs:{shape:c}}),g=bB({inputs:{x:m},backend:n,attrs:{begin:h,size:p}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}const ZW={kernelName:Lt,backendName:"cpu",kernelFunc:JW};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function QW(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i}=r,o=n.data.get(s.dataId).values,u=n.data.get(a.dataId).values,l=Dz(o,u,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,l)}const eV={kernelName:zt,backendName:"cpu",kernelFunc:QW};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function tV(e){const{inputs:t,backend:n}=e,{s0:r,s1:s}=t,a=n.data.get(r.dataId).values,i=n.data.get(s.dataId).values,o=ul(Array.from(a),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}const nV={kernelName:Wt,backendName:"cpu",kernelFunc:tV},rV=Bz(Gt,((e,t)=>{const n=t;return e>n.clipValueMax?n.clipValueMax:e<n.clipValueMin?n.clipValueMin:e})),sV={kernelName:Gt,backendName:"cpu",kernelFunc:rV},aV=e=>{const{x:t}=e.inputs,n=e.backend,r=new Float32Array(Ie(t.shape)),s=n.data.get(t.dataId),a=s.complexTensorInfos.real,i=s.complexTensorInfos.imag,o=n.data.get(a.dataId).values,u=n.data.get(i.dataId).values;for(let l=0;l<o.length;l++){const e=o[l],t=u[l];r[l]=Math.hypot(e,t)}return n.makeOutput(r,t.shape,"float32")},iV={kernelName:jt,backendName:"cpu",kernelFunc:aV};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function oV(e){const{inputs:t,backend:n}=e,{input:r}=t,s=n.data.get(r.dataId).complexTensorInfos.imag,a=n.data.get(s.dataId).values;return n.makeTensorInfo(s.shape,s.dtype,a)}const uV={kernelName:Ln,backendName:"cpu",kernelFunc:oV};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function lV(e){const{inputs:t,backend:n,attrs:r}=e,{axis:s}=r,a=De(s,t[0].shape)[0],i=t.map((e=>e.shape));Aw(i,a);let o=Fw(t.map((e=>e.shape)),a);if(0===Ie(o))return n.makeTensorInfo(o,t[0].dtype,[]);const u=t.filter((e=>Ie(e.shape)>0));if(1===u.length)return vz({inputs:{x:u[0]},backend:n});if("complex64"===u[0].dtype){const e=u.map((e=>Iz({inputs:{input:e},backend:n}))),t=u.map((e=>oV({inputs:{input:e},backend:n}))),r=lV({inputs:e,backend:n,attrs:{axis:a}}),s=lV({inputs:t,backend:n,attrs:{axis:a}}),i=bz({inputs:{real:r,imag:s},backend:n});return e.forEach((e=>n.disposeIntermediateTensorInfo(e))),t.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(s),i}const l=u.map((e=>{const t=Ie(e.shape.slice(a)),r=[-1,t];return iW({inputs:{x:e},backend:n,attrs:{shape:r}})})),c=l.map((e=>({vals:n.data.get(e.dataId).values,shape:e.shape})));o=Fw(l.map((e=>e.shape)),1);const h=1===l[0].shape[0],p=Hz(c,o,t[0].dtype,h),d=Fw(u.map((e=>e.shape)),a),f=n.makeTensorInfo(d,t[0].dtype,p);return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),f}const cV={kernelName:qt,backendName:"cpu",kernelFunc:lV};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function hV(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dataFormat:u,dilations:l,dimRoundingMode:c}=r;hz([s,a],"conv2d");const h=jh(u),p=Fh(s.shape,a.shape,i,l,o,c,!1,h),d=p.filterHeight,f=p.filterWidth,m=p.dilationHeight,g=p.dilationWidth,y=p.padInfo.left,b=p.padInfo.top,x="channelsLast"===p.dataFormat,w=new Pa(p.outShape,s.dtype),v=Xe(s.shape),k=Xe(a.shape),I=v[0],N=x?v[1]:v[2],S=x?v[2]:1,T=x?1:v[1],$=w.strides[0],C=x?w.strides[1]:w.strides[2],E=x?w.strides[2]:1,R=x?1:w.strides[1],A=n.data.get(s.dataId).values,F=n.data.get(a.dataId).values,_=w.values;for(let D=0;D<p.batchSize;++D){const e=D*I,t=D*$;for(let n=0;n<p.outHeight;++n){const r=t+n*C,s=n*p.strideHeight-b;for(let t=0;t<d;++t){const n=s+t*m;if(n<0||n>=p.inHeight)continue;const a=t*k[0],i=e+n*N;for(let e=0;e<p.outWidth;++e){const t=r+e*E,n=e*p.strideWidth-y;for(let e=0;e<f;++e){const r=n+e*g;if(r<0||r>=p.inWidth)continue;const s=a+e*k[1],o=i+r*S;let u=s;for(let e=0;e<p.inChannels;++e){const n=A[o+e*T];for(let e=0;e<p.outChannels;++e)_[t+e*R]+=n*F[u+e];u+=p.outChannels}}}}}}return n.makeTensorInfo(w.shape,w.dtype,_)}const pV={kernelName:Kt,backendName:"cpu",kernelFunc:hV};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function dV(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,dataFormat:u,dimRoundingMode:l,filterShape:c}=r;hz([s,a],"conv2dBackpropFilter");const h=jh(u),p=Fh(s.shape,c,i,1,o,l,!1,h),{strideHeight:d,strideWidth:f,filterHeight:m,filterWidth:g}=p,y="channelsLast"===p.dataFormat,b=new Pa(p.filterShape,"float32"),x=p.padInfo.left,w=p.padInfo.top,v=n.data.get(s.dataId).values,k=n.data.get(a.dataId).values,I=new Pa(s.shape,s.dtype,v),N=new Pa(a.shape,a.dtype,k);for(let S=0;S<m;++S){const e=Math.max(0,Math.ceil((w-S)/d)),t=Math.min(p.outHeight,(p.inHeight+w-S)/d);for(let n=0;n<g;++n){const r=Math.max(0,Math.ceil((x-n)/f)),s=Math.min(p.outWidth,(p.inWidth+x-n)/f);for(let a=0;a<p.inChannels;++a)for(let i=0;i<p.outChannels;++i){let o=0;for(let u=0;u<p.batchSize;++u)for(let l=e;l<t;++l){const e=S+l*d-w;for(let t=r;t<s;++t){const r=n+t*f-x;o+=y?I.get(u,e,r,a)*N.get(u,l,t,i):I.get(u,a,e,r)*N.get(u,i,l,t)}}b.set(o,S,n,a,i)}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}const fV={kernelName:Xt,backendName:"cpu",kernelFunc:dV};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function mV(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{inputShape:i,strides:o,pad:u,dataFormat:l,dimRoundingMode:c}=r;hz([s,a],"conv2dBackpropInput");const h=Xe(a.shape),p=Xe(s.shape);let d=jh(l);const f=Fh(i,a.shape,o,1,u,c,!1,d),m=new Pa(f.inShape,"float32"),g=m.values,y=n.data.get(s.dataId).values,b=n.data.get(a.dataId).values,[x,w,v]=h,{batchSize:k,filterHeight:I,filterWidth:N,inChannels:S,inHeight:T,inWidth:$,outChannels:C,outHeight:E,outWidth:R,strideHeight:A,strideWidth:F}=f;d=f.dataFormat;const _=I-1-f.padInfo.top,D=N-1-f.padInfo.left,O="channelsLast"===d,M=m.strides[0],L=O?m.strides[1]:m.strides[2],z=O?m.strides[2]:1,P=O?1:m.strides[1],B=p[0],W=O?p[1]:p[2],V=O?p[2]:1,U=O?1:p[1];for(let G=0;G<k;++G)for(let e=0;e<S;++e)for(let t=0;t<T;++t){const n=t-_,r=Math.max(0,Math.ceil(n/A)),s=Math.min(E,(I+n)/A);for(let a=0;a<$;++a){const i=a-D,o=Math.max(0,Math.ceil(i/F)),u=Math.min(R,(N+i)/F);let l=0;for(let t=r;t<s;++t){const r=t*A-n;for(let n=o;n<u;++n){const s=n*F-i,a=B*G+W*t+V*n,o=x*(I-1-r)+w*(N-1-s)+v*e;for(let e=0;e<C;++e){const t=y[a+U*e],n=b[o+e];l+=t*n}}}const c=M*G+L*t+z*a+P*e;g[c]=l}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}const gV={kernelName:Yt,backendName:"cpu",kernelFunc:mV};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function yV(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:u}=r;hz([s,a],"conv3d");const l=_h(s.shape,a.shape,i,u,o),{filterDepth:c,filterHeight:h,filterWidth:p,dilationDepth:d,dilationHeight:f,dilationWidth:m,padInfo:g}=l,y=g.front,b=g.left,x=g.top,w=new Pa(l.outShape,s.dtype),v=n.data.get(s.dataId).values,k=n.data.get(a.dataId).values,I=w.values,N=Xe(s.shape),S=Xe(a.shape);for(let T=0;T<l.batchSize;++T){const e=T*N[0],t=T*w.strides[0];for(let n=0;n<l.outDepth;++n){const r=t+n*w.strides[1],s=n*l.strideDepth-y;for(let t=0;t<c;++t){const n=s+t*d;if(n<0||n>=l.inDepth)continue;const a=t*S[0],i=e+n*N[1];for(let e=0;e<l.outHeight;++e){const t=r+e*w.strides[2],n=e*l.strideHeight-x;for(let e=0;e<h;++e){const r=n+e*f;if(r<0||r>=l.inHeight)continue;const s=a+e*S[1],o=i+r*N[2];for(let e=0;e<l.outWidth;++e){const n=t+e*l.outChannels,r=e*l.strideWidth-b;for(let e=0;e<p;++e){const t=r+e*m;if(t<0||t>=l.inWidth)continue;const a=s+e*S[2],i=o+t*l.inChannels;let u=a;for(let e=0;e<l.inChannels;++e){const t=v[i+e];for(let e=0;e<l.outChannels;++e)I[n+e]+=t*k[u+e];u+=l.outChannels}}}}}}}}return n.makeTensorInfo(w.shape,w.dtype,w.values)}const bV={kernelName:Jt,backendName:"cpu",kernelFunc:yV};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function xV(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,filterShape:u}=r;hz([s,a],"conv3dBackpropFilterV2");const l=Xe(s.shape),c=Xe(a.shape),h=_h(s.shape,u,i,1,o),p=h.strideDepth,d=h.strideHeight,f=h.strideWidth,m=h.filterDepth,g=h.filterHeight,y=h.filterWidth,b=new Pa(h.filterShape,"float32"),x=b.values,[w,v,k,I]=b.strides,N=n.data.get(a.dataId).values,[S,T,$,C]=c,E=n.data.get(s.dataId).values,[R,A,F,_]=l,D=h.padInfo.front,O=h.padInfo.left,M=h.padInfo.top;for(let L=0;L<m;++L){const e=Math.max(0,Math.ceil((D-L)/p)),t=Math.min(h.outDepth,(h.inDepth+D-L)/p),n=L*w;for(let r=0;r<g;++r){const s=Math.max(0,Math.ceil((M-r)/d)),a=Math.min(h.outHeight,(h.inHeight+M-r)/d),i=r*v+n;for(let n=0;n<y;++n){const o=Math.max(0,Math.ceil((O-n)/f)),u=Math.min(h.outWidth,(h.inWidth+O-n)/f),l=n*k+i;for(let i=0;i<h.inChannels;++i){const c=i*I+l;for(let l=0;l<h.outChannels;++l){let m=0;for(let c=0;c<h.batchSize;++c){const h=c*R,g=c*S;for(let c=e;c<t;++c){const e=L+c*p-D,t=e*A+h,y=c*T+g;for(let c=s;c<a;++c){const e=r+c*d-M,s=e*F+t,a=c*$+y;for(let t=o;t<u;++t){const e=n+t*f-O,r=e*_+s,o=t*C+a;m+=E[r+i]*N[o+l]}}}}x[c+l]=m}}}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}const wV={kernelName:Zt,backendName:"cpu",kernelFunc:xV};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function vV(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{pad:i,strides:o,inputShape:u}=r;hz([s],"conv3dBackpropInputV2");const l=Xe(s.shape),c=Xe(a.shape),h=_h(u,a.shape,o,1,i),p=new Pa(h.inShape,"float32"),d=p.values,[f,m,g,y]=p.strides,b=n.data.get(s.dataId).values,[x,w,v,k]=l,I=n.data.get(a.dataId).values,[N,S,T,$]=c,{batchSize:C,filterDepth:E,filterHeight:R,filterWidth:A,inChannels:F,inDepth:_,inHeight:D,inWidth:O,outChannels:M,outDepth:L,outHeight:z,outWidth:P,strideDepth:B,strideHeight:W,strideWidth:V}=h,U=E-1-h.padInfo.front,G=R-1-h.padInfo.top,H=A-1-h.padInfo.left;for(let j=0;j<C;++j)for(let e=0;e<F;++e)for(let t=0;t<_;++t){const n=t-U,r=Math.max(0,Math.ceil(n/B)),s=Math.min(L,(E+n)/B);for(let a=0;a<D;++a){const i=a-G,o=Math.max(0,Math.ceil(i/W)),u=Math.min(z,(R+i)/W);for(let l=0;l<O;++l){const c=l-H,h=Math.max(0,Math.ceil(c/V)),p=Math.min(P,(A+c)/V);let C=0;for(let t=r;t<s;++t){const r=t*B-n;for(let n=o;n<u;++n){const s=n*W-i;for(let a=h;a<p;++a){const i=a*V-c,o=x*j+w*t+v*n+k*a,u=N*(E-1-r)+S*(R-1-s)+T*(A-1-i)+$*e;for(let e=0;e<M;++e){const t=b[o+e],n=I[u+e];C+=t*n}}}}d[f*j+m*t+g*a+y*l+e]=C}}}return n.makeTensorInfo(p.shape,p.dtype,p.values)}const kV={kernelName:Qt,backendName:"cpu",kernelFunc:vV},IV=Bz(en,(e=>Math.cos(e))),NV={kernelName:en,backendName:"cpu",kernelFunc:IV},SV=Bz(tn,(e=>Math.cosh(e))),TV={kernelName:tn,backendName:"cpu",kernelFunc:SV};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function $V(e){const{inputs:t,backend:n,attrs:r}=e,{image:s,boxes:a,boxInd:i}=t,{cropSize:o,method:u,extrapolationValue:l}=r,[c,h,p,d]=s.shape,f=a.shape[0],[m,g]=o,y=qo([f,m,g,d],"float32"),b=n.data.get(a.dataId).values,x=n.data.get(i.dataId).values,w=n.data.get(s.dataId).values,v=Xe(s.shape),k=Xe(y.shape);for(let I=0;I<f;I++){const e=4*I,t=b[e],n=b[e+1],r=b[e+2],s=b[e+3],a=x[I];if(a>=c)continue;const i=m>1?(r-t)*(h-1)/(m-1):0,o=g>1?(s-n)*(p-1)/(g-1):0;for(let c=0;c<m;c++){const e=m>1?t*(h-1)+c*i:.5*(t+r)*(h-1);if(e<0||e>h-1)for(let t=0;t<g;t++)for(let e=0;e<d;e++){const n=e+t*k[2]+c*k[1]+I*k[0];y.values[n]=l}else if("bilinear"===u){const t=Math.floor(e),r=Math.ceil(e),i=e-t;for(let e=0;e<g;e++){const u=g>1?n*(p-1)+e*o:.5*(n+s)*(p-1);if(u<0||u>p-1){for(let t=0;t<d;t++){const n=t+e*k[2]+c*k[1]+I*k[0];y.values[n]=l}continue}const h=Math.floor(u),f=Math.ceil(u),m=u-h;for(let n=0;n<d;n++){let s=n+h*v[2]+t*v[1]+a*v[0];const o=w[s];s=n+f*v[2]+t*v[1]+a*v[0];const u=w[s];s=n+h*v[2]+r*v[1]+a*v[0];const l=w[s];s=n+f*v[2]+r*v[1]+a*v[0];const p=w[s],d=o+(u-o)*m,g=l+(p-l)*m;s=n+e*k[2]+c*k[1]+I*k[0],y.values[s]=d+(g-d)*i}}}else for(let t=0;t<g;++t){const r=g>1?n*(p-1)+t*o:.5*(n+s)*(p-1);if(r<0||r>p-1){for(let e=0;e<d;e++){const n=e+t*k[2]+c*k[1]+I*k[0];y.values[n]=l}continue}const i=Math.round(r),u=Math.round(e);for(let e=0;e<d;e++){const n=e+i*v[2]+u*v[1]+a*v[0],r=e+t*k[2]+c*k[1]+I*k[0];y.values[r]=w[n]}}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}const CV={kernelName:sn,backendName:"cpu",kernelFunc:$V};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function EV(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r;hz(s,"cumprod");const u=Bd([a],s.shape.length);let l=s;null!=u&&(l=UP({inputs:{x:s},backend:n,attrs:{perm:u}}));const c=Vd(1,s.shape.length)[0];if(c!==l.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${l.shape.length-1} but got axis=${c}`);const h=ti(l.dtype,"int32"),p=Qe(Ie(l.shape),h),d=n.data.get(l.dataId).values,f=l.shape[l.shape.length-1],m=o?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let y=0;y<d.length;y+=f)for(let e=0;e<f;e++){const t=m(y,e);if(0===e)p[t]=i?1:d[t];else{const n=m(y,e-1);p[t]=i?d[n]*p[n]:d[t]*p[n]}}const g=n.makeTensorInfo(l.shape,h,p);if(null!=u){const e=Wd(u),t=UP({inputs:{x:g},backend:n,attrs:{perm:e}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(l),t}return g}const RV={kernelName:nn,backendName:"cpu",kernelFunc:EV};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function AV(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r;hz(s,"cumsum");const u=Bd([a],s.shape.length);let l=s;null!=u&&(l=UP({inputs:{x:s},backend:n,attrs:{perm:u}}));const c=Vd(1,s.shape.length)[0];if(c!==l.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${l.shape.length-1} but got axis=${c}`);const h=ti(l.dtype,"int32"),p=et(Ie(l.shape),h),d=n.data.get(l.dataId).values,f=l.shape[l.shape.length-1],m=o?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let y=0;y<d.length;y+=f)for(let e=0;e<f;e++){const t=m(y,e);if(0===e)p[t]=i?0:d[t];else{const n=m(y,e-1);p[t]=i?d[n]+p[n]:d[t]+p[n]}}const g=n.makeTensorInfo(l.shape,h,p);if(null!=u){const e=Wd(u),t=UP({inputs:{x:g},backend:n,attrs:{perm:e}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(l),t}return g}const FV={kernelName:rn,backendName:"cpu",kernelFunc:AV};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function _V(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i,binaryOutput:o}=r;if(1===s.shape.length){const e=n.data.get(s.dataId).values,t=n.data.get(a.dataId).values,r=Dz(e,t,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,r)}if(2===s.shape.length){const e=n.bufferSync(s),t=n.bufferSync(a),r=Oz(e,t,i,o);return n.makeTensorInfo(r.shape,a.dtype,r.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}const DV={kernelName:an,backendName:"cpu",kernelFunc:_V};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function OV(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockSize:a,dataFormat:i}=r;we("NHWC"===i,(()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`));const o=s.shape[0],u=s.shape[1],l=s.shape[2],c=s.shape[3],h=u*a,p=l*a,d=c/(a*a),f=n.data.get(s.dataId).values,m=new Float32Array(o*h*p*d);let g=0;for(let y=0;y<o;++y)for(let e=0;e<h;++e){const t=Math.floor(e/a),n=e%a;for(let e=0;e<p;++e){const r=Math.floor(e/a),s=e%a,i=(n*a+s)*d;for(let e=0;e<d;++e){const n=e+i,s=n+c*(r+l*(t+u*y));m[g++]=f[s]}}}return n.makeTensorInfo([o,h,p,d],s.dtype,m)}const MV={kernelName:on,backendName:"cpu",kernelFunc:OV};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function LV(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:u,dimRoundingMode:l}=r;hz([s,a],"depthwiseConv2DNative");const c=Xe(s.shape),h=Xe(a.shape);let p=u;null==p&&(p=[1,1]),we(Gh(i,p),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${p}'`));const d=Fh(s.shape,a.shape,i,p,o,l,!0),{filterHeight:f,filterWidth:m,dilationHeight:g,dilationWidth:y,padInfo:b}=d,x=b.left,w=b.top,v=d.outChannels/d.inChannels,k=new Pa(d.outShape,s.dtype),I=n.data.get(s.dataId).values,N=n.data.get(a.dataId).values,S=k.values;for(let T=0;T<d.batchSize;++T){const e=T*c[0],t=T*k.strides[0];for(let n=0;n<d.outHeight;++n){const r=t+n*k.strides[1],s=n*d.strideHeight-w;for(let t=0;t<f;++t){const n=s+t*g;if(n<0||n>=d.inHeight)continue;const a=t*h[0],i=e+n*c[1];for(let e=0;e<d.outWidth;++e){const t=r+e*k.strides[2],n=e*d.strideWidth-x;for(let e=0;e<m;++e){const r=n+e*y;if(r<0||r>=d.inWidth)continue;const s=a+e*h[1],o=i+r*d.inChannels;let u=t,l=s;for(let e=0;e<d.inChannels;++e){const t=I[o+e];for(let e=0;e<v;++e)S[u+e]+=t*N[l+e];u+=v,l+=v}}}}}}return n.makeTensorInfo(k.shape,k.dtype,k.values)}const zV={kernelName:un,backendName:"cpu",kernelFunc:LV};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function PV(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,dilations:o,pad:u,dimRoundingMode:l,filterShape:c}=r;hz([s,a],"depthwiseConv2dNativeBackpropFilter");const h=Fh(s.shape,c,i,o,u,l,!0),{strideHeight:p,strideWidth:d,filterHeight:f,filterWidth:m}=h,g=new Pa(h.filterShape,"float32"),y=h.padInfo.left,b=h.padInfo.top,x=h.outChannels/h.inChannels,w=n.data.get(s.dataId).values,v=new Pa(s.shape,s.dtype,w),k=n.data.get(a.dataId).values,I=new Pa(a.shape,a.dtype,k);for(let N=0;N<f;++N){const e=Math.max(0,Math.ceil((b-N)/p)),t=Math.min(h.outHeight,(h.inHeight+b-N)/p);for(let n=0;n<m;++n){const r=Math.max(0,Math.ceil((y-n)/d)),s=Math.min(h.outWidth,(h.inWidth+y-n)/d);for(let a=0;a<h.outChannels;++a){const i=Math.trunc(a/x),o=a%x;let u=0;for(let l=0;l<h.batchSize;++l)for(let o=e;o<t;++o){const e=N+o*p-b;for(let t=r;t<s;++t){const r=n+t*d-y;u+=v.get(l,e,r,i)*I.get(l,o,t,a)}}g.set(u,N,n,i,o)}}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}const BV={kernelName:ln,backendName:"cpu",kernelFunc:PV};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function WV(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{strides:i,dilations:o,pad:u,dimRoundingMode:l,inputShape:c}=r;hz([s,a],"depthwiseConv2DNativeBackpropInput");const h=Xe(s.shape),p=Xe(a.shape),d=Fh(c,a.shape,i,o,u,l,!0),f=new Pa(d.inShape,"float32"),m=f.values,[g,y,b]=f.strides,x=n.data.get(s.dataId).values,[w,v,k]=h,I=n.data.get(a.dataId).values,[N,S,T]=p,{batchSize:$,filterHeight:C,filterWidth:E,inChannels:R,inHeight:A,inWidth:F,outChannels:_,outHeight:D,outWidth:O,strideHeight:M,strideWidth:L}=d,z=C-1-d.padInfo.top,P=E-1-d.padInfo.left,B=_/R;for(let W=0;W<$;++W)for(let e=0;e<R;++e)for(let t=0;t<A;++t){const n=t-z,r=Math.max(0,Math.ceil(n/M)),s=Math.min(D,(C+n)/M);for(let a=0;a<F;++a){const i=a-P,o=Math.max(0,Math.ceil(i/L)),u=Math.min(O,(E+i)/L);let l=0;for(let t=r;t<s;++t){const r=t*M-n;for(let n=o;n<u;++n){const s=n*L-i,a=w*W+v*t+k*n,o=N*(C-1-r)+S*(E-1-s)+T*e;for(let t=0;t<B;++t){const n=e*B+t,r=x[a+n],s=I[o+t];l+=r*s}}}m[g*W+y*t+b*a+e]=l}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}const VV={kernelName:cn,backendName:"cpu",kernelFunc:WV};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function UV(e){const{inputs:t,backend:n}=e,{x:r}=t,s=Ie(r.shape),a=n.data.get(r.dataId).values,i=qo([s,s],r.dtype),o=i.values;for(let l=0;l<a.length;l++)o[l*s+l]=a[l];const u=[...r.shape,...r.shape];return n.makeTensorInfo(u,i.dtype,i.values)}const GV={kernelName:hn,backendName:"cpu",kernelFunc:UV},HV={kernelName:pn,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r,filter:s}=e,{strides:a,pad:i,dilations:o}=n,u=t,l=u.data.get(r.dataId).values,c=r.shape.length,h=u.data.get(s.dataId).values,p=s.shape.length,{batchSize:d,inHeight:f,inWidth:m,inChannels:g,outHeight:y,outWidth:b,padInfo:x,strideHeight:w,strideWidth:v,filterHeight:k,filterWidth:I,dilationHeight:N,dilationWidth:S,outShape:T}=Eh(r.shape,s.shape,a,i,"NHWC",o),$=Ie(T),C=T.length,E=Le(r.dtype,$);for(let A=0;A<d;++A)for(let e=0;e<y;++e){const t=e*w-x.top;for(let n=0;n<b;++n){const a=n*v-x.left;for(let i=0;i<g;++i){let o=Number.MIN_SAFE_INTEGER;for(let e=0;e<k;++e){const n=t+e*N;if(n>=0&&n<f)for(let t=0;t<I;++t){const u=a+t*S;if(u>=0&&u<m){const a=rt([A,n,u,i],c,Xe(r.shape)),d=rt([e,t,i],p,Xe(s.shape)),f=l[a]+h[d];f>o&&(o=f)}}}const u=rt([A,e,n,i],C,Xe(T));E[u]=o}}}const R=u.write(ba(E,r.dtype),T,r.dtype);return{dataId:R,shape:T,dtype:r.dtype}}},jV={kernelName:fn,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r,filter:s,dy:a}=e,{strides:i,pad:o,dilations:u}=n,l=t,c=Je(r.shape,l.data.get(r.dataId).values),h=Je(s.shape,l.data.get(s.dataId).values),{batchSize:p,inHeight:d,inWidth:f,inChannels:m,outHeight:g,outWidth:y,padInfo:b,strideHeight:x,strideWidth:w,filterHeight:v,filterWidth:k,dilationHeight:I,dilationWidth:N,outShape:S}=Eh(r.shape,s.shape,i,o,"NHWC",u);we(a.rank===S.length,(()=>`Error in ${fn}, dy must have the same rank as output ${S.length}, but got ${a.rank}`));const T=Je(S,l.data.get(a.dataId).values),$=tt(s.shape,s.dtype);for(let E=0;E<p;++E)for(let e=0;e<g;++e){const t=e*x-b.top;for(let n=0;n<y;++n){const r=n*w-b.left;for(let s=0;s<m;++s){let a=Number.MIN_SAFE_INTEGER,i=0,o=0;for(let e=0;e<v;++e){const n=t+e*I;if(n>=0&&n<d)for(let t=0;t<k;++t){const u=r+t*N;if(u>=0&&u<f){const r=c[E][n][u][s]+h[e][t][s];r>a&&(a=r,i=e,o=t)}}}$[i][o][s]+=T[E][e][n][s]}}}const C=l.write(ba($,r.dtype),s.shape,s.dtype);return{dataId:C,shape:s.shape,dtype:s.dtype}}},qV={kernelName:dn,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r,filter:s,dy:a}=e,{strides:i,pad:o,dilations:u}=n,l=t,c=Je(r.shape,l.data.get(r.dataId).values),h=Je(s.shape,l.data.get(s.dataId).values),{batchSize:p,inHeight:d,inWidth:f,inChannels:m,outHeight:g,outWidth:y,padInfo:b,strideHeight:x,strideWidth:w,filterHeight:v,filterWidth:k,dilationHeight:I,dilationWidth:N,outShape:S}=Eh(r.shape,s.shape,i,o,"NHWC",u);we(a.rank===S.length,(()=>`Error in ${dn}, dy must have the same rank as output ${S.length}, but got ${a.rank}`));const T=Je(S,l.data.get(a.dataId).values),$=tt(r.shape,r.dtype);for(let E=0;E<p;++E)for(let e=0;e<g;++e){const t=e*x-b.top;for(let n=0;n<y;++n){const r=n*w-b.left;for(let s=0;s<m;++s){let a=Number.MIN_SAFE_INTEGER,i=t<0?0:t,o=r<0?0:r;for(let e=0;e<v;++e){const n=t+e*I;if(n>=0&&n<d)for(let t=0;t<k;++t){const u=r+t*N;if(u>=0&&u<f){const r=c[E][n][u][s]+h[e][t][s];r>a&&(a=r,i=n,o=u)}}}$[E][i][o][s]+=T[E][e][n][s]}}}const C=l.write(ba($,r.dtype),r.shape,r.dtype);return{dataId:C,shape:r.shape,dtype:r.dtype}}};
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function KV(e){const{inputs:t,backend:n,attrs:r}=e,{image:s}=t,{canvas:a,options:i}=r,{contextOptions:o,imageOptions:u}=i||{},l=(null===u||void 0===u?void 0:u.alpha)||1,c=(null===o||void 0===o?void 0:o.contextType)||"2d";if("2d"!==c)throw new Error(`Context type ${o.contextType} is not supported by the CPU backend.`);const h=a.getContext(c,(null===o||void 0===o?void 0:o.contextAttributes)||{});if(null==h)throw new Error(`Could not get the context with ${c} type.`);const[p,d]=s.shape.slice(0,2),f=2===s.shape.length?1:s.shape[2],m=n.data.get(s.dataId).values,g="float32"===s.dtype?255:1,y=new Uint8ClampedArray(d*p*4);for(let x=0;x<p*d;++x){const e=[0,0,0,255*l];for(let n=0;n<f;n++){const t=m[x*f+n];if("float32"===s.dtype){if(t<0||t>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${t}.`)}else if("int32"===s.dtype&&(t<0||t>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${t}.`);1===f?(e[0]=t*g,e[1]=t*g,e[2]=t*g):e[n]=t*g}const t=4*x;y[t+0]=Math.round(e[0]),y[t+1]=Math.round(e[1]),y[t+2]=Math.round(e[2]),y[t+3]=Math.round(e[3])}a.width=d,a.height=p;const b=new ImageData(y,d,p);return h.putImageData(b,0,0),s}const XV={kernelName:mn,backendName:"cpu",kernelFunc:KV};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function YV(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;let o;hz(s,"sum"),o="bool"===s.dtype?Tz({inputs:{x:s},backend:n,attrs:{dtype:"int32"}}):vz({inputs:{x:s},backend:n});const u=o.shape.length,l=De(a,o.shape),c=Bd(l,u);let h=l,p=o;null!=c&&(p=UP({inputs:{x:o},backend:n,attrs:{perm:c}}),h=Vd(h.length,u)),Pd("sum",h,p.shape.length);const[d,f]=Ld(p.shape,h),m=ti(p.dtype,"int32");let g=wz(n,d,m);const y=Ie(f),b=n.data.get(g.dataId).values,x=n.data.get(p.dataId).values;for(let w=0;w<b.length;++w){const e=w*y;let t=0;for(let n=0;n<y;++n)t+=x[e+n];b[w]=t}if(i){const e=zd(g.shape,l),t=g;g=iW({inputs:{x:g},backend:n,attrs:{shape:e}}),n.disposeIntermediateTensorInfo(t)}return n.disposeIntermediateTensorInfo(o),null!=c&&n.disposeIntermediateTensorInfo(p),g}const JV={kernelName:rs,backendName:"cpu",kernelFunc:YV};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ZV(e){const{inputs:t,backend:n,attrs:r}=e,{equation:s}=r,a=t,{allDims:i,summedDims:o,idDims:u}=pv(s,a.length);fv(i.length,u,a);const{path:l,steps:c}=mv(o,u),h=c.length;let p=null,d=i.length;const f=[];for(let m=0;m<h;++m){for(const e of c[m]){const{permutationIndices:t,expandDims:r}=dv(d,u[e]);let s;gv(t)?s=a[e]:(s=UP({inputs:{x:a[e]},backend:n,attrs:{perm:t}}),f.push(s));const i=s.shape.slice();for(let e=0;e<r.length;++e)i.splice(r[e],0,1);Te(s.shape,i)||(s=iW({inputs:{x:s},backend:n,attrs:{shape:i}}),f.push(s)),null===p?p=s:(p=DP({inputs:{a:s,b:p},backend:n}),f.push(p))}m<h-1&&(l[m]>=0&&(p=YV({inputs:{x:p},backend:n,attrs:{axis:l[m]-(i.length-d),keepDims:!1}}),f.push(p)),d--)}for(const m of f)m!==p&&n.disposeIntermediateTensorInfo(m);return p}const QV={kernelName:yn,backendName:"cpu",kernelFunc:ZV};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function eU(e){const{inputs:t,backend:n}=e,{dy:r,y:s}=t;hz([r,s],"eluGrad");const a=new Float32Array(Ie(s.shape)),i=n.data.get(s.dataId).values,o=n.data.get(r.dataId).values;for(let u=0;u<i.length;++u){const e=i[u];a[u]=e>=0?o[u]:o[u]*(e+1)}return n.makeTensorInfo(s.shape,"float32",a)}const tU={kernelName:xn,backendName:"cpu",kernelFunc:eU},nU=Kw,rU=Xw,sU=Yw,aU=Jw,iU=Zw,oU=Qw,uU=Bz(wn,(e=>{const t=Math.sign(e),n=Math.abs(e),r=1/(1+nU*n);return t*(1-((((oU*r+iU)*r+aU)*r+sU)*r+rU)*r*Math.exp(-n*n))})),lU={kernelName:wn,backendName:"cpu",kernelFunc:uU};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function cU(e){const{inputs:t,backend:n,attrs:r}=e,{input:s}=t,{dim:a}=r,i=s.shape.length,o=s.shape.slice();let u=a;return a<0&&(we(-(i+1)<=a,(()=>`Axis must be in the interval [${-(i+1)}, ${i}]`)),u=i+a+1),o.splice(u,0,1),iW({inputs:{x:s},backend:n,attrs:{shape:o}})}const hU={kernelName:In,backendName:"cpu",kernelFunc:cU},pU=yz(((e,t)=>e/t)),dU=Cz(gn,pU),fU={kernelName:gn,backendName:"cpu",kernelFunc:dU};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function mU(e,t,n){const r=e.shape,s=r[0],a=r[1],i=n.data.get(e.dataId),o=i.complexTensorInfos.real,u=i.complexTensorInfos.imag,l=[s,a],c=Ie(l),h=Me("float32",c),p=Me("float32",c);for(let g=0;g<s;g++){const e=bB({inputs:{x:o},backend:n,attrs:{begin:[g,0],size:[1,a]}}),r=bB({inputs:{x:u},backend:n,attrs:{begin:[g,0],size:[1,a]}}),s=bz({inputs:{real:e,imag:r},backend:n}),{real:i,imag:l}=gU(s,t,n),c=ev(i,l);for(let t=0;t<a;t++){const e=sv(c,t);h[g*a+t]=e.real,p[g*a+t]=e.imag}n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(s)}const d=n.makeTensorInfo(l,"float32",h),f=n.makeTensorInfo(l,"float32",p),m=bz({inputs:{real:d,imag:f},backend:n});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(f),m}function gU(e,t,n){const r=Ie(e.shape),s=n.data.get(e.dataId),a=n.data.get(s.complexTensorInfos.real.dataId).values,i=n.data.get(s.complexTensorInfos.imag.dataId).values;if(yU(r)){const s=bU(a,i,r,t,n),o=[e.shape[0],e.shape[1]];if(t){const e=n.makeTensorInfo(o,"float32",s.real),t=n.makeTensorInfo(o,"float32",s.imag),a=n.makeTensorInfo([],"float32",ga(r,"float32")),i=vz({inputs:{x:a},backend:n}),u=fU.kernelFunc({inputs:{a:e,b:a},backend:n}),l=fU.kernelFunc({inputs:{a:t,b:i},backend:n}),c=n.data.get(u.dataId).values,h=n.data.get(l.dataId).values;return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(l),{real:c,imag:h}}return s}{const e=ev(a,i),n=xU(e,r,t);return tv(n)}}function yU(e){return 0===(e&e-1)}function bU(e,t,n,r,s){if(1===n)return{real:e,imag:t};const a=ev(e,t),i=n/2,o=nv(a),u=o.real,l=o.imag,c=[u.length],h=s.makeTensorInfo(c,"float32",u),p=s.makeTensorInfo(c,"float32",l),d=bz({inputs:{real:h,imag:p},backend:s}),f=rv(a),m=f.real,g=f.imag,y=[m.length],b=s.makeTensorInfo(y,"float32",m),x=s.makeTensorInfo(y,"float32",g),w=bz({inputs:{real:b,imag:x},backend:s}),v=bU(u,l,i,r,s),k=v.real,I=v.imag,N=[k.length],S=s.makeTensorInfo(N,"float32",k),T=s.makeTensorInfo(N,"float32",I),$=bz({inputs:{real:S,imag:T},backend:s}),C=bU(m,g,i,r,s),E=C.real,R=C.imag,A=[E.length],F=s.makeTensorInfo(A,"float32",E),_=s.makeTensorInfo(A,"float32",R),D=bz({inputs:{real:F,imag:_},backend:s}),O=iv(n,r),M=[O.real.length],L=s.makeTensorInfo(M,"float32",O.real),z=s.makeTensorInfo(M,"float32",O.imag),P=bz({inputs:{real:L,imag:z},backend:s}),B=DP({inputs:{a:P,b:D},backend:s}),W=Fz({inputs:{a:$,b:B},backend:s}),V=BB({inputs:{a:$,b:B},backend:s}),U=Iz({inputs:{input:W},backend:s}),G=Iz({inputs:{input:V},backend:s}),H=oV({inputs:{input:W},backend:s}),j=oV({inputs:{input:V},backend:s}),q=lV({inputs:[U,G],backend:s,attrs:{axis:0}}),K=lV({inputs:[H,j],backend:s,attrs:{axis:0}}),X=s.data.get(q.dataId).values,Y=s.data.get(K.dataId).values;return s.disposeIntermediateTensorInfo(h),s.disposeIntermediateTensorInfo(p),s.disposeIntermediateTensorInfo(d),s.disposeIntermediateTensorInfo(b),s.disposeIntermediateTensorInfo(x),s.disposeIntermediateTensorInfo(w),s.disposeIntermediateTensorInfo(S),s.disposeIntermediateTensorInfo(T),s.disposeIntermediateTensorInfo($),s.disposeIntermediateTensorInfo(F),s.disposeIntermediateTensorInfo(_),s.disposeIntermediateTensorInfo(D),s.disposeIntermediateTensorInfo(L),s.disposeIntermediateTensorInfo(z),s.disposeIntermediateTensorInfo(P),s.disposeIntermediateTensorInfo(B),s.disposeIntermediateTensorInfo(W),s.disposeIntermediateTensorInfo(V),s.disposeIntermediateTensorInfo(U),s.disposeIntermediateTensorInfo(H),s.disposeIntermediateTensorInfo(G),s.disposeIntermediateTensorInfo(j),s.disposeIntermediateTensorInfo(q),s.disposeIntermediateTensorInfo(K),{real:X,imag:Y}}function xU(e,t,n){const r=new Float32Array(2*t);for(let s=0;s<t;s++){let a=0,i=0;for(let r=0;r<t;r++){const o=ov(s*r,t,n),u=sv(e,r);a+=u.real*o.real-u.imag*o.imag,i+=u.real*o.imag+u.imag*o.real}n&&(a/=t,i/=t),av(r,a,i,s)}return r}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function wU(e){const{inputs:t,backend:n}=e,{input:r}=t,s=Ie(r.shape),a=r.shape[r.shape.length-1],i=s/a,o=iW({inputs:{x:r},backend:n,attrs:{shape:[i,a]}}),u=mU(o,!1,n),l=iW({inputs:{x:u},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(u),l}const vU={kernelName:Sn,backendName:"cpu",kernelFunc:wU};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function kU(e){const{backend:t,attrs:n}=e,{shape:r,value:s,dtype:a}=n,i=a||je(s),o=Le(i,Ie(r));return NU(o,s,i),t.makeTensorInfo(r,i,o)}const IU={kernelName:Tn,backendName:"cpu",kernelFunc:kU};function NU(e,t,n){e.fill(t)}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const SU={kernelName:$n,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:r}=e,s=n,a=Me(r.dtype,Ie(r.shape)),[i,o,u,l]=r.shape,c=s.data.get(r.dataId).values;for(let p=0;p<i;p++){const e=p*u*o*l;for(let t=0;t<o;t++){const n=t*(u*l);for(let t=0;t<u;t++){const r=t*l;for(let s=0;s<l;s++){const i=Math.round(u-t-1),o=e+n+r+s;let h=c[o];if(i>=0&&i<u){const t=i*l,r=e+n+t+s;h=c[r]}a[o]=h}}}}const h=s.write(a,r.shape,r.dtype);return{dataId:h,shape:r.shape,dtype:r.dtype}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function TU(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:u,pad:l,dataFormat:c,dilations:h,dimRoundingMode:p,activation:d,leakyreluAlpha:f}=r;let m=hV({inputs:{x:s,filter:a},backend:n,attrs:{strides:u,pad:l,dataFormat:c,dilations:h,dimRoundingMode:p}});if(i){const e=m;if("NCHW"===c&&1===i.shape.length&&1!==i.shape[0]){const e=iW({inputs:{x:i},backend:n,attrs:{shape:[i.shape[0],1,1]}});m=Fz({inputs:{a:m,b:e},backend:n}),n.disposeIntermediateTensorInfo(e)}else m=Fz({inputs:{a:m,b:i},backend:n});n.disposeIntermediateTensorInfo(e)}if(d){const e=m;if("NCHW"===c&&"prelu"===d&&1===o.shape.length&&1!==o.shape[0]){const e=iW({inputs:{x:o},backend:n,attrs:{shape:[o.shape[0],1,1]}});m=aW(n,m,d,e,f),n.disposeIntermediateTensorInfo(e)}else m=aW(n,m,d,o,f);n.disposeIntermediateTensorInfo(e)}return m}const $U={kernelName:Os,backendName:"cpu",kernelFunc:TU};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function CU(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:u,pad:l,dataFormat:c,dilations:h,dimRoundingMode:p,activation:d,leakyreluAlpha:f}=r;let m=LV({inputs:{x:s,filter:a},backend:n,attrs:{strides:u,pad:l,dataFormat:c,dilations:h,dimRoundingMode:p}});if(i){const e=m;m=Fz({inputs:{a:m,b:i},backend:n}),n.disposeIntermediateTensorInfo(e)}if(d){const e=m;m=aW(n,m,d,o,f),n.disposeIntermediateTensorInfo(e)}return m}const EU={kernelName:Ms,backendName:"cpu",kernelFunc:CU};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function RU(e){const{inputs:t,backend:n}=e,{params:r,indices:s}=t,a=Ie(r.shape),i=s.shape,o=i[i.length-1],[u,l,c,h]=xc(r,s);if(0===l)return n.makeTensorInfo(u,r.dtype,[]);const p=n.data.get(s.dataId).values,d=n.bufferSync(r),f=oP(p,d,r.dtype,l,o,c,h,r.shape,a);return n.makeTensorInfo(u,r.dtype,f.values)}const AU={kernelName:Fn,backendName:"cpu",kernelFunc:RU};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function FU(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,indices:a}=t,{axis:i,batchDims:o}=r;hz([s,a],"gatherV2");const u=De(i,s.shape)[0],l=n.data.get(a.dataId).values,c=s.shape[u];for(let w=0;w<l.length;++w){const e=l[w];we(e<=c-1&&e>=0,(()=>`GatherV2: the index value ${e} is not in [0, ${c-1}]`))}let h=o;null==o&&(h=0);const p=Ie(a.shape),d=_v(s,a,u,h),f=iW({inputs:{x:s},backend:n,attrs:{shape:[d.batchSize,d.outerSize,d.dimSize,d.sliceSize]}}),m=iW({inputs:{x:a},backend:n,attrs:{shape:[d.batchSize,p/d.batchSize]}}),g=[d.batchSize,d.outerSize,p/d.batchSize,d.sliceSize],y=n.bufferSync(m),b=n.bufferSync(f),x=uP(b,y,g);return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.makeTensorInfo(d.outputShape,x.dtype,x.values)}const _U={kernelName:An,backendName:"cpu",kernelFunc:FU};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function DU(e){const{inputs:t,backend:n}=e,{input:r}=t,s=Ie(r.shape),a=r.shape[r.shape.length-1],i=s/a,o=iW({inputs:{x:r},backend:n,attrs:{shape:[i,a]}}),u=mU(o,!0,n),l=iW({inputs:{x:u},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(u),l}const OU={kernelName:Mn,backendName:"cpu",kernelFunc:DU},MU=Bz(zn,(e=>Number.isFinite(e)?1:0),"bool"),LU={kernelName:zn,backendName:"cpu",kernelFunc:MU},zU=Bz(Pn,(e=>Math.abs(e)===1/0?1:0),"bool"),PU={kernelName:Pn,backendName:"cpu",kernelFunc:zU},BU=Bz(Bn,(e=>Number.isNaN(e)?1:0),"bool"),WU={kernelName:Bn,backendName:"cpu",kernelFunc:BU};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function VU(e){const{backend:t,attrs:n}=e,{start:r,stop:s,num:a}=n,i=vP(r,s,a);return t.makeTensorInfo([i.length],"float32",i)}const UU={kernelName:Gn,backendName:"cpu",kernelFunc:VU},GU=Bz(jn,(e=>Math.log1p(e))),HU={kernelName:jn,backendName:"cpu",kernelFunc:GU},jU=yz(((e,t)=>e&&t)),qU=Cz(qn,jU,null,"bool"),KU={kernelName:qn,backendName:"cpu",kernelFunc:qU},XU=Bz(Kn,(e=>e?0:1),"bool"),YU={kernelName:Kn,backendName:"cpu",kernelFunc:XU},JU=yz(((e,t)=>e||t)),ZU=Cz(Xn,JU,null,"bool"),QU={kernelName:Xn,backendName:"cpu",kernelFunc:ZU};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function eG(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{depthRadius:a,bias:i,alpha:o,beta:u}=r;hz(s,"LRN");const l=s.shape[3],c=l-1,h=n.data.get(s.dataId).values,p=Ie(s.shape),d=new Float32Array(p);function f(e){const t=e%l;let n=e-t+Math.max(0,t-a);const r=e-t+Math.min(t+a,c);let s=0;for(;n<=r;n++){const e=h[n];s+=e*e}return s}for(let m=0;m<p;m++){const e=f(m),t=h[m]*Math.pow(i+o*e,-u);d[m]=t}return n.makeTensorInfo(s.shape,s.dtype,d)}const tG={kernelName:Qn,backendName:"cpu",kernelFunc:eG};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function nG(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,y:a,dy:i}=t,{depthRadius:o,bias:u,alpha:l,beta:c}=r;hz(i,"LRNGrad");const h=Ie(i.shape),p=i.shape[3],d=n.data.get(i.dataId).values,f=n.data.get(s.dataId).values,m=n.data.get(a.dataId).values,g=new Float32Array(h),y=h;for(let b=0;b<y;b++){const e=b%p,t=b-e+Math.max(0,e-o),n=b-e+Math.min(p,e+o+1);let r=0;for(let s=t;s<n;s++)r+=Math.pow(f[s],2);r=l*r+u;for(let s=t;s<n;s++){let e=-2*l*c*f[s]*m[b]/r;b===s&&(e+=Math.pow(r,-c)),e*=d[b],g[s]+=e}}return n.makeTensorInfo(i.shape,s.dtype,g)}const rG={kernelName:er,backendName:"cpu",kernelFunc:nG};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function sG(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reductionIndices:a,keepDims:i}=r,o=n;let u=s.shape;const l=u.length,c=De(a,u);let h=c;const p=Bd(h,l);let d=o.data.get(s.dataId).values;if(null!=p){const e=new Array(l);for(let t=0;t<e.length;t++)e[t]=u[p[t]];d=VP(d,u,s.dtype,p,e),h=Vd(h.length,l),u=e}hz(s,"max"),Pd("max",h,l);const[f,m]=Ld(u,h),g=Ie(m),y=SP(d,g,f,s.dtype),b=o.write(y,f,s.dtype);let x=f;if(i){const e=zd(f,c);x=e}return{dataId:b,shape:x,dtype:s.dtype}}const aG={kernelName:nr,backendName:"cpu",kernelFunc:sG};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function iG(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;hz(s,"maxPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:u}=r,l=1;we(Gh(i,l),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${l}'`));const c=Rh(s.shape,a,i,l,o,u);let h;if(1===c.filterWidth&&1===c.filterHeight&&Te(c.inShape,c.outShape))h=vz({inputs:{x:s},backend:n});else{const e=n.data.get(s.dataId).values,t=Xe(s.shape),r=LW(e,s.shape,s.dtype,t,c,"max");h=n.makeTensorInfo(c.outShape,s.dtype,r.values)}return h}const oG={kernelName:sr,backendName:"cpu",kernelFunc:iG};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function uG(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:u,dataFormat:l}=r;hz(s,"maxPool3d");const c=Ah(s.shape,a,i,1,o,u,l),h=n.data.get(s.dataId).values,p=PW(h,s.shape,s.dtype,Xe(s.shape),c,"max");return n.makeTensorInfo(p.shape,"float32",p.values)}const lG={kernelName:ir,backendName:"cpu",kernelFunc:uG};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function cG(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,{filterSize:i,strides:o,pad:u,dimRoundingMode:l}=r;hz([s,a],"maxPool3DGrad");const c=Ah(a.shape,i,o,1,u,l),h=n.bufferSync(a),p=BW(h,c),d=c.strideDepth,f=c.strideHeight,m=c.strideWidth,g=c.dilationDepth,y=c.dilationHeight,b=c.dilationWidth,x=c.effectiveFilterDepth,w=c.effectiveFilterHeight,v=c.effectiveFilterWidth,k=x-1-c.padInfo.front,I=v-1-c.padInfo.left,N=w-1-c.padInfo.top,S=qo(a.shape,"float32"),T=n.bufferSync(s);for(let $=0;$<c.batchSize;++$)for(let e=0;e<c.inChannels;++e)for(let t=0;t<c.inDepth;++t)for(let n=0;n<c.inHeight;++n)for(let r=0;r<c.inWidth;++r){const s=t-k,a=n-N,i=r-I;let o=0;for(let t=0;t<x;t+=g){const n=(s+t)/d;if(!(n<0||n>=c.outDepth||Math.floor(n)!==n))for(let r=0;r<w;r+=y){const s=(a+r)/f;if(!(s<0||s>=c.outHeight||Math.floor(s)!==s))for(let a=0;a<v;a+=b){const u=(i+a)/m;if(u<0||u>=c.outWidth||Math.floor(u)!==u)continue;const l=x*w*v-1-p.get($,n,s,u,e),h=t*w*v+r*v+a,d=l===h?1:0;if(0===d)continue;const f=T.get($,n,s,u,e);o+=f*d}}}S.set(o,$,t,n,r,e)}return n.makeTensorInfo(S.shape,S.dtype,S.values)}const hG={kernelName:or,backendName:"cpu",kernelFunc:cG};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function pG(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a,output:i}=t,o=a;hz([a,i],"maxPoolGrad");const{filterSize:u,strides:l,pad:c,dimRoundingMode:h}=r,p=Rh(o.shape,u,l,1,c,h),d=n.data.get(o.dataId).values,f=qo(p.outShape,o.dtype,zW(d,o.shape,o.dtype,p).values),m=p.strideHeight,g=p.strideWidth,y=p.dilationHeight,b=p.dilationWidth,x=p.effectiveFilterHeight,w=p.effectiveFilterWidth,v=w-1-p.padInfo.left,k=x-1-p.padInfo.top,I=qo(o.shape,"float32"),N=n.data.get(s.dataId).values,S=qo(s.shape,"float32",N);for(let T=0;T<p.batchSize;++T)for(let e=0;e<p.inChannels;++e)for(let t=0;t<p.inHeight;++t)for(let n=0;n<p.inWidth;++n){const r=t-k,s=n-v;let a=0;for(let t=0;t<x;t+=y){const n=(r+t)/m;if(!(n<0||n>=p.outHeight||Math.floor(n)!==n))for(let r=0;r<w;r+=b){const i=(s+r)/g;if(i<0||i>=p.outWidth||Math.floor(i)!==i)continue;const o=x*w-1-f.get(T,n,i,e),u=t*w+r,l=o===u?1:0;if(0===l)continue;const c=S.get(T,n,i,e);a+=c*l}}I.set(a,T,t,n,e)}return n.makeTensorInfo(I.shape,I.dtype,I.values)}const dG={kernelName:ar,backendName:"cpu",kernelFunc:pG};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function fG(e,t,n,r,s){const a=Xe(t),i=LW(e,t,n,a,s,"max"),o=zW(e,t,n,s,!0,r);return[i.values,o.values]}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const mG={kernelName:ur,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r}=e,{filterSize:s,strides:a,pad:i,includeBatchInIndex:o}=t,u=n;hz(r,"MaxPoolWithArgmax");const l=u.data.get(r.dataId).values,c=Rh(r.shape,s,a,[1,1],i),[h,p]=fG(l,r.shape,r.dtype,o,c),d=u.write(h,c.outShape,r.dtype),f=u.write(p,c.outShape,r.dtype);return[{dataId:d,shape:c.outShape,dtype:r.dtype},{dataId:f,shape:c.outShape,dtype:"int32"}]}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function gG(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=De(a,s.shape),u=Ld(s.shape,o),l=u[1],c=Ie(l),h=[],p=n.makeTensorInfo([],"float32",new Float32Array([c]));h.push(p);const d=Tz({inputs:{x:s},backend:n,attrs:{dtype:"float32"}});h.push(d);const f=dU({inputs:{a:d,b:p},backend:n});h.push(f);const m=YV({inputs:{x:f},backend:n,attrs:{axis:a,keepDims:i}});return h.forEach((e=>n.disposeIntermediateTensorInfo(e))),m}const yG={kernelName:lr,backendName:"cpu",kernelFunc:gG};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function bG(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;hz(s,"min");const o=De(a,s.shape);let u=o;const l=Bd(u,s.shape.length);let c=s;null!=l&&(c=UP({inputs:{x:s},backend:n,attrs:{perm:l}}),u=Vd(u.length,s.shape.length)),Pd("min",u,c.shape.length);const[h,p]=Ld(c.shape,u),d=Ie(p),f=et(Ie(h),c.dtype),m=n.data.get(c.dataId).values;for(let y=0;y<f.length;++y){const e=y*d;let t=m[e];for(let n=0;n<d;++n){const r=m[e+n];(Number.isNaN(r)||r<t)&&(t=r)}f[y]=t}null!=l&&n.disposeIntermediateTensorInfo(c);const g=n.makeTensorInfo(h,c.dtype,f);if(i){const e=zd(h,o),t=iW({inputs:{x:g},backend:n,attrs:{shape:e}});return n.disposeIntermediateTensorInfo(g),t}return g}const xG={kernelName:cr,backendName:"cpu",kernelFunc:bG};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function wG(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:a,mode:i}=r;hz(s,"mirrorPad");const o=a.map(((e,t)=>e[0]+s.shape[t]+e[1])),u=a.map((e=>e[0])),l=a.map(((e,t)=>e[0]+s.shape[t])),c="reflect"===i?0:1,h=n.data.get(s.dataId).values,p=s.shape.length,d=Xe(s.shape),f=Ie(o),m=o.length,g=Xe(o),y=Me(s.dtype,f);for(let x=0;x<f;x++){let e=st(x,m,g);for(let n=0;n<m;n++)e[n]<u[n]?e[n]=2*u[n]-e[n]-c:e[n]>=l[n]&&(e[n]=2*(l[n]-1)-e[n]+c);e=e.map(((e,t)=>e-u[t]));const t=rt(e,p,d);y[x]=h[t]}const b=n.write(y,o,s.dtype);return{dataId:b,shape:o,dtype:s.dtype}}const vG={kernelName:pr,backendName:"cpu",kernelFunc:wG},kG=yz(((e,t)=>{const n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t})),IG=Cz(dr,kG),NG={kernelName:dr,backendName:"cpu",kernelFunc:IG};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function SG(e){const{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{dim:a}=r,i=s.shape.length;let o=a;if(-1===o&&(o=i-1),o!==i-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${o}`);const u=De([o],s.shape),l=sG({inputs:{x:s},backend:n,attrs:{reductionIndices:u,keepDims:!1}}),c=zd(l.shape,u),h=iW({inputs:{x:l},backend:n,attrs:{shape:c}}),p=BB({inputs:{a:s,b:h},backend:n}),d=Yz({inputs:{x:p},backend:n}),f=YV({inputs:{x:d},backend:n,attrs:{axis:u,keepDims:!1}}),m=iW({inputs:{x:f},backend:n,attrs:{shape:c}}),g=dU({inputs:{a:d,b:m},backend:n});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}const TG={kernelName:is,backendName:"cpu",kernelFunc:SG};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function $G(e){const{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{numSamples:a,seed:i,normalized:o}=r;hz(s,"multinomial");const u=o?s:SG({inputs:{logits:s},backend:n,attrs:{dim:-1}}),l=u.shape[0],c=u.shape[1],h=n.data.get(u.dataId).values,p=[l,a],d=et(Ie(p),"int32");for(let f=0;f<l;++f){const e=f*c,t=new Float32Array(c-1);t[0]=h[e];for(let s=1;s<t.length;++s)t[s]=t[s-1]+h[e+s];const n=og.alea(i.toString()),r=f*a;for(let s=0;s<a;++s){const e=n();d[r+s]=t.length;for(let n=0;n<t.length;n++)if(e<t[n]){d[r+s]=n;break}}}return o||n.disposeIntermediateTensorInfo(u),n.makeTensorInfo(p,"int32",d)}const CG={kernelName:fr,backendName:"cpu",kernelFunc:$G},EG=ax;function RG(e){const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:u}=r;hz(s,"NonMaxSuppression");const l=n.data.get(s.dataId).values,c=n.data.get(a.dataId).values,{selectedIndices:h}=EG(l,c,i,o,u);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}const AG={kernelName:br,backendName:"cpu",kernelFunc:RG},FG=ix;function _G(e){const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:u,padToMaxOutputSize:l}=r;hz(s,"NonMaxSuppressionPadded");const c=n.data.get(s.dataId).values,h=n.data.get(a.dataId).values,{selectedIndices:p,validOutputs:d}=FG(c,h,i,o,u,l);return[n.makeTensorInfo([p.length],"int32",new Int32Array(p)),n.makeTensorInfo([],"int32",new Int32Array([d]))]}const DG={kernelName:xr,backendName:"cpu",kernelFunc:_G},OG=ox;function MG(e){const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:u,softNmsSigma:l}=r;hz(s,"NonMaxSuppressionWithScore");const c=n.data.get(s.dataId).values,h=n.data.get(a.dataId).values,p=i,d=o,f=u,m=l,{selectedIndices:g,selectedScores:y}=OG(c,h,p,d,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}const LG={kernelName:wr,backendName:"cpu",kernelFunc:MG};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function zG(e){const{inputs:t,backend:n,attrs:r}=e,{indices:s}=t,{dtype:a,depth:i,onValue:o,offValue:u}=r;hz(s,"oneHot");const l=Ie(s.shape),c=new Float32Array(l*i);c.fill(u);const h=n.data.get(s.dataId).values;for(let p=0;p<l;++p)h[p]>=0&&h[p]<i&&(c[p*i+h[p]]=o);return n.makeTensorInfo([...s.shape,i],a,c)}const PG={kernelName:kr,backendName:"cpu",kernelFunc:zG};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function BG(e){const{inputs:t,backend:n}=e,{x:r}=t;if("string"===r.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===r.dtype){const e=Iz({inputs:{input:r},backend:n}),t=BG({inputs:{x:e},backend:n}),s=oV({inputs:{input:r},backend:n}),a=BG({inputs:{x:s},backend:n}),i=bz({inputs:{real:t,imag:a},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),i}return kU({backend:n,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}const WG={kernelName:Rs,backendName:"cpu",kernelFunc:BG};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function VG(e){const{inputs:t,backend:n}=e,{x:r}=t;if("string"===r.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===r.dtype){const e=Iz({inputs:{input:r},backend:n}),t=VG({inputs:{x:e},backend:n}),s=oV({inputs:{input:r},backend:n}),a=BG({inputs:{x:s},backend:n}),i=bz({inputs:{real:t,imag:a},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),i}return kU({backend:n,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}const UG={kernelName:vr,backendName:"cpu",kernelFunc:VG};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function GG(e){const{inputs:t,backend:n,attrs:r}=e,{axis:s}=r;if(1===t.length)return cU({inputs:{input:t[0]},backend:n,attrs:{dim:s}});const a=t[0].shape,i=t[0].dtype;t.forEach((e=>{ve(a,e.shape,"All tensors passed to stack must have matching shapes"),we(i===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const o=[],u=t.map((e=>{const t=cU({inputs:{input:e},backend:n,attrs:{dim:s}});return o.push(t),t})),l=lV({inputs:u,backend:n,attrs:{axis:s}});return o.forEach((e=>n.disposeIntermediateTensorInfo(e))),l}const HG={kernelName:Ir,backendName:"cpu",kernelFunc:GG};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function jG(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:a,constantValue:i}=r;hz(s,"pad");const o=a.map(((e,t)=>e[0]+s.shape[t]+e[1])),u=a.map((e=>e[0])),l=n.data.get(s.dataId).values,c=Ie(s.shape),h=s.shape.length,p=Xe(s.shape),d=Ie(o),f=o.length,m=Xe(o),g=Me(s.dtype,d);0!==i&&g.fill(i);for(let b=0;b<c;b++){const e=st(b,h,p),t=e.map(((e,t)=>e+u[t])),n=rt(t,f,m);g[n]=l[b]}const y=n.write(g,o,s.dtype);return{dataId:y,shape:o,dtype:s.dtype}}const qG={kernelName:Nr,backendName:"cpu",kernelFunc:jG},KG=yz(((e,t)=>Math.pow(e,t))),XG=Cz(Tr,KG),YG={kernelName:Tr,backendName:"cpu",kernelFunc:XG};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function JG(e){const{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:s,paramsDenseValues:a,indices:i}=t,{outputRaggedRank:o}=r,u=s.map((e=>n.data.get(e.dataId).values)),l=s.map((e=>e.shape)),c=n.data.get(a.dataId).values,h=n.data.get(i.dataId).values,[p,d,f]=tB(u,l,c,a.shape,a.dtype,h,i.shape,o),m=p.map((e=>n.makeTensorInfo([e.length],"int32",e))),g=n.makeTensorInfo(f,a.dtype,d);return m.concat([g])}const ZG={kernelName:Er,backendName:"cpu",kernelFunc:JG};
/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function QG(e){const{inputs:t,backend:n}=e,{starts:r,limits:s,deltas:a}=t,i=n.data.get(r.dataId).values,o=n.data.get(s.dataId).values,u=n.data.get(a.dataId).values,[l,c]=rB(i,r.shape,r.dtype,o,s.shape,u,a.shape),h=n.makeTensorInfo([l.length],"int32",l),p=n.makeTensorInfo([c.length],r.dtype,c);return[h,p]}const eH={kernelName:Rr,backendName:"cpu",kernelFunc:QG};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function tH(e){const{inputs:t,backend:n,attrs:r}=e,{shape:s,values:a,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:u}=r,l=n.data.get(s.dataId).values,c=n.data.get(a.dataId).values,h=n.data.get(i.dataId).values,p=o.map((e=>n.data.get(e.dataId).values)),d=o.map((e=>e.shape)),[f,m]=uB(l,s.shape,c,a.shape,a.dtype,h,i.shape,p,d,u);return n.makeTensorInfo(f,a.dtype,m)}const nH={kernelName:Ar,backendName:"cpu",kernelFunc:tH};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function rH(e){const{backend:t,attrs:n}=e,{start:r,stop:s,dtype:a,step:i}=n,o=lB(r,s,i,a);return t.makeTensorInfo([o.length],a,o)}const sH={kernelName:Fr,backendName:"cpu",kernelFunc:rH},aH=Bz(Dr,(e=>1/e)),iH={kernelName:Dr,backendName:"cpu",kernelFunc:aH};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function oH(e){const{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:i,size:o}=r;hz(s,"resizeBilinear");const u=Xe(s.shape),[l,c]=o,[h,p,d,f]=s.shape,m=n.data.get(s.dataId).values,g=new Float32Array(Ie([h,l,c,f])),y=[a&&l>1?p-1:p,a&&c>1?d-1:d],b=[a&&l>1?l-1:l,a&&c>1?c-1:c];let x=0;const w=y[0]/b[0],v=y[1]/b[1];for(let k=0;k<h;k++)for(let e=0;e<l;e++){let t;t=i?w*(e+.5)-.5:w*e;const n=Math.max(0,Math.floor(t)),r=t-n,s=Math.min(p-1,Math.ceil(t)),a=k*u[0]+n*u[1],o=k*u[0]+s*u[1];for(let e=0;e<c;e++){let t;t=i?v*(e+.5)-.5:v*e;const n=Math.max(0,Math.floor(t)),s=t-n,l=Math.min(d-1,Math.ceil(t)),c=a+n*u[2],h=o+n*u[2],p=a+l*u[2],y=o+l*u[2];for(let e=0;e<f;e++){const t=m[c+e],n=m[h+e],a=m[p+e],i=m[y+e],o=t+(a-t)*s,u=n+(i-n)*s,l=o+(u-o)*r;g[x++]=l}}}return n.makeTensorInfo([h,l,c,f],"float32",g)}const uH={kernelName:Pr,backendName:"cpu",kernelFunc:oH};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function lH(e){const{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r;hz([a,s],"resizeBilinearGrad");const o=Xe(s.shape),[u,l,c,h]=s.shape,[,p,d]=a.shape,f=new Float32Array(u*l*c*h),m=[i&&p>1?l-1:l,i&&d>1?c-1:c],g=[i&&p>1?p-1:p,i&&d>1?d-1:d],y=m[0]/g[0],b=m[1]/g[1],x=n.data.get(a.dataId).values;let w=0;for(let v=0;v<u;v++){const e=v*o[0];for(let t=0;t<p;t++){const n=t*y,r=Math.floor(n),s=Math.min(Math.ceil(n),l-1),a=e+r*o[1],i=e+s*o[1],u=n-r,p=1-u;for(let e=0;e<d;e++){const t=e*b,n=Math.floor(t),r=Math.min(Math.ceil(t),c-1),s=t-n,l=1-s,d=a+n*o[2],m=a+r*o[2],g=i+n*o[2],y=i+r*o[2],v=p*l,k=p*s,I=u*l,N=u*s;for(let e=0;e<h;e++){const t=x[w++];f[d+e]+=t*v,f[m+e]+=t*k,f[g+e]+=t*I,f[y+e]+=t*N}}}}return n.makeTensorInfo([u,c,l,h],"float32",f)}const cH={kernelName:Br,backendName:"cpu",kernelFunc:lH};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function hH(e){const{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:i,size:o}=r;hz(s,"resizeNearestNeighbor");const u=Xe(s.shape),[l,c]=o,[h,p,d,f]=s.shape,m=n.data.get(s.dataId).values,g=new Float32Array(h*l*c*f),y=[a&&l>1?p-1:p,a&&c>1?d-1:d],b=[a&&l>1?l-1:l,a&&c>1?c-1:c],x=y[0]/b[0],w=y[1]/b[1];let v=0;for(let k=0;k<h;k++){const e=k*u[0];for(let t=0;t<l;t++){const n=i?x*(t+.5):x*t;let r=Math.min(p-1,a?Math.round(n):Math.floor(n));i&&(r=Math.max(0,r));const s=e+r*u[1];for(let e=0;e<c;e++){const t=i?w*(e+.5):w*e;let n=Math.min(d-1,a?Math.round(t):Math.floor(t));i&&(n=Math.max(0,n));const r=s+n*u[2];for(let e=0;e<f;e++){const t=m[r+e];g[v++]=t}}}}return n.makeTensorInfo([h,l,c,f],s.dtype,g)}const pH={kernelName:Lr,backendName:"cpu",kernelFunc:hH};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function dH(e){const{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r;hz([a,s],"resizeNearestNeighborGrad");const o=Xe(s.shape),u=Xe(a.shape),[l,c,h,p]=s.shape,[,d,f]=a.shape,m=new Float32Array(l*c*h*p),g=n.data.get(a.dataId).values,y=[i&&d>1?c-1:c,i&&f>1?h-1:h],b=[i&&d>1?d-1:d,i&&f>1?f-1:f],x=y[0]/b[0],w=y[1]/b[1],v=1/x,k=1/w,I=2*Math.ceil(v)+2,N=2*Math.ceil(k)+2;for(let S=0;S<l;S++){const e=S*o[0];for(let t=0;t<c;t++){const n=e+t*o[1],r=Math.floor(t*v),s=Math.floor(r-I/2);for(let a=0;a<h;a++){const r=n+a*o[2],l=Math.floor(a*k),y=Math.floor(l-N/2);for(let n=0;n<p;n++){let o=0;for(let r=0;r<I;r++){const l=r+s;if(l<0||l>=d)continue;const p=e+l*u[1],m=l*x,b=Math.min(c-1,i?Math.round(m):Math.floor(m));if(t===b)for(let e=0;e<N;e++){const t=e+y;if(t<0||t>=f)continue;const r=p+t*u[2],s=t*w,l=Math.min(h-1,i?Math.round(s):Math.floor(s));a===l&&(o+=g[r+n])}}m[r+n]=o}}}}return n.makeTensorInfo(s.shape,s.dtype,m)}const fH={kernelName:zr,backendName:"cpu",kernelFunc:dH};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function mH(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dims:a}=r;hz(s,"reverse");const i=s.shape.length,o=De(a,s.shape);if(0===i)return vz({inputs:{x:s},backend:n});const u=new Pa(s.shape,s.dtype),l=n.bufferSync(s);for(let c=0;c<u.size;c++){const e=u.indexToLoc(c),t=e.slice();o.forEach((e=>t[e]=s.shape[e]-1-t[e])),u.set(l.get(...t),...e)}return n.makeTensorInfo(u.shape,u.dtype,u.values)}const gH={kernelName:Vr,backendName:"cpu",kernelFunc:mH},yH={kernelName:_s,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:r}=e,{radians:s,fillValue:a,center:i}=t,o=n,u=Me(r.dtype,Ie(r.shape)),[l,c,h,p]=r.shape,[d,f]=Bw(i,c,h),m=255,g=Math.sin(s),y=Math.cos(s),b=o.data.get(r.dataId).values;for(let w=0;w<l;w++){const e=w*h*c*p;for(let t=0;t<c;t++){const n=t*(h*p);for(let r=0;r<h;r++){const s=r*p;for(let i=0;i<p;i++){const o=[l,t,r,i],x=o[2],w=o[1];let v=(x-d)*y-(w-f)*g,k=(x-d)*g+(w-f)*y;v=Math.round(v+d),k=Math.round(k+f);let I=a;if("number"!==typeof a&&(I=3===i?m:a[i]),v>=0&&v<h&&k>=0&&k<c){const t=k*(h*p),n=v*p,r=e+t+n+i;I=b[r]}const N=e+n+s+i;u[N]=I}}}}const x=o.write(u,r.shape,r.dtype);return{dataId:x,shape:r.shape,dtype:r.dtype}}},bH=Bz(Ur,(e=>{const t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2===0?t:t+1})),xH={kernelName:Ur,backendName:"cpu",kernelFunc:bH};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function wH(e){const{inputs:t,backend:n,attrs:r}=e,{indices:s,updates:a}=t,{shape:i}=r,{sliceRank:o,numUpdates:u,sliceSize:l,strides:c,outputSize:h}=kc(a,s,i),p=!0,d=n.bufferSync(s),f=n.bufferSync(a),m=dB(d,f,i,h,l,u,o,c,0,p);return n.makeTensorInfo(i,m.dtype,m.values)}const vH={kernelName:Hr,backendName:"cpu",kernelFunc:wH};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function kH(e,t){let n=0,r=e.length,s=0;while(n<r)s=Math.floor((n+r)/2),e[s]<t?n=s+1:r=s;return r}function IH(e,t){let n=0,r=e.length,s=0;while(n<r)s=Math.floor((n+r)/2),e[s]<=t?n=s+1:r=s;return r}function NH(e,t,n,r,s,a){const i=Le("int32",n*s);for(let o=0;o<n;++o){const n=e.slice(o*r,(o+1)*r),u=o*s;for(let e=0;e<s;++e)i[u+e]="left"===a?kH(n,t[e+u]):IH(n,t[e+u])}return i}
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function SH(e){const{inputs:t,backend:n,attrs:r}=e,{sortedSequence:s,values:a}=t,{side:i}=r,o=n.data.get(s.dataId).values,u=n.data.get(a.dataId).values,l=NH(o,u,s.shape[0],s.shape[1],a.shape[1],i);return n.makeTensorInfo(a.shape,"int32",l)}const TH={kernelName:qr,backendName:"cpu",kernelFunc:SH};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function $H(e){const{inputs:t,backend:n}=e,{condition:r,t:s,e:a}=t;hz([r,s,a],"select");const i=r.shape.length,o=n.data.get(r.dataId).values,u=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values,c=ti(s.dtype,a.dtype),h=et(Ie(s.shape),c);let p=0;const d=0===i||i>1||1===s.shape.length?1:Ie(s.shape.slice(1));for(let f=0;f<o.length;f++)for(let e=0;e<d;e++)1===o[f]?h[p++]=u[f]:h[p++]=l[f];return n.makeTensorInfo(s.shape,c,h)}const CH={kernelName:Kr,backendName:"cpu",kernelFunc:$H},EH=jw,RH=qw,AH=Bz(Xr,(e=>e>=0?RH*e:EH*(Math.exp(e)-1))),FH={kernelName:Xr,backendName:"cpu",kernelFunc:AH},_H=Bz(Qr,(e=>e<0?-1:e>0?1:0)),DH={kernelName:Qr,backendName:"cpu",kernelFunc:_H},OH=Bz(Jr,(e=>Math.sin(e))),MH={kernelName:Jr,backendName:"cpu",kernelFunc:OH},LH=Bz(Zr,(e=>Math.sinh(e))),zH={kernelName:Zr,backendName:"cpu",kernelFunc:LH},PH=1.1920928955078125e-7,BH=Math.log(PH)+2,WH=Bz(ts,(e=>{const t=e>-BH,n=e<BH,r=Math.exp(e);let s;return s=n?r:t?e:Math.log(1+r),s})),VH={kernelName:ts,backendName:"cpu",kernelFunc:WH};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function UH(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,paddings:i}=r;hz([s],"spaceToBatchND");const o=Ie(a),u=[[0,0]];u.push(...i);for(let k=1+a.length;k<s.shape.length;++k)u.push([0,0]);const l=qG.kernelFunc({inputs:{x:s},backend:n,attrs:{paddings:u,constantValue:0}}),c=Ww(l.shape,a,o,!1),h=Vw(c.length,a.length,!1),p=Uw(l.shape,a,o,!1),d={x:l},f={shape:c},m=iW({inputs:d,backend:n,attrs:f}),g={x:m},y={perm:h},b=UP({inputs:g,backend:n,attrs:y}),x={x:b},w={shape:p},v=iW({inputs:x,backend:n,attrs:w});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(b),v}const GH={kernelName:ss,backendName:"cpu",kernelFunc:UH};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function HH(e){const{inputs:t,backend:n}=e,{indices:r,values:s,denseShape:a,defaultValue:i}=t;if(1!==a.shape.length)throw new Error(`Dense shape must be a vector, saw:\n        ${a.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n        ${r.shape}`);if(1!==s.shape.length)throw new Error(`Values must be a vector, saw:\n        ${s.shape}`);if(0!==i.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${i.shape}`);const o=n.data.get(r.dataId).values,u=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values,c=n.data.get(i.dataId).values[0],[h,p,d,f,m]=wB(o,r.shape,r.dtype,u,s.dtype,l,c);return[n.makeTensorInfo(p,r.dtype,h),n.makeTensorInfo([p[0]],s.dtype,d),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((e=>Number(e))))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}const jH={kernelName:os,backendName:"cpu",kernelFunc:HH};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function qH(e){const{inputs:t,backend:n}=e,{inputIndices:r,inputShape:s,newShape:a}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${r.shape}`);if(1!==s.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${s.shape}`);if(1!==a.shape.length)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);const i=Array.from(n.data.get(s.dataId).values),o=n.data.get(r.dataId).values,u=Array.from(n.data.get(a.dataId).values),[l,c,h]=vB(o,r.shape,r.dtype,i,u);return[n.makeTensorInfo(c,r.dtype,l),n.makeTensorInfo([h.length],a.dtype,new Int32Array(h))]}const KH={kernelName:us,backendName:"cpu",kernelFunc:qH};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function XH(e){const{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n          ${s.shape}`);if(1!==a.shape.length)throw new Error(`Segment ids should be a vector but received shape\n          ${a.shape}`);if(s.shape[0]!==a.shape[0])throw new Error("segmentIds and indices should have same size.");const i=n.data.get(r.dataId).values,o=n.data.get(s.dataId).values,u=n.data.get(a.dataId).values,[l,c]=kB(i,r.shape,r.dtype,o,u,!0);return n.makeTensorInfo(c,r.dtype,l)}const YH={kernelName:ls,backendName:"cpu",kernelFunc:XH};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function JH(e){const{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n         ${s.shape}`);if(1!==a.shape.length)throw new Error(`Segment ids should be a vector but received shape\n         ${a.shape}`);if(s.shape[0]!==a.shape[0])throw new Error("segmentIds and indices should have same size.");const i=n.data.get(r.dataId).values,o=n.data.get(s.dataId).values,u=n.data.get(a.dataId).values,[l,c]=kB(i,r.shape,r.dtype,o,u);return n.makeTensorInfo(c,r.dtype,l)}const ZH={kernelName:cs,backendName:"cpu",kernelFunc:JH};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function QH(e){const{inputs:t,backend:n,attrs:r}=e,{sparseIndices:s,sparseValues:a,defaultValue:i}=t,{outputShape:o}=r,{sliceRank:u,numUpdates:l,sliceSize:c,strides:h,outputSize:p}=kc(a,s,o),d=!1,f=n.bufferSync(s);let m;switch(a.dtype){case"bool":{const e=n.bufferSync(a),t=Boolean(n.data.get(i.dataId).values[0]);m=dB(f,e,o,p,c,l,u,h,t,d);break}case"float32":{const e=n.bufferSync(a),t=n.data.get(i.dataId).values[0];m=dB(f,e,o,p,c,l,u,h,t,d);break}case"int32":{const e=n.bufferSync(a),t=n.data.get(i.dataId).values[0];m=dB(f,e,o,p,c,l,u,h,t,d);break}case"string":{const e=n.bufferSync(a),t=ka(n.data.get(i.dataId).values[0]);m=dB(f,e,o,p,c,l,u,h,t,d);break}default:throw new Error(`Unsupported type ${a.dtype}`)}return n.makeTensorInfo(o,m.dtype,m.values)}const ej={kernelName:hs,backendName:"cpu",kernelFunc:QH};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function tj(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{numOrSizeSplits:a,axis:i}=r,o=De(i,s.shape)[0],u=bv(s,a,o),l=new Array(s.shape.length).fill(0),c=s.shape.slice();return u.map((e=>{const t=[...c];t[o]=e;const r=bB({inputs:{x:s},backend:n,attrs:{begin:l,size:t}});return l[o]+=e,r}))}const nj={kernelName:as,backendName:"cpu",kernelFunc:tj},rj={kernelName:ds,backendName:"cpu",kernelFunc:({inputs:e,backend:t})=>{const{x:n}=e,r=t;hz(n,"square");const s=r.data.get(n.dataId).values,a=new Float32Array(s.length);for(let o=0;o<s.length;++o){const e=s[o];a[o]=e*e}const i=r.write(a,n.shape,n.dtype);return{dataId:i,shape:n.shape,dtype:n.dtype}}},sj=Bz(As,((e,t)=>{const n=t;return isNaN(e)?NaN:e>0?1:n.alpha})),aj={kernelName:As,backendName:"cpu",kernelFunc:sj};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ij(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,end:i,strides:o,beginMask:u,endMask:l,ellipsisMask:c,newAxisMask:h,shrinkAxisMask:p}=r;hz(s,"stridedSlice");const{finalShapeSparse:d,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:b,end:x,strides:w}=Bc(s.shape,a,i,o,u,l,c,h,p);let v;if(m)v=iW({inputs:{x:s},backend:n,attrs:{shape:f}});else if(g||y){we(s.shape.length>=1,(()=>`Input must have rank at least 1, got: ${s.shape.length}`));const e=$c(b,x,w),t=bB({inputs:{x:s},backend:n,attrs:{begin:b,size:e}});v=iW({inputs:{x:t},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(t)}else{const e=n.bufferSync(s),t=FB(d,e,w,b);v=n.makeTensorInfo(f,t.dtype,t.values)}return v}const oj={kernelName:ms,backendName:"cpu",kernelFunc:ij};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function uj(e){const{inputs:t,backend:n,attrs:r}=e,{separator:s,nGramWidths:a,leftPad:i,rightPad:o,padWidth:u,preserveShortSequences:l}=r,{data:c,dataSplits:h}=t,p=n.data.get(c.dataId).values,d=n.data.get(h.dataId).values,[f,m]=DB(p,d,s,a,i,o,u,l);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(h.shape,"int32",m)]}const lj={kernelName:gs,backendName:"cpu",kernelFunc:uj};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function cj(e){const{inputs:t,backend:n,attrs:r}=e,{skipEmpty:s}=r,{input:a,delimiter:i}=t;if("string"!==a.dtype)throw new Error("Input must be of datatype string");if(1!==a.shape.length)throw new Error(`Input must be a vector, got shape: ${a.shape}`);if(0!==i.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const o=n.data.get(a.dataId).values,u=n.data.get(i.dataId).values[0],[l,c,h]=MB(o,u,s),p=c.length;return[n.makeTensorInfo([p,2],"int32",l),n.makeTensorInfo([p],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(h))]}const hj={kernelName:ys,backendName:"cpu",kernelFunc:cj};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function pj(e){const{inputs:t,backend:n,attrs:r}=e,{numBuckets:s}=r,{input:a}=t;if("string"!==a.dtype)throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const i=n.data.get(a.dataId).values,o=LB(i,s);return n.makeTensorInfo(a.shape,"int32",o)}const dj={kernelName:bs,backendName:"cpu",kernelFunc:pj},fj=Bz(ws,(e=>Math.tan(e))),mj={kernelName:ws,backendName:"cpu",kernelFunc:fj},gj=Bz(vs,(e=>Math.tanh(e))),yj={kernelName:vs,backendName:"cpu",kernelFunc:gj};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function bj(e){const{inputs:t,backend:n}=e,{tensor:r,indices:s,updates:a}=t,{sliceRank:i,numUpdates:o,sliceSize:u,strides:l,outputSize:c}=kc(a,s,r.shape),h=!1,p=n.bufferSync(s),d=n.bufferSync(a),f=n.bufferSync(r),m=dB(p,d,r.shape,c,u,o,i,l,f,h);return n.makeTensorInfo(r.shape,m.dtype,m.values)}const xj={kernelName:jr,backendName:"cpu",kernelFunc:bj};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function wj(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reps:a}=r;hz(s,"tile");const i=VB(n.bufferSync(s),a);return n.makeTensorInfo(i.shape,i.dtype,i.values)}const vj={kernelName:ks,backendName:"cpu",kernelFunc:wj};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function kj(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{k:a,sorted:i}=r;hz(s,"topk");const o=n.data.get(s.dataId).values,[u,l]=HB(o,s.shape,s.dtype,a,i);return[n.makeTensorInfo(u.shape,u.dtype,u.values),n.makeTensorInfo(l.shape,l.dtype,l.values)]}const Ij={kernelName:Is,backendName:"cpu",kernelFunc:kj};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Nj(e){const{inputs:t,attrs:n,backend:r}=e,{image:s,transforms:a}=t,{interpolation:i,fillMode:o,fillValue:u,outputShape:l}=n,[c,h,p,d]=s.shape,[f,m]=null!=l?l:[h,p],g=[c,f,m,d],y=Xe(s.shape),b=y[0],x=y[1],w=y[2],v=Xe(g),k=v[0],I=v[1],N=v[2],S=Me(s.dtype,Ie(g));S.fill(u);const T=r.data.get(s.dataId).values,$=r.data.get(a.dataId).values;for(let E=0;E<c;++E){const e=1===a.shape[0]?$:$.subarray(8*E,8*E+8);for(let t=0;t<f;++t)for(let n=0;n<m;++n)for(let r=0;r<d;++r){let s;const a=e[6]*n+e[7]*t+1;if(0===a)continue;const l=(e[0]*n+e[1]*t+e[2])/a,c=(e[3]*n+e[4]*t+e[5])/a,d=Tj(l,p,o),f=Tj(c,h,o);switch(i){case"nearest":s=Fj(T,h,p,b,x,w,E,f,d,r,u);break;case"bilinear":s=_j(T,h,p,b,x,w,E,f,d,r,u);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`)}const m=E*k+t*I+n*N+r;S[m]=s}return r.makeTensorInfo(g,s.dtype,S)}const C=r.write(S,g,s.dtype);return{dataId:C,shape:s.shape,dtype:s.dtype}}const Sj={kernelName:Ns,backendName:"cpu",kernelFunc:Nj};function Tj(e,t,n){switch(n){case"reflect":return $j(e,t);case"wrap":return Cj(e,t);case"nearest":return Rj(e,t);case"constant":default:return Ej(e,t)}}function $j(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const e=2*t;n<e&&(n=e*Math.trunc(-n/e)+n),n=n<-t?n+e:-n-1}else if(n>t-1)if(t<=1)n=0;else{const e=2*t;n-=e*Math.trunc(n/e),n>=t&&(n=e-n-1)}return fe(0,n,t-1)}function Cj(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const e=t-1;n+=t*(Math.trunc(-n/e)+1)}else if(n>t-1)if(t<=1)n=0;else{const e=t-1;n-=t*Math.trunc(n/e)}return fe(0,n,t-1)}function Ej(e,t){return e}function Rj(e,t){return fe(0,e,t-1)}function Aj(e,t,n,r,s,a,i,o,u,l,c){const h=i*r+o*s+u*a+l;return 0<=o&&o<t&&0<=u&&u<n?e[h]:c}function Fj(e,t,n,r,s,a,i,o,u,l,c){const h=Math.round(o),p=Math.round(u);return Aj(e,t,n,r,s,a,i,h,p,l,c)}function _j(e,t,n,r,s,a,i,o,u,l,c){const h=Math.floor(o),p=Math.floor(u),d=h+1,f=p+1,m=(f-u)*Aj(e,t,n,r,s,a,i,h,p,l,c)+(u-p)*Aj(e,t,n,r,s,a,i,h,f,l,c),g=(f-u)*Aj(e,t,n,r,s,a,i,d,p,l,c)+(u-p)*Aj(e,t,n,r,s,a,i,d,f,l,c);return(d-o)*m+(o-h)*g}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Dj(e){const{inputs:t,attrs:n,backend:r}=e,{axis:s}=n,{x:a}=t;hz(a,"unique");const i=r.data.get(a.dataId).values,{outputValues:o,outputShape:u,indices:l}=jB(i,s,a.shape,a.dtype);return[r.makeTensorInfo(u,a.dtype,o),r.makeTensorInfo([l.length],"int32",l)]}const Oj={kernelName:Ts,backendName:"cpu",kernelFunc:Dj};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Mj(e){const{inputs:t,backend:n,attrs:r}=e,{value:s}=t;let{axis:a}=r;a<0&&(a+=s.shape.length);const i=s.shape.length,o=s.shape[a],u=new Array(i-1);let l=0;for(let d=0;d<i;d++)d!==a&&(u[l++]=s.shape[d]);const c=new Array(i).fill(0),h=s.shape.slice();h[a]=1;const p=new Array(o);for(let d=0;d<p.length;d++){c[a]=d;const e=bB({inputs:{x:s},backend:n,attrs:{begin:c,size:h}});p[d]=iW({inputs:{x:e},backend:n,attrs:{shape:u}}),n.disposeIntermediateTensorInfo(e)}return p}const Lj={kernelName:$s,backendName:"cpu",kernelFunc:Mj};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function zj(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,segmentIds:a}=t,{numSegments:i}=r;hz(s,"unsortedSegmentSum");const o=s.shape.length,u=a.shape.length,l=[],c=[],h=o-u;let p=a;for(let f=0;f<h;++f){const e=cU({inputs:{input:p},backend:n,attrs:{dim:f+1}});p=e,c.push(e)}for(let f=0;f<i;++f){const e=ga(f,"int32"),t=n.makeTensorInfo([],"int32",e),r=qz({inputs:{a:t,b:p},backend:n}),a=Tz({inputs:{x:r},backend:n,attrs:{dtype:"float32"}}),i=DP({inputs:{a:a,b:s},backend:n}),o=YV({inputs:{x:i},backend:n,attrs:{axis:0,keepDims:!1}});l.push(o),c.push(t),c.push(r),c.push(a),c.push(i),c.push(o)}const d=GG({inputs:l,backend:n,attrs:{axis:0}});return c.forEach((e=>n.disposeIntermediateTensorInfo(e))),d}const Pj={kernelName:Cs,backendName:"cpu",kernelFunc:zj},Bj=[hW,gz,dW,mW,_z,yW,xW,vW,IW,SW,$W,EW,AW,DW,MW,VW,GW,jW,KW,lW,YW,ZW,eV,zz,nV,$z,Gz,sV,xz,iV,cV,pV,fV,gV,bV,wV,kV,NV,TV,CV,RV,FV,DV,MV,zV,BV,VV,GV,HV,jV,qV,XV,QV,XB,tU,Kz,lU,Jz,hU,eP,vU,IU,SU,rP,iP,$U,EU,AU,_U,hP,fP,kz,OU,uV,LU,PU,WU,JB,yP,wP,UU,NP,HU,KU,YU,QU,tG,rG,aG,CP,oG,lG,hG,dG,mG,yG,xG,AP,vG,NG,CG,OP,zP,AG,DG,LG,WP,PG,UG,HG,qG,YG,eW,qP,ZG,eH,nH,sH,Nz,fU,iH,nW,sW,oW,uH,cH,pH,fH,gH,yH,xH,pB,vH,TH,CH,FH,gB,DH,MH,zH,xB,TG,VH,GH,jH,KH,YH,ZH,ej,nj,SB,rj,CB,AB,aj,oj,lj,hj,dj,WB,JV,mj,yj,xj,vj,Ij,Sj,GP,Oj,Lj,Pj,WG];for(const c7 of Bj)Gs(c7);
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Wj={},Vj={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function Uj(e,t){Wj[e]=t}function Gj(e,t){if(!(e in Wj)||null!=t){const n=jj(e,t);if(null===n)return console.log("Could not get context for WebGL version",e),null;Wj[e]=n}const n=Wj[e];return null==n||n.isContextLost()?(delete Wj[e],Gj(e)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),Wj[e])}function Hj(e){if(ht().getBool("IS_SAFARI")||"undefined"===typeof OffscreenCanvas||2!==e){if("undefined"!==typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}return new OffscreenCanvas(300,150)}function jj(e,t){if(1!==e&&2!==e)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const n=null==t?Hj(e):t;return n.addEventListener("webglcontextlost",(t=>{t.preventDefault(),delete Wj[e]}),!1),ht().getBool("SOFTWARE_WEBGL_ENABLED")&&(Vj.failIfMajorPerformanceCaveat=!1),1===e?n.getContext("webgl",Vj)||n.getContext("experimental-webgl",Vj):n.getContext("webgl2",Vj)}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var qj,Kj,Xj;function Yj(e,t){return[t,e]}function Jj(e,t){return e*t}function Zj(e){const t=Ie(e),n=Math.ceil(t/4);return Ee(n)}function Qj(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function eq(e,t){const[n,r]=Qj(e,t);return n*r*4}function tq(e,t){const n=e;let r,s,a,i,o,u,l,c,h,p;return 2===ht().getNumber("WEBGL_VERSION")?(r=n.R32F,s=n.R16F,a=n.RGBA16F,i=n.RGBA32F,o=n.RED,l=4,c=1,h=n.HALF_FLOAT,p=n.FLOAT,u=n.RGBA8):(r=e.RGBA,s=e.RGBA,a=e.RGBA,i=n.RGBA,o=e.RGBA,l=4,c=4,h=null!=t?t.HALF_FLOAT_OES:null,p=e.FLOAT,u=e.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:s,internalFormatPackedHalfFloat:a,internalFormatPackedFloat:i,textureFormatFloat:o,downloadTextureFormat:u,downloadUnpackNumChannels:l,defaultNumChannels:c,textureTypeHalfFloat:h,textureTypeFloat:p}}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function nq(e,t){const n=t();return ht().getBool("DEBUG")&&rq(e),n}function rq(e){const t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+oq(e,t))}(function(e){e[e["DENSE"]=0]="DENSE",e[e["SHARED_BATCH"]=1]="SHARED_BATCH"})(qj||(qj={})),function(e){e[e["RENDER"]=0]="RENDER",e[e["UPLOAD"]=1]="UPLOAD",e[e["PIXELS"]=2]="PIXELS",e[e["DOWNLOAD"]=3]="DOWNLOAD"}(Kj||(Kj={})),function(e){e[e["UNPACKED_FLOAT16"]=0]="UNPACKED_FLOAT16",e[e["UNPACKED_FLOAT32"]=1]="UNPACKED_FLOAT32",e[e["PACKED_4X1_UNSIGNED_BYTE"]=2]="PACKED_4X1_UNSIGNED_BYTE",e[e["PACKED_2X2_FLOAT32"]=3]="PACKED_2X2_FLOAT32",e[e["PACKED_2X2_FLOAT16"]=4]="PACKED_2X2_FLOAT16"}(Xj||(Xj={}));const sq=5.96e-8,aq=65504;function iq(e){return!!(ht().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===e||sq<Math.abs(e)&&Math.abs(e)<aq)}function oq(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}function uq(e,t){return _q(e,(()=>e.getExtension(t)),'Extension "'+t+'" not supported on this browser.')}function lq(e,t){const n=_q(e,(()=>e.createShader(e.VERTEX_SHADER)),"Unable to create vertex WebGLShader.");if(nq(e,(()=>e.shaderSource(n,t))),nq(e,(()=>e.compileShader(n))),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}function cq(e,t){const n=_q(e,(()=>e.createShader(e.FRAGMENT_SHADER)),"Unable to create fragment WebGLShader.");if(nq(e,(()=>e.shaderSource(n,t))),nq(e,(()=>e.compileShader(n))),ht().get("ENGINE_COMPILE_ONLY"))return n;if(!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw pq(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}const hq=/ERROR: [0-9]+:([0-9]+):/g;function pq(e,t){const n=hq.exec(t);if(null==n)return console.log(`Couldn't parse line number in error: ${t}`),void console.log(e);const r=+n[1],s=e.split("\n"),a=s.length.toString().length+2,i=s.map(((e,t)=>Ae((t+1).toString(),a)+e));let o=0;for(let h=0;h<i.length;h++)o=Math.max(i[h].length,o);const u=i.slice(0,r-1),l=i.slice(r-1,r),c=i.slice(r);console.log(u.join("\n")),console.log(t.split("\n")[0]),console.log(`%c ${Ae(l[0],o)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join("\n"))}function dq(e){return _q(e,(()=>e.createProgram()),"Unable to create WebGLProgram.")}function fq(e,t){if(nq(e,(()=>e.linkProgram(t))),!ht().get("ENGINE_COMPILE_ONLY")&&!1===e.getProgramParameter(t,e.LINK_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}function mq(e,t){if(nq(e,(()=>e.validateProgram(t))),!1===e.getProgramParameter(t,e.VALIDATE_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function gq(e,t){const n=_q(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return nq(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),nq(e,(()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW))),n}function yq(e,t){const n=_q(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return nq(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n))),nq(e,(()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW))),n}function bq(){return 2===ht().getNumber("WEBGL_VERSION")?1:4}function xq(e){return _q(e,(()=>e.createTexture()),"Unable to create WebGLTexture.")}function wq(e,t){const n=ht().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0){const n=`[${e}x${t}]`;throw new Error("Requested texture size "+n+" is invalid.")}if(e>n||t>n){const r=`[${e}x${t}]`,s=`[${n}x${n}]`;throw new Error("Requested texture size "+r+" greater than WebGL maximum on this browser / GPU "+s+".")}}function vq(e){return _q(e,(()=>e.createFramebuffer()),"Unable to create WebGLFramebuffer.")}function kq(e,t,n,r,s,a,i){const o=e.getAttribLocation(t,n);return-1!==o&&(nq(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,r))),nq(e,(()=>e.vertexAttribPointer(o,s,e.FLOAT,!1,a,i))),nq(e,(()=>e.enableVertexAttribArray(o))),!0)}function Iq(e,t,n){Dq(e,n),nq(e,(()=>e.activeTexture(e.TEXTURE0+n))),nq(e,(()=>e.bindTexture(e.TEXTURE_2D,t)))}function Nq(e,t){Dq(e,t),nq(e,(()=>e.activeTexture(e.TEXTURE0+t))),nq(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}function Sq(e,t,n){return _q(e,(()=>e.getUniformLocation(t,n)),'uniform "'+n+'" not present in program.')}function Tq(e,t,n){return e.getUniformLocation(t,n)}function $q(e,t,n,r){nq(e,(()=>Iq(e,t,r))),nq(e,(()=>e.uniform1i(n,r)))}function Cq(e){nq(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,null))),nq(e,(()=>e.viewport(0,0,e.canvas.width,e.canvas.height))),nq(e,(()=>e.scissor(0,0,e.canvas.width,e.canvas.height)))}function Eq(e,t,n){nq(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,n))),nq(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0)))}function Rq(e,t){nq(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,t))),nq(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0)))}function Aq(e){const t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+Fq(e,t))}function Fq(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}function _q(e,t,n){const r=nq(e,(()=>t()));if(null==r)throw new Error(n);return r}function Dq(e,t){const n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+e.TEXTURE0;if(r<e.TEXTURE0||r>n){const e=`[gl.TEXTURE0, gl.TEXTURE${n}]`;throw new Error(`textureUnit must be in ${e}.`)}}function Oq(e,t=2){return Ie(e.slice(0,e.length-t))}function Mq(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function Lq(e){let t=[1,1,1];const n=0===e.length||1===e.length&&1===e[0];return n||(t=[Oq(e),...Mq(e)]),t}function zq(e,t=!1){let n=ht().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=ht().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");if(r===1/0&&ht().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=n/2),t&&(n*=2,r*=2,e=e.map(((t,n)=>n>=e.length-2?me(e[n]):e[n])),1===e.length&&(e=[2,e[0]])),2!==e.length){const t=Oe(e);e=t.newShape}let s=Ie(e),a=null;e.length<=1&&s<=n?a=[1,s]:2===e.length&&e[0]<=n&&e[1]<=n?a=e:3===e.length&&e[0]*e[1]<=n&&e[2]<=n?a=[e[0]*e[1],e[2]]:3===e.length&&e[0]<=n&&e[1]*e[2]<=n?a=[e[0],e[1]*e[2]]:4===e.length&&e[0]*e[1]*e[2]<=n&&e[3]<=n?a=[e[0]*e[1]*e[2],e[3]]:4===e.length&&e[0]<=n&&e[1]*e[2]*e[3]<=n&&(a=[e[0],e[1]*e[2]*e[3]]);const i=null!=a&&Math.max(...a)>r&&Math.min(...a)<=(t?2:1)&&Math.min(...a)>0;if(null==a||i)if(t){const t=Oq(e);let n=2,r=2;e.length&&([n,r]=Mq(e)),s=t*(n/2)*(r/2),a=Ee(s).map((e=>2*e))}else a=Ee(s);return a}function Pq(e){return e%2===0}function Bq(e,t){if(e=e.slice(-2),t=t.slice(-2),Te(e,t))return!0;if(!e.length||!t.length)return!0;if(0===e[0]||0===e[1]||0===t[0]||0===t[1])return!0;if(e.length!==t.length){const n=e[e.length-1],r=t[t.length-1];if(n===r)return!0;if(Pq(n)&&Pq(r)&&(1===e[0]||1===t[0]))return!0}return e[1]===t[1]&&Pq(e[0])&&Pq(t[0])}let Wq,Vq;function Uq(e){if(null==Wq){const t=Gj(e);Wq=t.getParameter(t.MAX_TEXTURE_SIZE)}return Wq}function Gq(){Wq=null}function Hq(){Vq=null}function jq(e){if(null==Vq){const t=Gj(e);Vq=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,Vq)}function qq(e){if(0===e)return 0;let t;const n=Gj(e);return t=Kq(n,"EXT_disjoint_timer_query_webgl2")&&2===e?2:Kq(n,"EXT_disjoint_timer_query")?1:0,t}function Kq(e,t){const n=e.getExtension(t);return null!=n}function Xq(e){try{const t=Gj(e);if(null!=t)return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function Yq(e){if(0===e)return!1;const t=Gj(e);if(1===e){if(!Kq(t,"OES_texture_float"))return!1}else if(!Kq(t,"EXT_color_buffer_float"))return!1;const n=Zq(t);return n}function Jq(e){if(0===e)return!1;const t=Gj(e);if(1!==e){if(Kq(t,"EXT_color_buffer_float"))return Zq(t);const e="EXT_color_buffer_half_float";if(Kq(t,e)){const n=t.getExtension(e);return Qq(t,n)}return!1}if(!Kq(t,"OES_texture_float"))return!1;if(!Kq(t,"WEBGL_color_buffer_float"))return!1;const n=Zq(t);return n}function Zq(e){const t=tq(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n);const r=1,s=1;e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,r,s,0,t.textureFormatFloat,t.textureTypeFloat,null);const a=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,a),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);const i=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(a),i}function Qq(e,t){const n=tq(e,t),r=e.createTexture();e.bindTexture(e.TEXTURE_2D,r);const s=1,a=1;e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,s,a,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const i=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,i),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0);const o=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(r),e.deleteFramebuffer(i),o}function eK(e){if(2!==e)return!1;const t=Gj(e),n=null!=t.fenceSync;return n}function tK(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&we("complex64"!==e.dtype,(()=>`${t} does not support complex64 tensors in the WebGL backend.`))}))}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const nK=ht();
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function rK(){let e,t,n,r,s,a,i,o,u,l;return 2===ht().getNumber("WEBGL_VERSION")?(e="#version 300 es",t="in",n="out",r="in",s="texture",a="outputColor",i="out vec4 outputColor;",o=ht().getBool("WEBGL2_ISNAN_CUSTOM")?"\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ":"",u="",l="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(e="",t="attribute",n="varying",r="varying",s="texture2D",a="gl_FragColor",i="",o="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",u="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",l="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:e,attribute:t,varyingVs:n,varyingFs:r,texture2D:s,output:a,defineOutput:i,defineSpecialNaN:o,defineSpecialInf:u,defineRound:l}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function sK(e,t,n="index"){const r=Xe(t);return r.map(((t,s)=>{const a=`int ${e[s]} = ${n} / ${t}`,i=s===r.length-1?`int ${e[s+1]} = ${n} - ${e[s]} * ${t}`:`index -= ${e[s]} * ${t}`;return`${a}; ${i};`})).join("")}function aK(e,t,n="index"){const r=Xe(t);return r.map(((t,s)=>{const a=`int ${e[s]} = ${n} / outShapeStrides[${s}]`,i=s===r.length-1?`int ${e[s+1]} = ${n} - ${e[s]} * outShapeStrides[${s}]`:`index -= ${e[s]} * outShapeStrides[${s}]`;return`${a}; ${i};`})).join("")}function iK(e,t){const n=e.length,r=e.map((e=>`${t}[${e}]`)),s=new Array(n-1);s[n-2]=r[n-1];for(let a=n-3;a>=0;--a)s[a]=`(${s[a+1]} * ${r[a+1]})`;return s}function oK(e,t,n="index"){const r=e.map(((e,t)=>t)),s=iK(r,t);return s.map(((t,r)=>{const a=`int ${e[r]} = ${n} / ${s[r]}`,i=r===s.length-1?`int ${e[r+1]} = ${n} - ${e[r]} * ${s[r]}`:`index -= ${e[r]} * ${s[r]}`;return`${a}; ${i};`})).join("")}function uK(e){const t=Xe(e).map((e=>e.toString()));return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;\n  }\n`}function lK(){return"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n"}nK.registerFlag("HAS_WEBGL",(()=>nK.getNumber("WEBGL_VERSION")>0)),nK.registerFlag("WEBGL_VERSION",(()=>Xq(2)?2:Xq(1)?1:0)),nK.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",(()=>!1)),nK.registerFlag("WEBGL_BUFFER_SUPPORTED",(()=>2===nK.get("WEBGL_VERSION"))),nK.registerFlag("WEBGL_CPU_FORWARD",(()=>!0)),nK.registerFlag("WEBGL_FORCE_F16_TEXTURES",(()=>!1)),nK.registerFlag("WEBGL_PACK",(()=>nK.getBool("HAS_WEBGL"))),nK.registerFlag("WEBGL_PACK_NORMALIZATION",(()=>nK.getBool("WEBGL_PACK"))),nK.registerFlag("WEBGL_PACK_CLIP",(()=>nK.getBool("WEBGL_PACK"))),nK.registerFlag("WEBGL_PACK_DEPTHWISECONV",(()=>nK.getBool("WEBGL_PACK"))),nK.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",(()=>nK.getBool("WEBGL_PACK"))),nK.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",(()=>nK.getBool("WEBGL_PACK"))),nK.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",(()=>nK.getBool("WEBGL_PACK"))),nK.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",(()=>nK.getBool("WEBGL_PACK"))),nK.registerFlag("WEBGL_PACK_REDUCE",(()=>nK.getBool("WEBGL_PACK"))),nK.registerFlag("WEBGL_LAZILY_UNPACK",(()=>nK.getBool("WEBGL_PACK"))),nK.registerFlag("WEBGL_CONV_IM2COL",(()=>nK.getBool("WEBGL_PACK"))),nK.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",(()=>nK.getBool("WEBGL_PACK"))),nK.registerFlag("WEBGL_MAX_TEXTURE_SIZE",(()=>Uq(nK.getNumber("WEBGL_VERSION")))),nK.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",(()=>jq(nK.getNumber("WEBGL_VERSION")))),nK.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",(()=>{const e=nK.getNumber("WEBGL_VERSION");return 0===e?0:qq(e)})),nK.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",(()=>nK.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!vi())),nK.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",(()=>Yq(nK.getNumber("WEBGL_VERSION")))),nK.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",(()=>!nK.getBool("WEBGL_FORCE_F16_TEXTURES")&&nK.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))),nK.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",(()=>Jq(nK.getNumber("WEBGL_VERSION")))),nK.registerFlag("WEBGL_FENCE_API_ENABLED",(()=>eK(nK.getNumber("WEBGL_VERSION")))),nK.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",(()=>{const e=nK.getBool("WEBGL_RENDER_FLOAT32_ENABLED");return e?4:0})),nK.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",(()=>-1),(e=>{if("number"!==typeof e)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${e}.`);if(e<0&&-1!==e)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)})),nK.registerFlag("WEBGL_FLUSH_THRESHOLD",(()=>vi()?1:-1),(e=>{if("number"!==typeof e)throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${e}.`);if(e<0&&-1!==e)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)})),nK.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",(()=>128)),nK.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",(()=>!1)),nK.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",(()=>1e5)),nK.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",(()=>128)),nK.registerFlag("WEBGL_EXP_CONV",(()=>!1)),nK.registerFlag("SOFTWARE_WEBGL_ENABLED",(()=>nK.getBool("IS_TEST"))),nK.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",(()=>1/0)),nK.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",(()=>!1)),nK.registerFlag("WEBGL2_ISNAN_CUSTOM",(()=>!1)),nK.registerFlag("ENGINE_COMPILE_ONLY",(()=>!1));const cK="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:hK}=y;function pK(e,t,n){const r=[];if(e.forEach((e=>{const t=Ie(e.shapeInfo.logicalShape);if(e.shapeInfo.isUniform?r.push(`uniform float ${e.name}${t>1?`[${t}]`:""};`):(r.push(`uniform sampler2D ${e.name};`),r.push(`uniform int offset${e.name};`)),n.enableShapeUniforms){const{uniformShape:t}=eX(n.packedInputs,e.shapeInfo.logicalShape,e.shapeInfo.texShape);switch(t.length){case 1:r.push(`uniform int ${e.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${e.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${e.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${e.name}Shape;`);break;default:break}r.push(`uniform ivec2 ${e.name}TexShape;`)}})),n.enableShapeUniforms){switch(t.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;");break;default:break}r.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach((e=>{r.push(`uniform ${e.type} ${e.name}${e.arrayIndex?`[${e.arrayIndex}]`:""};`)}));const s=r.join("\n"),a=e.map((e=>mK(e,t,n.packedInputs,n.enableShapeUniforms))).join("\n"),i=t.texShape,o=rK(),u=bK(o);let l,c,h=vK(o);t.isPacked?(l=gK(t.logicalShape,i,n.enableShapeUniforms),c=wK(o)):(l=yK(t.logicalShape,i,n.enableShapeUniforms),c=xK(o)),n.packedInputs&&(h+=SK);const p=[h,u,c,s,l,a,n.userCode].join("\n");return p}function dK(e,t=!1){const n=e.shapeInfo.logicalShape;switch(n.length){case 0:return PK(e,t);case 1:return WK(e,t);case 2:return UK(e,t);case 3:return HK(e,t);case 4:return qK(e,t);case 5:return KK(e);case 6:return XK(e);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function fK(e,t){const n=e.shapeInfo.logicalShape;switch(n.length){case 0:return zK(e);case 1:return BK(e,t);case 2:return VK(e,t);case 3:return GK(e,t);default:return jK(e,t)}}function mK(e,t,n=!1,r){let s="";s+=n?fK(e,r):dK(e,r);const a=e.shapeInfo.logicalShape,i=t.logicalShape;return a.length<=i.length&&(s+=n?JK(e,t):ZK(e,t)),s}function gK(e,t,n){switch(e.length){case 0:return TK();case 1:return $K(e,t,n);case 2:return OK(e,t,n);case 3:return EK(e,t,n);default:return AK(e,t,n)}}function yK(e,t,n){switch(e.length){case 0:return TK();case 1:return CK(e,t,n);case 2:return MK(e,t,n);case 3:return RK(e,t,n);case 4:return FK(e,t,n);case 5:return _K(e,t);case 6:return DK(e,t);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}}function bK(e){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${e.texture2D}(textureSampler, uv).r;\n    }\n  `}function xK(e){return`\n    void setOutput(float val) {\n      ${e.output} = vec4(val, 0, 0, 0);\n    }\n  `}function wK(e){return`\n    void setOutput(vec4 val) {\n      ${e.output} = val;\n    }\n  `}function vK(e){const t=`${e.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${e.varyingFs} vec2 resultUV;\n    ${e.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${e.defineSpecialNaN}\n    ${e.defineSpecialInf}\n    ${e.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${kK}\n    ${IK}\n    ${NK}\n  `;return t}const kK="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",IK="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",NK="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",SK="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function TK(){return"\n    int getOutputCoords() {\n      return 0;\n    }\n  "}function $K(e,t,n){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return 1===r[0]?n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${r[1]}.0);\n      }\n    `:1===r[1]?n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${r[0]}.0);\n      }\n    `:n?"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);\n    }\n  `}function CK(e,t,n){return 1===t[0]?n?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.x * ${t[1]}.0);\n      }\n    `:1===t[1]?n?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.y * ${t[0]}.0);\n      }\n    `:n?"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      return resTexRC.x * ${t[1]} + resTexRC.y;\n    }\n  `}function EK(e,t,n){if(n)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],s=Math.ceil(e[2]/2),a=s*Math.ceil(e[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      int b = index / ${a};\n      index -= b * ${a};\n\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}function RK(e,t,n){if(n){const t=aK(["r","c","d"],e);return`\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ${t}\n    return ivec3(r, c, d);\n  }\n`}const r=sK(["r","c","d"],e);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec3(r, c, d);\n    }\n  `}function AK(e,t,n){if(n)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],s=Math.ceil(e[e.length-1]/2),a=s*Math.ceil(e[e.length-2]/2);let i=a,o="",u="b, r, c";for(let l=2;l<e.length-1;l++)i*=e[e.length-l-1],o=`\n      int b${l} = index / ${i};\n      index -= b${l} * ${i};\n    `+o,u=`b${l}, `+u;return`\n    ivec${e.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      ${o}\n\n      int b = index / ${a};\n      index -= b * ${a};\n\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec${e.length}(${u});\n    }\n  `}function FK(e,t,n){if(n){const t=aK(["r","c","d","d2"],e);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ${t}\n      return ivec4(r, c, d, d2);\n    }\n  `}const r=sK(["r","c","d","d2"],e);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec4(r, c, d, d2);\n    }\n  `}function _K(e,t){const n=sK(["r","c","d","d2","d3"],e);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},\n                             ${t[1]}));\n\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}function DK(e,t){const n=sK(["r","c","d","d2","d3","d4"],e);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}function OK(e,t,n){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(Te(e,t))return n?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));\n      }\n    `;const s=Math.ceil(e[1]/2);return n?"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}function MK(e,t,n){return Te(e,t)?n?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));\n      }\n    `:1===e[1]?n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `:1===e[0]?n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `:n?"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      int r = index / ${e[1]};\n      int c = index - r * ${e[1]};\n      return ivec2(r, c);\n    }\n  `}function LK(e){return`offset${e}`}function zK(e){const t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),r=rK();return`\n    vec4 ${n}() {\n      return ${r.texture2D}(${t}, halfCR);\n    }\n  `}function PK(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`float ${r}() {return ${n};}`;const[s,a]=e.shapeInfo.texShape;if(1===s&&1===a)return`\n      float ${r}() {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;const i=LK(n);if(t)return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${i});\n      return sampleTexture(${n}, uv);\n    }\n  `;const[o,u]=e.shapeInfo.texShape;return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${o}, ${u}, ${i});\n      return sampleTexture(${n}, uv);\n    }\n  `}function BK(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e.shapeInfo.texShape,a=rK();if(t)return`\n    vec4 ${r}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${a.texture2D}(${n}, uv);\n    }\n  `;const i=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];return`\n    vec4 ${r}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${i[0]}, ${i[1]}, index);\n      return ${a.texture2D}(${n}, uv);\n    }\n  `}function WK(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`\n      float ${r}(int index) {\n        ${YK(e)}\n      }\n    `;const s=e.shapeInfo.texShape,a=s[0],i=s[1];if(1===i&&1===a)return`\n      float ${r}(int index) {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;const o=LK(n);return 1===i?t?`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / float(${n}TexShape[0]));\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / ${a}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:1===a?t?`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${o}) + 0.5) / float(${n}TexShape[1]), 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${o}) + 0.5) / ${i}.0, 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `:t?`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${o});\n      return sampleTexture(${n}, uv);\n    }\n  `:`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${a}, ${i}, index + ${o});\n      return sampleTexture(${n}, uv);\n    }\n  `}function VK(e,t){const n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=e.shapeInfo.texShape,i=a[0],o=a[1],u=rK();if(null!=a&&Te(n,a))return t?`\n      vec4 ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n\n        return ${u.texture2D}(${r}, uv);\n      }\n    `:`\n      vec4 ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}.0, ${i}.0);\n\n        return ${u.texture2D}(${r}, uv);\n      }\n    `;if(t)return`\n    vec4 ${s}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${u.texture2D}(${r}, uv);\n    }\n  `;const l=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],c=Math.ceil(n[1]/2);return`\n    vec4 ${s}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${c}, ${l[0]}, ${l[1]}, row, col);\n      return ${u.texture2D}(${r}, uv);\n    }\n  `}function UK(e,t){const n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=e.shapeInfo.texShape;if(null!=a&&Te(n,a)){if(t)return`\n      float ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `;const e=a[0],n=a[1];return`\n    float ${s}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${n}.0, ${e}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `}const{newShape:i,keptDims:o}=Oe(n),u=i;if(u.length<n.length){const n=tX(e,u),r=["row","col"];return`\n      ${dK(n,t)}\n      float ${s}(int row, int col) {\n        return ${s}(${nX(r,o)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${s}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));\n        ${YK(e)}\n      }\n    `;const l=a[0],c=a[1],h=LK(r);return 1===c?t?`\n      float ${s}(int row, int col) {\n        float index = dot(vec3(row, col, ${h}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col) {\n      float index = dot(vec3(row, col, ${h}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${l}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `:1===l?t?`\n      float ${s}(int row, int col) {\n        float index = dot(vec3(row, col, ${h}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col) {\n      float index = dot(vec3(row, col, ${h}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);\n      return sampleTexture(${r}, uv);\n    }\n  `:t?`\n      float ${s}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${r}Shape[1] + col + ${h};\n        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n  float ${s}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${n[1]} + col + ${h};\n    vec2 uv = uvFromFlat(${l}, ${c}, index);\n    return sampleTexture(${r}, uv);\n  }\n`}function GK(e,t){const n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=e.shapeInfo.texShape,i=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];if(1===n[0]){const r=n.slice(1),a=[1,2],i=tX(e,r),o=["b","row","col"];return`\n        ${fK(i,t)}\n        vec4 ${s}(int b, int row, int col) {\n          return ${s}(${nX(o,a)});\n        }\n      `}const o=rK();if(t)return`\n    vec4 ${s}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${o.texture2D}(${r}, uv);\n    }\n  `;const u=i[0],l=i[1],c=Math.ceil(n[2]/2),h=c*Math.ceil(n[1]/2);return`\n    vec4 ${s}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${u}, ${l}, ${h}, ${c}, b, row, col);\n      return ${o.texture2D}(${r}, uv);\n    }\n  `}function HK(e,t){const n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=n[1]*n[2],i=n[2],{newShape:o,keptDims:u}=Oe(n),l=o;if(l.length<n.length){const n=tX(e,l),r=["row","col","depth"];return`\n        ${dK(n,t)}\n        float ${s}(int row, int col, int depth) {\n          return ${s}(${nX(r,u)});\n        }\n      `}if(e.shapeInfo.isUniform)return`\n      float ${s}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${a}, ${i}, 1)));\n        ${YK(e)}\n      }\n    `;const c=e.shapeInfo.texShape,h=c[0],p=c[1],d=e.shapeInfo.flatOffset;if(p===a&&null==d)return t?`\n      float ${s}(int row, int col, int depth) {\n        int stride1 = ${r}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n        float ${s}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${i}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${p}.0, ${h}.0);\n          return sampleTexture(${r}, uv);\n        }\n      `;if(p===i&&null==d)return t?`\n      float ${s}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${p}.0, ${h}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;const f=LK(r);return t?`\n    float ${s}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${r}Shape[1] * ${r}Shape[2];\n      int stride1 = ${r}Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ${f};\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n      return sampleTexture(${r}, uv);\n    }\n    `:`\n      float ${s}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${a} + col * ${i} + depth + ${f};\n        vec2 uv = uvFromFlat(${h}, ${p}, index);\n        return sampleTexture(${r}, uv);\n      }\n  `}function jK(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=rK();if(t)return`\n    vec4 ${r}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${n}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${s.texture2D}(${n}, uv);\n    }\n  `;const a=e.shapeInfo.logicalShape,i=a.length,o=e.shapeInfo.texShape,u=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],l=u[0],c=u[1],h=Math.ceil(a[i-1]/2);let p=h*Math.ceil(a[i-2]/2),d="int b, int row, int col",f=`b * ${p} + (row / 2) * ${h} + (col / 2)`;for(let m=2;m<i-1;m++)d=`int b${m}, `+d,p*=a[i-m-1],f=`b${m} * ${p} + `+f;return`\n    vec4 ${r}(${d}) {\n      int index = ${f};\n      int texR = index / ${c};\n      int texC = index - texR * ${c};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${l});\n      return ${s.texture2D}(${n}, uv);\n    }\n  `}function qK(e,t){const n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=n[3],i=n[2]*a,o=n[1]*i,{newShape:u,keptDims:l}=Oe(n);if(u.length<n.length){const n=tX(e,u),r=["row","col","depth","depth2"];return`\n      ${dK(n,t)}\n      float ${s}(int row, int col, int depth, int depth2) {\n        return ${s}(${nX(r,l)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${s}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${o}, ${i}, ${a}, 1)));\n        ${YK(e)}\n      }\n    `;const c=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,p=h[0],d=h[1],f=`int stride2 = ${r}Shape[3];`,m=`int stride1 = ${r}Shape[2] * stride2;`,g=`int stride0 = ${r}Shape[1] * stride1;`;if(d===o&&null==c)return t?`\n      float ${s}(int row, int col, int depth, int depth2) {\n        ${f}\n        ${m}\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${i}, ${a}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${d}.0, ${p}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;if(d===a&&null==c)return t?`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${n[1]*n[2]}, ${n[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${d}.0, ${p}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;const y=LK(r);return t?`\n    float ${s}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ${f}\n      ${m}\n      ${g}\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${y});\n      return sampleTexture(${r}, uv);\n    }\n  `:`\n    float ${s}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${o} + col * ${i} +\n          depth * ${a} + depth2;\n      vec2 uv = uvFromFlat(${p}, ${d}, index + ${y});\n      return sampleTexture(${r}, uv);\n    }\n  `}function KK(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=t[4],a=t[3]*s,i=t[2]*a,o=t[1]*i,{newShape:u,keptDims:l}=Oe(t);if(u.length<t.length){const t=tX(e,u),n=["row","col","depth","depth2","depth3"];return`\n      ${dK(t)}\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        return ${r}(${nX(n,l)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${o}, ${i}, ${a}, ${s})) +\n          depth3;\n        ${YK(e)}\n      }\n    `;const c=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,p=h[0],d=h[1];if(d===o&&null==c)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${i}, ${a}, ${s}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${d}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(d===s&&null==c)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]},\n               ${t[2]*t[3]}, ${t[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${d}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;const f=LK(n);return`\n    float ${r}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${o} + col * ${i} + depth * ${a} +\n          depth2 * ${s} + depth3 + ${f};\n      vec2 uv = uvFromFlat(${p}, ${d}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}function XK(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:s,keptDims:a}=Oe(t);if(s.length<t.length){const t=tX(e,s),n=["row","col","depth","depth2","depth3","depth4"];return`\n      ${dK(t)}\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${r}(${nX(n,a)});\n      }\n    `}const i=t[5],o=t[4]*i,u=t[3]*o,l=t[2]*u,c=t[1]*l;if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${c}, ${l}, ${u}, ${o})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${i}, 1)));\n        ${YK(e)}\n      }\n    `;const h=e.shapeInfo.flatOffset,p=e.shapeInfo.texShape,d=p[0],f=p[1];if(f===c&&null==h)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${l}, ${u}, ${o}, ${i})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${d}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(f===i&&null==h)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]*t[4]},\n               ${t[2]*t[3]*t[4]},\n               ${t[3]*t[4]},\n               ${t[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${d}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;const m=LK(n);return`\n    float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${c} + col * ${l} + depth * ${u} +\n          depth2 * ${o} + depth3 * ${i} + depth4 + ${m};\n      vec2 uv = uvFromFlat(${d}, ${f}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}function YK(e){const t=e.name,n=Ie(e.shapeInfo.logicalShape);return n<2?`return ${t};`:`\n    for (int i = 0; i < ${n}; i++) {\n      if (i == index) {\n        return ${t}[i];\n      }\n    }\n  `}function JK(e,t){const n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),s="get"+r+"AtOutCoords",a=e.shapeInfo.logicalShape.length,i=t.logicalShape.length,o=hK(e.shapeInfo.logicalShape,t.logicalShape),u=QK(i),l=i-a;let c;const h=["x","y","z","w","u","v"];c=0===a?"":i<2&&o.length>=1?"coords = 0;":o.map((e=>`coords.${h[e+l]} = 0;`)).join("\n");let p="";p=i<2&&a>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>`coords.${h[t+l]}`)).join(", ");let d="return outputValue;";const f=Ie(e.shapeInfo.logicalShape),m=1===f,g=Ie(t.logicalShape),y=1===g;if(1!==a||m||y){if(m&&!y)d=1===i?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(o.length){const e=a-2,t=a-1;o.indexOf(e)>-1&&o.indexOf(t)>-1?d="return vec4(outputValue.x);":o.indexOf(e)>-1?d="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":o.indexOf(t)>-1&&(d="return vec4(outputValue.xx, outputValue.zz);")}}else d="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${s}() {\n      ${u} coords = getOutputCoords();\n      ${c}\n      vec4 outputValue = get${r}(${p});\n      ${d}\n    }\n  `}function ZK(e,t){const n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),s="get"+r+"AtOutCoords",a=t.texShape,i=e.shapeInfo.texShape,o=e.shapeInfo.logicalShape.length,u=t.logicalShape.length;if(!e.shapeInfo.isUniform&&o===u&&null==e.shapeInfo.flatOffset&&Te(i,a))return`\n      float ${s}() {\n        return sampleTexture(${n}, resultUV);\n      }\n    `;const l=QK(u),c=hK(e.shapeInfo.logicalShape,t.logicalShape),h=u-o;let p;const d=["x","y","z","w","u","v"];p=0===o?"":u<2&&c.length>=1?"coords = 0;":c.map((e=>`coords.${d[e+h]} = 0;`)).join("\n");let f="";return f=u<2&&o>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>`coords.${d[t+h]}`)).join(", "),`\n    float ${s}() {\n      ${l} coords = getOutputCoords();\n      ${p}\n      return get${r}(${f});\n    }\n  `}function QK(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";if(6===e)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function eX(e,t,n){const{newShape:r,keptDims:s}=Oe(t),a=t.length,i=e&&3===a&&1===t[0],o=i?t.slice(1):r,u=!e&&a>1&&!Te(t,n)&&r.length<a||i,l=u?o:t;return{useSqueezeShape:u,uniformShape:l,keptDims:s}}function tX(e,t){const n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function nX(e,t){return t.map((t=>e[t])).join(", ")}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function rX(e,t,n,r){const s=n.map(((e,n)=>{const r={logicalShape:e.shape,texShape:e.isUniform?null:e.texData.texShape,isUniform:e.isUniform,isPacked:!e.isUniform&&e.texData.isPacked,flatOffset:null};return null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0&&(r.flatOffset=e.texData.slice.flatOffset),{name:t.variableNames[n],shapeInfo:r}})),a=s.map((e=>e.shapeInfo)),i={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},o=pK(s,i,t),u=cq(e.gl,o),l=e.createProgram(u);return ht().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:u,source:o,webGLProgram:l,inShapeInfos:a,outShapeInfo:i,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(e.buildVao(l),Object.assign({program:t,fragmentShader:u,source:o,webGLProgram:l,inShapeInfos:a,outShapeInfo:i},sX(e,t,l)))}function sX(e,t,n){const r=[],s=[];let a,i,o,u=null,l=null;l=e.getUniformLocation(n,"NAN",!1),1===ht().getNumber("WEBGL_VERSION")&&(u=e.getUniformLocation(n,"INFINITY",!1));const c=!1;for(const h of t.variableNames){const s={name:h,uniform:e.getUniformLocation(n,h,c),offset:e.getUniformLocation(n,`offset${h}`,c)};t.enableShapeUniforms&&(s.shape=e.getUniformLocation(n,`${h}Shape`,c),s.texShape=e.getUniformLocation(n,`${h}TexShape`,c)),r.push(s)}if(t.enableShapeUniforms&&(a=e.getUniformLocation(n,"outShape",c),o=e.getUniformLocation(n,"outShapeStrides",c),i=e.getUniformLocation(n,"outTexShape",c)),t.customUniforms)for(const h of t.customUniforms)s.push(e.getUniformLocation(n,h.name,c));return{variablesLocations:r,customUniformLocations:s,infLoc:u,nanLoc:l,outShapeLocation:a,outShapeStridesLocation:o,outTexShapeLocation:i}}function aX(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach(((e,n)=>{const r=e.logicalShape,s=t[n],a=s.shape;if(!Te(r,a))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${a} must match`);if(e.isUniform&&s.isUniform)return;const i=e.texShape,o=s.isUniform?null:s.texData.texShape;if(!Te(i,o))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${i} and ${o} must match`)}))}function iX(e,t,n,r,s){t.program.enableShapeUniforms||(aX(t.inShapeInfos,n),aX([t.outShapeInfo],[r]));const a=r.texData.texture,i=r.texData.texShape;r.texData.isPacked?e.setOutputPackedMatrixTexture(a.texture,i[0],i[1]):e.setOutputMatrixTexture(a.texture,i[0],i[1]),e.setProgram(t.webGLProgram),e.bindVertexArray(t.webGLProgram.vao),1===ht().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&e.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&e.gl.uniform1f(t.nanLoc,NaN);for(let u=0;u<n.length;++u){const r=n[u],{uniform:s,offset:a,shape:i,texShape:o}=t.variablesLocations[u];if(i){const{uniformShape:n}=eX(t.program.packedInputs,r.shape,r.texData.texShape);switch(n.length){case 1:e.gl.uniform1iv(i,new Int32Array(n));break;case 2:e.gl.uniform2iv(i,new Int32Array(n));break;case 3:e.gl.uniform3iv(i,new Int32Array(n));break;case 4:e.gl.uniform4iv(i,new Int32Array(n));break;default:break}}if(o&&e.gl.uniform2i(o,r.texData.texShape[0],r.texData.texShape[1]),null!=s)if(r.isUniform)if(Ie(r.shape)<2)e.gl.uniform1f(s,r.uniformValues[0]);else{let t=r.uniformValues;t instanceof Float32Array||(t=new Float32Array(t)),e.gl.uniform1fv(s,t)}else null!=r.texData.slice&&null!=a&&e.gl.uniform1i(a,r.texData.slice.flatOffset),e.setInputMatrixTexture(r.texData.texture.texture,s,u)}const o=t.outShapeLocation;if(o)switch(r.shape.length){case 1:e.gl.uniform1iv(o,new Int32Array(r.shape));break;case 2:e.gl.uniform2iv(o,new Int32Array(r.shape));break;case 3:e.gl.uniform3iv(o,new Int32Array(r.shape));break;case 4:e.gl.uniform4iv(o,new Int32Array(r.shape));break;default:break}if(t.outShapeStridesLocation){const n=Xe(r.shape);switch(r.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(n));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(n));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(n));break;default:break}}if(t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),t.program.customUniforms&&s)for(let u=0;u<t.program.customUniforms.length;++u){const n=t.program.customUniforms[u],r=t.customUniformLocations[u],a=s[u];if("float"===n.type)e.gl.uniform1fv(r,a);else if("vec2"===n.type)e.gl.uniform2fv(r,a);else if("vec3"===n.type)e.gl.uniform3fv(r,a);else if("vec4"===n.type)e.gl.uniform4fv(r,a);else if("int"===n.type)e.gl.uniform1iv(r,a);else if("ivec2"===n.type)e.gl.uniform2iv(r,a);else if("ivec3"===n.type)e.gl.uniform3iv(r,a);else{if("ivec4"!==n.type)throw Error(`uniform type ${n.type} is not supported yet.`);e.gl.uniform4iv(r,a)}}e.executeProgram()}function oX(e,t,n){let r="";t.concat(n).forEach((t=>{const s=null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!t.isUniform){const a=t.texData.texShape,{useSqueezeShape:i,uniformShape:o,keptDims:u}=eX(e.packedInputs,t.shape,a);let l="",c="",h="";if(1===o.length&&e.packedInputs){const e=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];l=`${e[0]>1}_${e[1]>1}`}else if(2!==o.length||e.packedInputs){if(o.length>2&&!e.packedInputs){const e=Xe(o);h=`${e[0]===a[1]}_${e[e.length-1]===a[1]}`}}else c=`${o[0]>1}_${o[1]>1}`;const p=t.shape.length,d=2===o.length&&Te(t.shape,a),f=1===Ie(t.shape),m=il(t.shape,n.shape),g=!e.packedInputs&&p===n.shape.length&&Te(a,n.texData.texShape),y=e.packedInputs||o.length>2?"":`${a[0]>1}_${a[1]>1}`;r+=`${p}_${g}_${i?u:""}_${o.length}_${f}_${m}_${d}_${l}_${c}_${h}_${y}_${s}`}else{const e=t.isUniform?"uniform":t.texData.texShape;r+=`${t.shape}_${e}_${s}`}}));const s=e.userCode;let a=e.constructor.name;return a+="_"+r+"_"+s+`${ht().getNumber("WEBGL_VERSION")}`,a}function uX(e){return ht().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class lX{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=qj.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=rK();this.outputShape=e,this.enableShapeUniforms=uX(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?aK(["r","c","d"],e):sK(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${t.output} = result;\n      }\n    `}}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class cX{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=qj.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=rK();this.outputShape=e,this.enableShapeUniforms=uX(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?aK(["r","c","d"],e):sK(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${t.output} = result;\n      }\n    `}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class hX{constructor(e){this.variableNames=["A"],this.outTexUsage=Kj.DOWNLOAD;const t=rK();this.outputShape=e,this.userCode=`\n      ${cK}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${t.output} = encode_float(x);\n      }\n    `}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class pX{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=Kj.DOWNLOAD;const t=rK();this.outputShape=e,this.userCode=`\n      ${cK}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${t.output} = encode_float(x);\n      }\n    `}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const dX={R:0,G:1,B:2,A:3};class fX{constructor(e,t=!1,n="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=rK();this.outputShape=e,this.enableShapeUniforms=uX(this.outputShape.length);let s="result";t&&(s="floor(result * 255. + 0.5)");let a="";for(let i=0;i<n.length;i++){const e=n[i];a+=`\n          if(offset == ${i}) {\n            result = values[${dX[e]}];\n          }`}this.userCode=`\n      ${this.enableShapeUniforms?lK():uK(e)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int flatIndex = getFlatIndex(coords);\n        float result = 0.;\n        int offset = imod(flatIndex, ${n.length});\n\n        flatIndex = idiv(flatIndex, ${n.length}, 1.);\n\n        int r = flatIndex / texShape[1];\n        if (r < texShape[0]) {\n          int c = imod(flatIndex, texShape[1]);\n          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n          vec4 values = ${r.texture2D}(A, uv);\n          ${a}\n        }\n        ${r.output} = vec4(${s}, 0., 0., 0.);\n      }\n    `}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class mX{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=rK();this.outputShape=e,this.enableShapeUniforms=uX(this.outputShape.length);let r="",s="result";t&&(s="floor(result * 255. + 0.5)");for(let a=0;a<=1;a++)for(let t=0;t<=1;t++){const s=2*a+t;r+=`\n          localCoords = coords;\n          if(localCoords[2] + ${t} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {\n          localCoords[2] += ${t};\n          if (localCoords[1] + ${a} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {\n            localCoords[1] += ${a};\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ${n.texture2D}(A, uv);\n\n            if (offset == 0) {\n              result[${s}] = values[0];\n            } else if (offset == 1) {\n              result[${s}] = values[1];\n            } else if (offset == 2) {\n              result[${s}] = values[2];\n            } else {\n              result[${s}] = values[3];\n            }\n          }\n        }\n        `}this.userCode=`\n        ${this.enableShapeUniforms?lK():uK(e)}\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ${r}\n\n          ${n.output} = ${s};\n        }\n    `}}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function gX(e){const t=rK(),n=`${t.version}\n    precision highp float;\n    ${t.attribute} vec3 clipSpacePos;\n    ${t.attribute} vec2 uv;\n    ${t.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`;return lq(e,n)}function yX(e){const t=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return gq(e,t)}function bX(e){const t=new Uint16Array([0,1,2,2,1,3]);return yq(e,t)}function xX(e,t,n,r,s,a){wq(t,n);const i=xq(e),o=e.TEXTURE_2D;return nq(e,(()=>e.bindTexture(o,i))),nq(e,(()=>e.texParameteri(o,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE))),nq(e,(()=>e.texParameteri(o,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE))),nq(e,(()=>e.texParameteri(o,e.TEXTURE_MIN_FILTER,e.NEAREST))),nq(e,(()=>e.texParameteri(o,e.TEXTURE_MAG_FILTER,e.NEAREST))),1===ht().getNumber("WEBGL_VERSION")?nq(e,(()=>e.texImage2D(o,0,r,t,n,0,s,a,null))):nq(e,(()=>e.texStorage2D(o,1,r,t,n))),nq(e,(()=>e.bindTexture(e.TEXTURE_2D,null))),{texture:i,texShape:[n,t]}}function wX(e){return e.internalFormatFloat}function vX(e,t,n,r){const[s,a]=Yj(t,n);return xX(e,s,a,wX(r),r.textureFormatFloat,e.FLOAT)}function kX(e){return e.internalFormatHalfFloat}function IX(e,t,n,r){const[s,a]=Yj(t,n);return xX(e,s,a,kX(r),r.textureFormatFloat,r.textureTypeHalfFloat)}function NX(e){return e.downloadTextureFormat}function SX(e,t,n,r){const[s,a]=Yj(t,n);return xX(e,s,a,NX(r),e.RGBA,e.UNSIGNED_BYTE)}function TX(e){return e.internalFormatPackedFloat}function $X(e,t,n,r){const[s,a]=Qj(t,n);return xX(e,s,a,TX(r),e.RGBA,e.FLOAT)}function CX(e){return e.internalFormatPackedHalfFloat}function EX(e,t,n,r){const[s,a]=Qj(t,n);return xX(e,s,a,CX(r),e.RGBA,r.textureTypeHalfFloat)}function RX(e,t,n){const r=0,s=12,a=20;nq(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n)));const i=kq(e,t,"clipSpacePos",n,3,a,r);return i&&kq(e,t,"uv",n,2,a,s)}function AX(e,t,n,r,s,a){let i,o,u;nq(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),s instanceof Uint8Array?(i=new Uint8Array(n*r*4),o=e.UNSIGNED_BYTE,u=e.RGBA):(i=new Float32Array(n*r*4),o=e.FLOAT,u=a.internalFormatPackedFloat),i.set(s),2===ht().getNumber("WEBGL_VERSION")?nq(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n,r,e.RGBA,o,i))):nq(e,(()=>e.texImage2D(e.TEXTURE_2D,0,u,n,r,0,e.RGBA,o,i))),nq(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}function FX(e,t,n){nq(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),n.data instanceof Uint8Array?2===ht().getNumber("WEBGL_VERSION")?nq(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n.width,n.height,e.RGBA,e.UNSIGNED_BYTE,n.data))):nq(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data))):2===ht().getNumber("WEBGL_VERSION")?nq(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,n))):nq(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n))),nq(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}function _X(e,t,n,r){const s=e.createBuffer();nq(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,s)));const a=4,i=4,o=a*i*t*n;return nq(e,(()=>e.bufferData(e.PIXEL_PACK_BUFFER,o,e.STREAM_READ))),nq(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0))),nq(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null))),s}function DX(e,t,n){const r=e,s=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,s),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),s}function OX(e,t,n,r){const[s,a]=Yj(t,n),i=4,o=new Uint8Array(Jj(t*n,i));return nq(e,(()=>e.readPixels(0,0,s,a,r.downloadTextureFormat,e.UNSIGNED_BYTE,o))),new Float32Array(o.buffer)}function MX(e,t,n,r,s,a,i,o){const u=e,l=new Float32Array(eq(a,i));return u.bindBuffer(u.PIXEL_PACK_BUFFER,t),u.getBufferSubData(u.PIXEL_PACK_BUFFER,0,l),u.bindBuffer(u.PIXEL_PACK_BUFFER,null),l}function LX(e,t,n){const r=new Float32Array(t*n*4);return nq(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,r))),r}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class zX{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const t=ht().getNumber("WEBGL_VERSION");if(null!=e?(this.gl=e,Uj(t,e)):this.gl=Gj(t),e=this.gl,2===ht().getNumber("WEBGL_VERSION")){const t=e;this.createVertexArray=()=>nq(t,(()=>t.createVertexArray())),this.bindVertexArray=e=>nq(t,(()=>t.bindVertexArray(e))),this.deleteVertexArray=e=>nq(t,(()=>t.deleteVertexArray(e))),this.getVertexArray=()=>nq(t,(()=>t.getParameter(t.VERTEX_ARRAY_BINDING)))}else if(null!=e){const t=e.getExtension("OES_vertex_array_object");if(null==t)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>nq(e,(()=>t.createVertexArrayOES())),this.bindVertexArray=n=>nq(e,(()=>t.bindVertexArrayOES(n))),this.deleteVertexArray=n=>nq(e,(()=>t.deleteVertexArrayOES(n))),this.getVertexArray=()=>nq(e,(()=>e.getParameter(t.VERTEX_ARRAY_BINDING_OES)))}let n="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===ht().getNumber("WEBGL_VERSION")){const e="OES_texture_float",t="OES_texture_half_float";if(this.textureFloatExtension=uq(this.gl,e),Kq(this.gl,t))this.textureHalfFloatExtension=uq(this.gl,t);else if(ht().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),Kq(this.gl,r))this.colorBufferHalfFloatExtension=uq(this.gl,r);else if(ht().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",Kq(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!Kq(this.gl,r))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(r)}this.vertexBuffer=yX(this.gl),this.indexBuffer=bX(this.gl),this.framebuffer=vq(this.gl),this.textureConfig=tq(this.gl,this.textureHalfFloatExtension)}get debug(){return ht().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;nq(e,(()=>e.finish())),nq(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,null))),nq(e,(()=>e.deleteFramebuffer(this.framebuffer))),nq(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,null))),nq(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null))),nq(e,(()=>e.deleteBuffer(this.indexBuffer))),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),vX(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),IX(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),SX(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),FX(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,r){this.throwIfDisposed(),AX(this.gl,e,t,n,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),EX(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),$X(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(Rq(this.gl,this.framebuffer),this.outputTexture=null),nq(this.gl,(()=>this.gl.deleteTexture(e)))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>OX(this.gl,t,n,this.textureConfig)))}downloadPackedMatrixFromBuffer(e,t,n,r,s,a){return MX(this.gl,e,t,n,r,s,a,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return DX(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);const r=_X(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if(ht().getBool("WEBGL_FENCE_API_ENABLED")){const r=e,s=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{const e=r.clientWaitSync(s,0,0);return e===r.ALREADY_SIGNALED||e===r.CONDITION_SATISFIED},t=s}else ht().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,ht().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>LX(this.gl,t,n)))}createProgram(e){this.throwIfDisposed();const t=this.gl;null==this.vertexShader&&(this.vertexShader=gX(t));const n=dq(t);nq(t,(()=>t.attachShader(n,this.vertexShader))),nq(t,(()=>t.attachShader(n,e))),fq(t,n);const r=Object.assign(n,{vao:this.createVertexArray()});return this.debug&&mq(t,r),r}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);const t=this.gl;nq(t,(()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer))),RX(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),null!=e&&(nq(this.gl,(()=>this.gl.deleteProgram(e))),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,null!=this.program&&this.debug&&mq(this.gl,this.program),nq(this.gl,(()=>this.gl.useProgram(e)))}getUniformLocation(e,t,n=!0){return this.throwIfDisposed(),n?Sq(this.gl,e,t):Tq(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),nq(this.gl,(()=>this.gl.getAttribLocation(e,t)))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),$q(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();const[r,s]=Qj(t,n);this.setOutputMatrixTextureDriver(e,r,s)}setOutputMatrixWriteRegion(e,t,n,r){this.setOutputMatrixWriteRegionDriver(n,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,n,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&mq(this.gl,this.program),Aq(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;if(this.debug){const e=this.getVertexArray();console.assert(e===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}nq(e,(()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0)))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),nq(this.gl,(()=>this.gl.finish()))}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=uq(this.gl,2===ht().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===ht().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2(),n=e.createQuery();return e.beginQuery(t.TIME_ELAPSED_EXT,n),n}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(2===ht().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2();return void e.endQuery(t.TIME_ELAPSED_EXT)}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await Fe((()=>this.disposed||this.isQueryAvailable(e,ht().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")))),this.getQueryTime(e,ht().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(0===t)return null;if(2===t){const t=this.gl,n=t.getQueryParameter(e,t.QUERY_RESULT);return n/1e6}{const t=this.getQueryTimerExtensionWebGL1(),n=t.getQueryObjectEXT(e,t.QUERY_RESULT_EXT);return n/1e6}}isQueryAvailable(e,t){if(0===t)return!0;if(2===t){const t=this.gl,n=this.getQueryTimerExtensionWebGL2(),r=t.getQueryParameter(e,t.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),r&&!this.disjoint}{const t=this.getQueryTimerExtensionWebGL1(),n=t.getQueryObjectEXT(e,t.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(t.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(e){return new Promise((t=>{this.addItemToPoll((()=>e.isFencePassed()),(()=>t()))}))}pollItems(){const e=PX(this.itemsToPoll.map((e=>e.isDoneFn)));for(let t=0;t<=e;++t){const{resolveFn:e}=this.itemsToPoll[t];e()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let n;"setTimeoutCustom"in ht().platform&&(n=ht().platform.setTimeoutCustom.bind(ht().platform)),Fe((()=>(this.pollItems(),0===this.itemsToPoll.length)),(()=>0),null,n)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),Eq(this.gl,e,this.framebuffer),this.debug&&Aq(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(Eq(this.gl,this.outputTexture,this.framebuffer),this.debug&&Aq(this.gl)):Rq(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();const r=this.gl;Eq(r,e,this.framebuffer),this.debug&&Aq(r),this.outputTexture=e,nq(r,(()=>r.viewport(0,0,t,n))),nq(r,(()=>r.scissor(0,0,t,n)))}setOutputMatrixWriteRegionDriver(e,t,n,r){this.throwIfDisposed(),nq(this.gl,(()=>this.gl.scissor(e,t,n,r)))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}function PX(e){let t=0;for(;t<e.length;++t){const n=e[t]();if(!n)break}return t-1}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const{addImpl:BX,bincountImpl:WX,bincountReduceImpl:VX,bitwiseAndImpl:UX,castImpl:GX,ceilImpl:HX,concatImpl:jX,equalImpl:qX,expImpl:KX,expm1Impl:XX,floorImpl:YX,gatherNdImpl:JX,gatherV2Impl:ZX,greaterImpl:QX,greaterEqualImpl:eY,lessImpl:tY,lessEqualImpl:nY,linSpaceImpl:rY,logImpl:sY,maxImpl:aY,maximumImpl:iY,minimumImpl:oY,multiplyImpl:uY,negImpl:lY,notEqualImpl:cY,prodImpl:hY,raggedGatherImpl:pY,raggedRangeImpl:dY,raggedTensorToTensorImpl:fY,rangeImpl:mY,rsqrtImpl:gY,scatterImpl:yY,sigmoidImpl:bY,simpleAbsImpl:xY,sliceImpl:wY,sparseFillEmptyRowsImpl:vY,sparseReshapeImpl:kY,sparseSegmentReductionImpl:IY,sqrtImpl:NY,staticRegexReplaceImpl:SY,stridedSliceImpl:TY,stringNGramsImpl:$Y,stringSplitImpl:CY,stringToHashBucketFastImpl:EY,subImpl:RY,tileImpl:AY,topKImpl:FY,transposeImpl:_Y,uniqueImpl:DY}=j;
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function OY(e,t){return["x","y","z","w","u","v"].slice(0,t).map((t=>`${e}.${t}`))}function MY(e,t){return 1===t?[e]:OY(e,t)}function LY(e,t){if(1===e)return"rc";let n="";for(let r=0;r<e;r++)n+=t[r],r<e-1&&(n+=",");return n}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class zY{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=uX(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const e=MY("rc",this.rank),t=QK(this.rank),n=this.getOutOfBoundsCondition(e),r=this.getSetup(e),s=this.getOutput(e);this.userCode=`\n        void main() {\n          ${t} rc = getOutputCoords();\n\n          if(${n}) {\n            setOutput(vec4(0));\n          } else {\n            ${r}\n\n            setOutput(vec4(${s}));\n          }\n        }\n      `}}getSourceCoordsArr(e){const t=[];for(let n=0;n<=1;n++)for(let r=0;r<=1;r++){let s=`${0===n?"r":"rp1"}, ${0===r?"c":"cp1"}`;for(let t=2;t<this.rank;t++)s=`${e[e.length-1-t]},`+s;t.push(s)}return t}getOutOfBoundsCondition(e){if(1===this.rank)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let n=this.rank-2;n<this.rank;n++)t+=`${e[n]} >= ${this.enableShapeUniforms?`outShape[${n}]`:this.outputShape[n]}`,n<this.rank-1&&(t+="||");return t}getSetup(e){if(1===this.rank)return"";const t=e.slice(-2),n=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],r=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`\n      int r = ${t[0]};\n      int c = ${t[1]};\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ${n};\n      bool rEdge = rp1 >= ${r};\n    `}getOutput(e){const t=this.getSourceCoordsArr(e);if(1===this.rank){const e=this.enableShapeUniforms?"outShape":this.outputShape[0];return`getA(rc), (rc + 1 >= ${e} ? 0. : getA(rc + 1)), 0, 0`}return`getA(${t[0]}),\n            cEdge ? 0. : getA(${t[1]}),\n            rEdge ? 0. : getA(${t[2]}),\n            rEdge || cEdge ? 0. : getA(${t[3]})`}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class PY{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=uX(this.outputShape.length);let n="";for(let r=0;r<4;r++){let e="thisRC = rc;";r%2===1&&(e+="thisRC.z += 1;"),r>1&&(e+="thisRC.y += 1;"),n+=`\n        ${e}\n        ${r>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${r}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${r>0?"}":""}\n      `}this.userCode=`\n      ${BY(t,this.enableShapeUniforms)}\n      ${this.enableShapeUniforms?lK():uK(e)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};\n        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};\n\n        ${n}\n\n        setOutput(result);\n      }\n    `}}function BY(e,t){const n=t?oK(["r","c","d"],"inputShape"):sK(["r","c","d"],e);return`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${n}\n      return ivec3(r, c, d);\n    }\n  `}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class WY{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,n){const r=jY(t,n),s=qY(e,r,n);s in this.freeTextures||(this.freeTextures[s]=[]),s in this.usedTextures||(this.usedTextures[s]=[]);const a=UY(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[s].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=a,this.log();const e=this.freeTextures[s].pop();return this.usedTextures[s].push(e),e}let i;return r===Xj.PACKED_2X2_FLOAT32?i=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===Xj.PACKED_2X2_FLOAT16?i=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===Xj.UNPACKED_FLOAT32?i=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===Xj.UNPACKED_FLOAT16?i=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===Xj.PACKED_4X1_UNSIGNED_BYTE&&(i=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[s].push(i),this.numUsedTextures++,this._numBytesAllocated+=a,this.log(),i}releaseTexture(e,t,n,r){if(null==this.freeTextures)return;const s=jY(n,r),a=qY(t,s,r);a in this.freeTextures||(this.freeTextures[a]=[]);const i=UY(t,s,this.gpgpu.gl,this.gpgpu.textureConfig,r),o=ht().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==o&&this._numBytesAllocated>o?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=i):(this.freeTextures[a].push(e),this.numFreeTextures++,this._numBytesFree+=i),this.numUsedTextures--;const u=this.usedTextures[a],l=u&&u.indexOf(e);if(null==l||l<0)throw new Error("Cannot release a texture that was never provided by this texture manager");u[l]=u[u.length-1],u.pop(),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const e in this.freeTextures)this.freeTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));for(const e in this.usedTextures)this.usedTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function VY(e,t){const n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F)return 16;if(t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}function UY(e,t,n,r,s){const a=GY(t,r);let i;if(s){const[t,n]=Qj(e[0],e[1]);i=t*n}else{const[t,n]=Yj(e[0],e[1]);i=t*n}const o=VY(n,a);return i*o}function GY(e,t){switch(e){case Xj.PACKED_2X2_FLOAT32:return TX(t);case Xj.PACKED_2X2_FLOAT16:return CX(t);case Xj.UNPACKED_FLOAT32:return wX(t);case Xj.UNPACKED_FLOAT16:return kX(t);case Xj.PACKED_4X1_UNSIGNED_BYTE:return NX(t);default:throw new Error(`Unknown physical texture type ${e}`)}}function HY(e){return ht().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?Xj.PACKED_2X2_FLOAT32:Xj.UNPACKED_FLOAT32:e?Xj.PACKED_2X2_FLOAT16:Xj.UNPACKED_FLOAT16}function jY(e,t){if(e===Kj.UPLOAD)return Xj.PACKED_2X2_FLOAT32;if(e===Kj.RENDER||null==e)return HY(t);if(e===Kj.DOWNLOAD||e===Kj.PIXELS)return Xj.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${e}`)}function qY(e,t,n){return`${e[0]}_${e[1]}_${t}_${n}`}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class KY{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=uX(this.outputShape.length),this.userCode=`\n      float unaryOperation(float x) {\n        ${t}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const XY="if (isnan(x)) return x;",YY="return x;",JY="return abs(x);";const ZY="return (x >= 0.0) ? x : (exp(x) - 1.0);",QY=XY+"\n  return (x < 0.0) ? 0.0 : x;\n",eJ=XY+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",tJ="return x;",nJ="return 1.0 / (1.0 + exp(-1.0 * x));",rJ="return x;",sJ="\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",aJ="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",iJ="\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",oJ="return 1.0 / (1.0 + exp(-1.0 * x));";class uJ{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=uX(this.outputShape.length),this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${t}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class lJ{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=uX(this.outputShape.length);const t=e.length,n=MY("rc",t),r=QK(t),s=LY(t,n),a=n.slice(-2),i=t<=1?"rc":`vec2(${a.join(",")})`;this.userCode=`\n      void main() {\n        ${r} rc = getOutputCoords();\n        vec4 packedInput = getA(${s});\n\n        setOutput(getChannel(packedInput, ${i}));\n      }\n    `}}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const cJ=Jy,hJ=1e-7,pJ=1e-4,dJ={};function fJ(e){return e in dJ||(dJ[e]={}),dJ[e]}const mJ=ht().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),gJ=600;function yJ(){return null==ht().global.screen?1024:ht().global.screen.height*ht().global.screen.width*window.devicePixelRatio*gJ/1024/1024}class bJ extends ce{nextDataId(){return bJ.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!ht().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(null!=e){if(e instanceof zX)t=e;else{const n=Gj(ht().getNumber("WEBGL_VERSION"),e);t=new zX(n)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const e=Gj(ht().getNumber("WEBGL_VERSION"));t=new zX(e),this.binaryCache=fJ(ht().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new WY(this.gpgpu),this.numMBBeforeWarning=yJ(),this.texData=new le(this,au())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,n,r,s,a){const i=this.makeTensorInfo(t,n),o=this.texData.get(i.dataId);o.isPacked=!1,o.texture={texture:e,texShape:[r,s]},o.texShape=[r,s];const u=Lq(t),l=new fX(u,!1,a),c=this.runWebGLProgram(l,[i],n,[[r,s]]);return c.shape=t,o.texture=null,this.disposeIntermediateTensorInfo(i),c.dataId}write(e,t,n){if((ht().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||ht().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===n&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.texData.set(r,{shape:t,dtype:n,values:e,usage:Kj.UPLOAD,refCount:1}),r}refCount(e){if(this.texData.has(e)){const t=this.texData.get(e);return t.refCount}return 0}incRef(e){const t=this.texData.get(e);t.refCount++}decRef(e){if(this.texData.has(e)){const t=this.texData.get(e);t.refCount--}}move(e,t,n,r,s){if(ht().getBool("DEBUG")&&this.checkNumericalProblems(t),"complex64"===r)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:n,dtype:r,values:t,usage:Kj.UPLOAD,refCount:s})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:n,dtype:r,complexTensorInfos:s,slice:a,shape:i,isPacked:o}=t;if(null!=a){let t;t=o?new uJ(i,tJ):new KY(i,tJ);const n=this.runWebGLProgram(t,[{dataId:e,shape:i,dtype:r}],r),s=this.readSync(n.dataId);return this.disposeIntermediateTensorInfo(n),s}if(null!=n)return this.convertAndCacheOnCPU(e);if("string"===r)return n;const u=null!=this.activeTimers;let l,c;if(u&&(l=xa()),"complex64"===r){const e=this.readSync(s.real.dataId),t=this.readSync(s.imag.dataId);c=ev(e,t)}else c=this.getValuesFromTexture(e);return u&&(this.downloadWaitMs+=xa()-l),this.convertAndCacheOnCPU(e,c)}async read(e){if(this.pendingRead.has(e)){const t=this.pendingRead.get(e);return new Promise((e=>t.push(e)))}const t=this.texData.get(e),{values:n,shape:r,slice:s,dtype:a,complexTensorInfos:i,isPacked:o}=t;if(null!=s){let t;t=o?new uJ(r,tJ):new KY(r,tJ);const n=this.runWebGLProgram(t,[{dataId:e,shape:r,dtype:a}],a),s=this.read(n.dataId);return this.disposeIntermediateTensorInfo(n),s}if(null!=n)return this.convertAndCacheOnCPU(e);if(ht().getBool("DEBUG")&&!ht().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===ht().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let u,l,c=null;if("complex64"!==a&&ht().get("WEBGL_BUFFER_SUPPORTED")){u=this.decode(e);const t=this.texData.get(u.dataId);c=this.gpgpu.createBufferFromTexture(t.texture.texture,...Zj(r))}if(this.pendingRead.set(e,[]),"complex64"!==a&&await this.gpgpu.createAndWaitForFence(),"complex64"===a){const e=await Promise.all([this.read(i.real.dataId),this.read(i.imag.dataId)]),t=e[0],n=e[1];l=ev(t,n)}else if(null==c)l=this.getValuesFromTexture(e);else{const e=Ie(r);l=this.gpgpu.downloadFloat32MatrixFromBuffer(c,e)}if(null!=u&&this.disposeIntermediateTensorInfo(u),null!=c){const e=this.gpgpu.gl;nq(e,(()=>e.deleteBuffer(c)))}const h=this.convertAndCacheOnCPU(e,l),p=this.pendingRead.get(e);return this.pendingRead.delete(e),p.forEach((e=>e(h))),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&au().removeDataId(e,this),this.pendingDeletes--),h}readToGPU(e,t={}){const n=this.texData.get(e),{values:r,shape:s,slice:a,dtype:i,isPacked:o,texture:u}=n;if("complex64"===i)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=a){let n;n=o?new uJ(s,tJ):new KY(s,tJ);const r=this.runWebGLProgram(n,[{dataId:e,shape:s,dtype:i}],i),a=this.readToGPU(r,t);return this.disposeIntermediateTensorInfo(r),a}if(null==u)throw null!=r?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const l=this.decode(e,t.customTexShape),c=au().makeTensorFromTensorInfo(l),h=this.texData.get(l.dataId);return Object.assign({tensorRef:c},h.texture)}bufferSync(e){const t=this.readSync(e.dataId);if("string"===e.dtype)try{const n=t.map((e=>ka(e)));return qo(e.shape,e.dtype,n)}catch(n){throw new Error("Failed to decode encoded string bytes into utf-8")}return qo(e.shape,e.dtype,t)}checkNumericalProblems(e){if(null!=e)for(let t=0;t<e.length;t++){const n=e[t];if(!iq(n)){if(ht().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);throw Error(`The value ${n} cannot be represented on this device.`)}}}getValuesFromTexture(e){const{shape:t,dtype:n,isPacked:r}=this.texData.get(e),s=Ie(t);if(ht().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const n=this.decode(e),r=this.texData.get(n.dataId),a=this.gpgpu.downloadMatrixFromPackedTexture(r.texture.texture,...Zj(t)).subarray(0,s);return this.disposeIntermediateTensorInfo(n),a}const a=ht().getBool("WEBGL_PACK")&&!0===r,i=a?Lq(t):t,o=a?new pX(i):new hX(i),u=this.runWebGLProgram(o,[{shape:i,dtype:n,dataId:e}],"float32"),l=this.texData.get(u.dataId),c=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(l.texture.texture,l.texShape[0],l.texShape[1]).subarray(0,s);return this.disposeIntermediateTensorInfo(u),c}timerAvailable(){return ht().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const t=this.activeTimers,n=[];let r=!1;null==this.programTimersStack?(this.programTimersStack=n,r=!0):this.activeTimers.push(n),this.activeTimers=n,e();const s=Na(this.activeTimers.map((e=>e.query))).filter((e=>null!=e)),a=Na(this.activeTimers.map((e=>e.name))).filter((e=>null!=e));this.activeTimers=t,r&&(this.programTimersStack=null);const i={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(ht().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const e=await Promise.all(s);i["kernelMs"]=ye(e),i["getExtraProfileInfo"]=()=>e.map(((e,t)=>({name:a[t],ms:e}))).map((e=>`${e.name}: ${e.ms}`)).join(", ")}else i["kernelMs"]={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,i})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return ht().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:xa(),endMs:null}}endTimer(e){return ht().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=xa(),e)}async getQueryTime(e){if(ht().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:n}=this.texData.get(e);return null!=n&&(this.disposeData(n.real.dataId,t),this.disposeData(n.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:n,texShape:r,usage:s,isPacked:a,slice:i}=this.texData.get(e),o=i&&i.origDataId||e,u=this.dataRefCount.get(o);u>1?this.dataRefCount.set(o,u-1):(this.dataRefCount.delete(o),null!=t&&(this.numBytesInGPU-=this.computeBytes(r,n),this.textureManager.releaseTexture(t,r,s,a)));const l=this.texData.get(e);l.texture=null,l.texShape=null,l.isPacked=!1,l.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=mJ){return ht().getBool("WEBGL_CPU_FORWARD")&&e.every((e=>null==this.texData.get(e.dataId).texture&&Ie(e.shape)<t))}getGPGPUContext(){return this.gpgpu}where(e){Ls("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return cJ(e.shape,t)}packedUnaryOp(e,t,n){const r=new uJ(e.shape,t),s=this.compileAndRun(r,[e],n);return au().makeTensorFromTensorInfo(s)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){const t=xY(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,t)}if(ht().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,JY,e.dtype);const t=new KY(e.shape,JY),n=this.compileAndRun(t,[e]);return au().makeTensorFromTensorInfo(n)}makeTensorInfo(e,t,n){let r;if("string"===t&&null!=n&&n.length>0&&Ue(n[0])){const s=n.map((e=>va(e)));r=this.write(s,e,t)}else r=this.write(n,e,t);return this.texData.get(r).usage=null,{dataId:r,shape:e,dtype:t}}makeOutput(e,t,n){return au().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,n),this)}unpackTensor(e){const t=new lJ(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new zY(e.shape),n=!0;return this.runWebGLProgram(t,[e],e.dtype,null,n)}packedReshape(e,t){const n=[Oq(e.shape),...Mq(e.shape)],r={dtype:e.dtype,shape:n,dataId:e.dataId},s=[Oq(t),...Mq(t)],a=new PY(s,n),i=!0,o=[n],u=this.runWebGLProgram(a,[r],e.dtype,o,i);return{dataId:u.dataId,shape:t,dtype:u.dtype}}decode(e,t){const n=this.texData.get(e),{isPacked:r,shape:s,dtype:a}=n;if(null!=t){const e=Ie(s),n=t[0]*t[1]*4;we(e<=n,(()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data."))}const i=Lq(s);let o;o=r?new cX(i):new lX(i);const u=!0,l=[null!=t?t:Zj(i)],c=this.runWebGLProgram(o,[{shape:i,dtype:a,dataId:e}],a,l,u,t);return{dtype:a,shape:s,dataId:c.dataId}}runWebGLProgram(e,t,n,r,s=!1,a){const i=this.makeTensorInfo(e.outputShape,n),o=this.texData.get(i.dataId);if(e.packedOutput&&(o.isPacked=!0),e.outPackingScheme===qj.DENSE){const t=null!=a?a:Zj(e.outputShape);o.texShape=t.map((e=>2*e))}if(null!=e.outTexUsage&&(o.usage=e.outTexUsage),0===Ie(i.shape))return o.values=Me(i.dtype,0),i;const u=[],l=t.map((t=>{if("complex64"===t.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let n=this.texData.get(t.dataId);if(null==n.texture){if(!e.packedInputs&&Ie(t.shape)<=ht().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:t.shape,texData:null,isUniform:!0,uniformValues:n.values};e.packedInputs&&(n.isPacked=!0,n.shape=t.shape)}if(this.uploadToGPU(t.dataId),!!n.isPacked!==!!e.packedInputs)t=n.isPacked?this.unpackTensor(t):this.packTensor(t),u.push(t),n=this.texData.get(t.dataId);else if(n.isPacked&&!Bq(n.shape,t.shape)){const e=t,r=t.shape;t.shape=n.shape,t=this.packedReshape(t,r),u.push(t),n=this.texData.get(t.dataId),e.shape=r}return{shape:t.shape,texData:n,isUniform:!1}}));this.uploadToGPU(i.dataId);const c={shape:i.shape,texData:o,isUniform:!1},h=oX(e,l,c),p=this.getAndSaveBinary(h,(()=>rX(this.gpgpu,e,l,c))),d=null!=this.activeTimers;let f;d&&(f=this.startTimer()),ht().get("ENGINE_COMPILE_ONLY")||iX(this.gpgpu,p,l,c,r),u.forEach((e=>this.disposeIntermediateTensorInfo(e))),d&&(f=this.endTimer(f),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(f)}));const m=ht().getNumber("WEBGL_FLUSH_THRESHOLD");if(m>0){const e=xa();e-this.lastGlFlushTime>m&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=e)}if(!ht().getBool("WEBGL_LAZILY_UNPACK")&&o.isPacked&&!1===s){const e=this.unpackTensor(i);return this.disposeIntermediateTensorInfo(i),e}return i}compileAndRun(e,t,n,r,s=!1){n=n||t[0].dtype;const a=this.runWebGLProgram(e,t,n,r,s);return a}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){if(!this.disposed){if(!ht().getBool("IS_TEST")){const e=Object.keys(this.binaryCache);e.forEach((e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]}))}this.textureManager.dispose(),null!=this.canvas&&"undefined"!==typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0}}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=uu((()=>{if(!ht().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=ht().getBool("DEBUG");ht().set("DEBUG",!1);const t=this.abs(Vu(1e-8)).dataSync()[0];if(ht().set("DEBUG",e),t>0)return 32}return 16}))),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?hJ:pJ}uploadToGPU(e){const t=this.texData.get(e),{shape:n,dtype:r,values:s,texture:a,usage:i,isPacked:o}=t;if(null!=a)return;const u=null!=this.activeTimers;let l;u&&(l=xa());let c=t.texShape;if(null==c&&(c=zq(n,o),t.texShape=c),null!=s){const e=Lq(n);let a,i=c[1],h=c[0];const p=s instanceof Uint8Array||s instanceof Uint8ClampedArray;!o&&p||([i,h]=Qj(c[0],c[1])),a=o?new mX(e,p):new fX(e,p);const d=p?[h,i]:c,f=this.makeTensorInfo(d,r),m=this.texData.get(f.dataId);m.usage=p?Kj.PIXELS:Kj.UPLOAD,m.texShape=d,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(f.dataId),i,h,s);const g=[[h,i]],y=!0,b=this.runWebGLProgram(a,[f],r,g,y),x=this.texData.get(b.dataId);t.texShape=x.texShape,t.isPacked=x.isPacked,t.usage=x.usage,ht().get("ENGINE_COMPILE_ONLY")?this.disposeData(b.dataId):(t.texture=x.texture,t.values=null,this.texData.delete(b.dataId)),this.disposeIntermediateTensorInfo(f),u&&(this.uploadWaitMs+=xa()-l)}else{const e=this.acquireTexture(c,i,r,o);t.texture=e}}convertAndCacheOnCPU(e,t){const n=this.texData.get(e),{dtype:r}=n;return null!=t&&(n.values=xJ(t,r)),n.values}acquireTexture(e,t,n,r){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const e=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${e} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,r)}computeBytes(e,t){return e[0]*e[1]*We(t)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}for(const[,t]of Object.entries(this.binaryCache)){const n=new Promise((e=>{try{this.checkCompletion_(t),e(!0)}catch(n){throw n}}));e.push(n)}return Promise.all(e)}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await Rw(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(!1===this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)){if(console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS))throw pq(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.");throw new Error("Failed to link vertex and fragment shaders.")}return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:t,customUniformLocations:n,infLoc:r,nanLoc:s,outShapeLocation:a,outShapeStridesLocation:i,outTexShapeLocation:o}=sX(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=t,e.customUniformLocations=n,e.infLoc=r,e.nanLoc=s,e.outShapeLocation=a,e.outShapeStridesLocation=i,e.outTexShapeLocation=o}}createTensorFromGPUData(e,t,n){e.channels=e.channels||"RGBA";const{texture:r,height:s,width:a,channels:i}=e,o=au().backend;if(!o.gpgpu.gl.isTexture(r))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const u=o.writeTexture(r,t,n,s,a,i);return au().makeTensorFromDataId(u,t,n,o)}}function xJ(e,t){if("float32"===t||"complex64"===t)return e;if("int32"===t||"bool"===t){const n="int32"===t?new Int32Array(e.length):new Uint8Array(e.length);for(let t=0;t<n.length;++t)n[t]=Math.round(e[t]);return n}throw new Error(`Unknown dtype ${t}`)}bJ.nextDataId=0;
/** @license See the LICENSE file. */
const wJ="4.11.0";
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function vJ(){ht().set("WEBGL_FORCE_F16_TEXTURES",!0)}
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
ki()&&bu("webgl",(()=>new bJ),2);const kJ={forceHalfFloat:vJ},IJ="\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n";class NJ{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=ul(t,n),this.enableShapeUniforms=uX(this.outputShape.length),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${e}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const SJ="\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n";class TJ{constructor(e,t,n,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=ul(t,n);const s=this.outputShape.length;this.enableShapeUniforms=uX(s);let a="";if(r)if(0===s||1===Ie(this.outputShape))a="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else{const e=QK(s);if(a=`\n          ${e} coords = getOutputCoords();\n        `,1===s)this.enableShapeUniforms?a+="\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":a+=`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const e=MY("coords",s);this.enableShapeUniforms?a+=`\n            bool nextRowOutOfBounds =\n              (${e[s-2]} + 1) >= outShape[${s} - 2];\n            bool nextColOutOfBounds =\n              (${e[s-1]} + 1) >= outShape[${s} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `:a+=`\n            bool nextRowOutOfBounds =\n              (${e[s-2]} + 1) >= ${this.outputShape[s-2]};\n            bool nextColOutOfBounds =\n              (${e[s-1]} + 1) >= ${this.outputShape[s-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${e}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${a}\n\n        setOutput(result);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function $J(e){const{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const CJ={kernelName:On,backendName:"webgl",kernelFunc:$J};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function EJ(e){const{inputs:t,backend:n}=e,{real:r,imag:s}=t,a=n.makeTensorInfo(r.shape,"complex64"),i=n.texData.get(a.dataId),o=$J({inputs:{x:r},backend:n}),u=$J({inputs:{x:s},backend:n});return i.complexTensorInfos={real:o,imag:u},a}const RJ={kernelName:Ht,backendName:"webgl",kernelFunc:EJ},AJ="return (a < 0.) ? b * a : a;",FJ="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";function _J(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{alpha:a}=r,i=n.makeTensorInfo([],"float32",ga(a,"float32")),o=ht().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new TJ(FJ,s.shape,i.shape):new NJ(AJ,s.shape,i.shape),u=n.runWebGLProgram(o,[s,i],"float32");return n.disposeIntermediateTensorInfo(i),u}const DJ={kernelName:Wn,backendName:"webgl",kernelFunc:_J},OJ="return (a < 0.) ? b * a : a;",MJ="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";function LJ(e){const{inputs:t,backend:n}=e,{x:r,alpha:s}=t,a=ht().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new TJ(MJ,r.shape,s.shape):new NJ(OJ,r.shape,s.shape);return n.runWebGLProgram(a,[r,s],"float32")}const zJ={kernelName:$r,backendName:"webgl",kernelFunc:LJ},PJ="if (isnan(x)) return x;";function BJ({opSnippet:e,packedOpSnippet:t,cpuKernelImpl:n,dtype:r}){return({inputs:s,backend:a})=>{const{x:i}=s,o=a,u=r||i.dtype;if(o.shouldExecuteOnCPU([i])&&null!=n){const e=o.texData.get(i.dataId),t=n(e.values,u);return o.makeTensorInfo(i.shape,u,t)}const l=ht().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=t;let c;return c=l?new uJ(i.shape,t):new KY(i.shape,e),o.runWebGLProgram(c,[i],u)}}function WJ({opSnippet:e,packedOpSnippet:t,checkOutOfBounds:n=!1,supportsComplex:r=!1,cpuKernelImpl:s,dtype:a}){return({inputs:i,backend:o})=>{const{a:u,b:l}=i,c=o;if(r&&"complex64"===u.dtype){const t=c.texData.get(u.dataId),n=c.texData.get(l.dataId),[r,s]=[[t.complexTensorInfos.real,n.complexTensorInfos.real],[t.complexTensorInfos.imag,n.complexTensorInfos.imag]].map((t=>{const[n,r]=t,s={dataId:n.dataId,dtype:n.dtype,shape:u.shape},a={dataId:r.dataId,dtype:r.dtype,shape:l.shape},i=new NJ(e,u.shape,l.shape);return c.runWebGLProgram(i,[s,a],ti(n.dtype,r.dtype))})),a=EJ({inputs:{real:r,imag:s},backend:c});return c.disposeIntermediateTensorInfo(r),c.disposeIntermediateTensorInfo(s),a}const h=a||ti(u.dtype,l.dtype);if(("string"===u.dtype||"string"===l.dtype||c.shouldExecuteOnCPU([u,l]))&&null!=s){const e=c.texData.get(u.dataId).values,t=c.texData.get(l.dataId).values,n="string"===u.dtype?Dv(e):e,r="string"===u.dtype?Dv(t):t,[a,i]=s(u.shape,l.shape,n,r,h),o=c.makeTensorInfo(i,h),p=c.texData.get(o.dataId);return p.values=a,o}const p=ht().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=t;let d;return d=p?new TJ(t,u.shape,l.shape,n):new NJ(e,u.shape,l.shape),c.runWebGLProgram(d,[u,l],h)}}function VJ(e,t=!1){if("linear"===e)return t?rJ:YY;if("relu"===e)return t?aJ:QY;if("elu"===e)return t?sJ:ZY;if("relu6"===e)return t?iJ:eJ;if("prelu"===e)return t?MJ:OJ;if("leakyrelu"===e)return t?FJ:AJ;if("sigmoid"===e)return t?oJ:nJ;throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class UJ{constructor(e,t,n,r=!1,s=!1,a=!1,i=null,o=!1,u=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=uX(this.outputShape.length);const l=r?e[1]:e[2],c=Math.ceil(l/2),h=r?"i * 2, rc.y":"rc.y, i * 2",p=s?"rc.z, i * 2":"i * 2, rc.z",d=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],f=s?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let m="",g="";i&&(m=o?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${i}\n        }`:u?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${i}\n        }`:`vec4 activation(vec4 x) {\n          ${i}\n        }`,g="result = activation(result);");const y=a?"result += getBiasAtOutCoords();":"";a&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),u&&this.variableNames.push("leakyreluAlpha");let b="rc.x",x="rc.x";e[0]<t[0]?b=`imod(rc.x, ${e[0]})`:t[0]<e[0]&&(x=`imod(rc.x, ${t[0]})`),this.userCode=`\n      ${m}\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ${c}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        int batchA = ${b};\n        int batchB = ${x};\n        for (int i = 0; i < ${c}; i++) {\n          vec4 a = getMatrixA(batchA, ${h});\n          vec4 b = getMatrixB(batchB, ${p});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${d[0]} * ${f[0]});\n          result += (${d[1]} * ${f[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${y}\n\n        ${g}\n\n        setOutput(result);\n      }\n    `}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const GJ={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class HJ{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=ul(t,n),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${e}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const jJ="return a * b;";function qJ(e){const{inputs:t,backend:n}=e,{a:r,b:s}=t,a=ti(r.dtype,s.dtype);if("complex64"===r.dtype){const e=n.texData.get(r.dataId),t=n.texData.get(s.dataId),a=new HJ(GJ.REAL,r.shape,s.shape),i=new HJ(GJ.IMAG,r.shape,s.shape),o=[{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:r.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:s.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:s.shape}],u=n.runWebGLProgram(a,o,"float32"),l=n.runWebGLProgram(i,o,"float32"),c=EJ({inputs:{real:u,imag:l},backend:n});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(l),c}if(n.shouldExecuteOnCPU([r,s])){const e=n.texData.get(r.dataId),t=n.texData.get(s.dataId),[i,o]=uY(r.shape,s.shape,e.values,t.values,a),u=n.makeTensorInfo(o,a),l=n.texData.get(u.dataId);return l.values=i,u}let i;return i=ht().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new TJ(jJ,r.shape,s.shape):new NJ(jJ,r.shape,s.shape),n.runWebGLProgram(i,[r,s],a)}const KJ={kernelName:mr,backendName:"webgl",kernelFunc:qJ};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function XJ(e,t,n){const r=[Oq(e.shape),...Mq(e.shape)],s={dtype:e.dtype,shape:r,dataId:e.dataId},a=[Oq(t),...Mq(t)],i=new PY(a,r),o=!0,u=[r],l=n.runWebGLProgram(i,[s],e.dtype,u,o);return{dataId:l.dataId,shape:t,dtype:l.dtype}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function YJ(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{shape:a}=r,i=n,o=Ie(s.shape),u=_e(a,o),l=Ie(u);we(o===l,(()=>`The new shape (${u}) has ${l} elements and the old shape (${s.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`));const c=i.texData.get(s.dataId);return!c.isPacked||Bq(s.shape,u)||null!==c.texture&&Bq(c.shape,u)?(i.incRef(s.dataId),{dataId:s.dataId,shape:u,dtype:s.dtype}):XJ(s,u,i)}const JJ={kernelName:Mr,backendName:"webgl",kernelFunc:YJ};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class ZJ{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:s,outSize:a}=e;this.outputShape=[r,a];const i=4*Math.floor(n/4),o=n%4;let u="sumValue += dot(values, ones);";if(null!=t){const e=1/t;u=`sumValue += dot(values * ${$e(e)?e.toPrecision(2):e}, ones);`}let l="";s%n>0&&(l=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${l}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${i}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${u}\n        }\n\n        int inIdx = inOffset + ${i};\n        if (${1===o}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${u}\n        } else if (${2===o}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${u}\n        } else if (${3===o}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${u}\n        }\n        setOutput(sumValue);\n      }\n    `}}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class QJ{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:s,outSize:a}=e;this.outputShape=[r,a];let i="0.0",o="";"prod"===t?i="1.0":"min"===t?(i="1.0 / 1e-20",o="min"):"max"===t&&(i="-1.0 / 1e-20",o="max");let u=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===t?u="sumValue":"prod"===t?u="prodValue":"all"===t?u="allValue":"any"===t&&(u="anyValue");const l=4*Math.floor(n/4),c=n%4;let h=`\n      if (${"sum"===t}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===t}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${o}(values, minMaxValue);\n        if (${"min"===t} || ${"max"===t}) {\n          minMaxValue = ${o}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `,p="vec4";"all"===t?(i="1.0",h="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",p="bvec4"):"any"===t&&(i="0.0",h="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",p="bvec4");let d="";s%n>0&&(d=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${i};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${d}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        vec4 minMaxValue = vec4(${i});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${l}; i += 4) {\n          int inIdx = inOffset + i;\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${h}\n        }\n\n        int inIdx = inOffset + ${l};\n        if (${1===c}) {\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${2===c}) {\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${3===c}) {\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${h}\n        }\n        setOutput(${u});\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function eZ(e){const t=[];while(0===t.length||1!==t[t.length-1].outSize){const n=t.length?t[t.length-1].outSize:e[1],r=Pw(n);t.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)})}return t}function tZ(e,t,n,r){const s=eZ(e.shape);let a=e;for(let i=0;i<s.length;i++){const{inSize:o,windowSize:u,outSize:l}=s[i];let c,h;c="mean"===n?0===i?new ZJ({windowSize:u,inSize:o,batchSize:e.shape[0],outSize:l},o):new ZJ({windowSize:u,inSize:o,batchSize:e.shape[0],outSize:l}):new QJ({windowSize:u,inSize:o,batchSize:e.shape[0],outSize:l},n),h=a,a=r.runWebGLProgram(c,[a],t),h.dataId!==e.dataId&&r.disposeIntermediateTensorInfo(h)}return a}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class nZ{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let a=0;a<n.length;a++)n[a]=e[t[a]];this.outputShape=n,this.rank=n.length;const r=QK(this.rank),s=rZ(t);this.userCode=`\n    void main() {\n      ${r} resRC = getOutputCoords();\n      setOutput(getA(${s}));\n    }\n    `}}function rZ(e){const t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(t);for(let s=0;s<e.length;s++)r[e[s]]=n[s];return r.join()}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class sZ{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const n=new Array(e.length);for(let l=0;l<n.length;l++)n[l]=e[t[l]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const r=QK(this.rank),s=OY("rc",this.rank),a=new Array(this.rank);for(let l=0;l<t.length;l++)a[t[l]]=s[l];const i=`vec2(${a.slice(-2).join()})`,o=`++${s[this.rank-1]} < ${n[this.rank-1]}`,u=`getChannel(getA(${a.join()}), ${i})`;this.userCode=`\n    void main() {\n      ${r} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${u};\n      if(${o}) {\n        result[1] = ${u};\n      }\n      --${s[this.rank-1]};\n      if(++${s[this.rank-2]} < ${n[this.rank-2]}) {\n        result[2] = ${u};\n        if(${o}) {\n          result[3] = ${u};\n        }\n      }\n      setOutput(result);\n    }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function aZ(e,t,n){const r=ht().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new sZ(e.shape,t):new nZ(e.shape,t);return n.runWebGLProgram(r,[e],e.dtype)}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function iZ(e,t,n,r){const s=t,a=e.shape.length,i=De(s,e.shape);let o=i;const u=Bd(o,a),l=null!=u;let c=e;l&&(c=aZ(e,u,r),o=Vd(o.length,a)),Pd("sum",o,a);const[h,p]=Ld(c.shape,o);let d=h;n&&(d=zd(h,i));const f=Ie(p),m=Ie(e.shape),g=m/f,y=YJ({inputs:{x:c},attrs:{shape:[g,f]},backend:r}),b=ni(e.dtype),x=tZ(y,b,"sum",r),w=YJ({inputs:{x:x},attrs:{shape:d},backend:r});return r.disposeIntermediateTensorInfo(y),r.disposeIntermediateTensorInfo(x),l&&r.disposeIntermediateTensorInfo(c),w}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function oZ(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;return iZ(s,a,i,n)}const uZ={kernelName:rs,backendName:"webgl",kernelFunc:oZ};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function lZ(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{perm:a}=r,i=n,o=s.shape.length,u=new Array(o);for(let c=0;c<u.length;c++)u[c]=s.shape[a[c]];let l;if(i.shouldExecuteOnCPU([s])){const e=i.texData.get(s.dataId),t=e.values,n=_Y(t,s.shape,s.dtype,a,u);l=i.makeTensorInfo(u,s.dtype);const r=i.texData.get(l.dataId);r.values=n}else l=aZ(s,a,i);return l}const cZ={kernelName:Ss,backendName:"webgl",kernelFunc:lZ},hZ=1e3;function pZ({a:e,b:t,transposeA:n,transposeB:r,backend:s,bias:a=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:u=null}){const l=e.shape.length,c=t.shape.length,h=n?e.shape[l-2]:e.shape[l-1],p=r?t.shape[c-1]:t.shape[c-2],d=n?e.shape[l-1]:e.shape[l-2],f=r?t.shape[c-2]:t.shape[c-1],m=e.shape.slice(0,-2),g=t.shape.slice(0,-2),y=Ie(m),b=Ie(g),x=ul(e.shape.slice(0,-2),t.shape.slice(0,-2)),w=x.concat([d,f]);we(h===p,(()=>`Error in matMul: inner shapes (${h}) and (${p}) of Tensors with shapes ${e.shape} and ${t.shape} and transposeA=${n} and transposeB=${r} must match.`));const v=n?[y,h,d]:[y,d,h],k=r?[b,f,p]:[b,p,f],I=YJ({inputs:{x:e},backend:s,attrs:{shape:v}}),N=YJ({inputs:{x:t},backend:s,attrs:{shape:k}}),S=[I,N],T=Math.max(y,b),$=n?I.shape[1]:I.shape[2],C=null!=a,E=null!=i,R="leakyrelu"===u,A=null!=u?VJ(u,!0):null,F=C||E||R||null!=A;let _;if((1===d||1===f)&&$>hZ&&!1===F){let e=I,t=N;n&&(e=lZ({inputs:{x:I},backend:s,attrs:{perm:[0,2,1]}}),S.push(e)),r&&(t=lZ({inputs:{x:N},backend:s,attrs:{perm:[0,2,1]}}),S.push(t));const a=1!==f,i=1===f;let o=e;a&&(o=YJ({inputs:{x:e},backend:s,attrs:{shape:[T,$,1]}}),S.push(o));const u=1===f?2:1;let l=t;i&&(l=YJ({inputs:{x:t},backend:s,attrs:{shape:[T,1,$]}}),S.push(l));const c=qJ({inputs:{a:o,b:l},backend:s});_=oZ({inputs:{x:c},backend:s,attrs:{axis:u,keepDims:!0}}),S.push(c)}else{const u=ti(e.dtype,t.dtype),l=new UJ(v,k,[T,d,f],n,r,C,A,E,R),c=[I,N];if(null!=a&&c.push(a),E&&c.push(i),R){const e=s.makeTensorInfo([],"float32",ga(o,"float32"));c.push(e),S.push(e)}_=s.runWebGLProgram(l,c,u)}const D=YJ({inputs:{x:_},backend:s,attrs:{shape:w}});S.push(_);for(const O of S)s.disposeIntermediateTensorInfo(O);return D}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function dZ(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:a,bias:i,preluActivationWeights:o}=t,{transposeA:u,transposeB:l,activation:c,leakyreluAlpha:h}=r;return pZ({a:s,b:a,transposeA:u,transposeB:l,backend:n,bias:i,preluActivationWeights:o,leakyreluAlpha:h,activation:c})}const fZ={kernelName:Ds,backendName:"webgl",kernelFunc:dZ},mZ="return abs(x);";function gZ(e){const{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])&&"complex64"!==r.dtype){const e=n.texData.get(r.dataId),t=xY(e.values);return n.makeTensorInfo(r.shape,r.dtype,t)}let s;return s=ht().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new uJ(r.shape,mZ):new KY(r.shape,mZ),n.runWebGLProgram(s,[r],r.dtype)}const yZ={kernelName:bt,backendName:"webgl",kernelFunc:gZ},bZ=XY+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n",xZ=BJ({opSnippet:bZ}),wZ={kernelName:xt,backendName:"webgl",kernelFunc:xZ},vZ=XY+"\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));",kZ=BJ({opSnippet:vZ}),IZ={kernelName:wt,backendName:"webgl",kernelFunc:kZ},NZ="return a + b;",SZ=WJ({opSnippet:NZ,packedOpSnippet:NZ,supportsComplex:!0,cpuKernelImpl:BX}),TZ={kernelName:vt,backendName:"webgl",kernelFunc:SZ};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class $Z{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map(((e,t)=>`T${t}`));const n=[];this.variableNames.forEach((e=>{n.push(`float v${e} = get${e}AtOutCoords();`)}));const r=this.variableNames.map((e=>`v${e}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        float result = ${r};\n        setOutput(result);\n      }\n    `}}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class CZ{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map(((e,t)=>`T${t}`));const n=[];this.variableNames.forEach((e=>{n.push(`vec4 v${e} = get${e}AtOutCoords();`)}));const r=this.variableNames.map((e=>`v${e}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        vec4 result = ${r};\n        setOutput(result);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function EZ(e){const{inputs:t,backend:n}=e,r=t;if(1===r.length)return $J({inputs:{x:r[0]},backend:n});if(r.length>ht().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const e=Math.floor(r.length/2),t=EZ({inputs:r.slice(0,e),backend:n}),s=EZ({inputs:r.slice(e),backend:n});return EZ({inputs:[t,s],backend:n})}const s=r.map((e=>e.dtype)).reduce(((e,t)=>ti(e,t))),a=r.map((e=>e.shape)),i=ht().getBool("WEBGL_PACK"),o=i?new CZ(r[0].shape,a):new $Z(r[0].shape,a);return n.runWebGLProgram(o,r,s)}const RZ={kernelName:kt,backendName:"webgl",kernelFunc:EZ};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function AZ(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=s.shape.length,u=De(a,s.shape);let l=u;const c=Bd(l,o);let h=s;null!=c&&(h=lZ({inputs:{x:s},backend:n,attrs:{perm:c}}),l=Vd(l.length,o)),Pd("all",l,o);const[p,d]=Ld(h.shape,l),f=Ie(d),m=YJ({inputs:{x:h},backend:n,attrs:{shape:[-1,f]}}),g=tZ(m,m.dtype,"all",n);let y;if(i){const e=zd(p,u);y=YJ({inputs:{x:g},backend:n,attrs:{shape:e}})}else y=YJ({inputs:{x:g},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),null!=c&&n.disposeIntermediateTensorInfo(h),y}const FZ={kernelName:It,backendName:"webgl",kernelFunc:AZ};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function _Z(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=s.shape.length,u=De(a,s.shape);let l=u;const c=Bd(l,o);let h=s;null!=c&&(h=lZ({inputs:{x:s},backend:n,attrs:{perm:c}}),l=Vd(l.length,o)),Pd("any",l,o);const[p,d]=Ld(h.shape,l),f=Ie(d),m=YJ({inputs:{x:h},backend:n,attrs:{shape:[-1,f]}}),g=tZ(m,m.dtype,"any",n);let y;if(i){const e=zd(p,u);y=YJ({inputs:{x:g},backend:n,attrs:{shape:e}})}else y=YJ({inputs:{x:g},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),null!=c&&n.disposeIntermediateTensorInfo(h),y}const DZ={kernelName:Nt,backendName:"webgl",kernelFunc:_Z};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class OZ{constructor(e,t,n){this.variableNames=["A"];const{windowSize:r,batchSize:s,outSize:a}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[s,a];const i="max"===t?">":"<",o=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${r}; i++) {\n          int inIdx = ${o};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${i} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class MZ{constructor(e,t,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,we(e.length>2,(()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`));const s=e[e.length-1],a=Math.ceil(s/t);this.outputShape=e.slice(0,-1),a>1&&this.outputShape.push(a),r||this.variableNames.push("bestIndicesA");const i=this.outputShape,o=i.length,u=QK(o),l=MY("coords",o);let c,h;if(1===a){h=o+1;const e=QK(h);c=`\n        ${e} sourceLocR = ${e}(${l.join()}, 0);\n        ++${l[o-1]};\n        ${e} sourceLocG = ${e}(${l.join()}, 0);\n        ++${l[o-2]};\n        ${e} sourceLocA = ${e}(${l.join()}, 0);\n        --${l[o-1]};\n        ${e} sourceLocB = ${e}(${l.join()}, 0);\n        --${l[o-2]};`}else h=o,c=`\n        ${u} sourceLocR = coords;\n        ++${l[o-1]};\n        ${u} sourceLocG = coords;\n        ++${l[o-2]};\n        ${u} sourceLocA = coords;\n        --${l[o-1]};\n        ${u} sourceLocB = coords;\n        --${l[o-2]};`;const p=["x","y","z","w","u","v"].slice(0,h),d="."+p[h-1],f=p.map((e=>"int "+e)),m=MY("sourceLocR",h-1).concat("inIdx.r"),g=MY("sourceLocG",h-1).concat("inIdx.g"),y=MY("sourceLocB",h-1).concat("inIdx.b"),b=MY("sourceLocA",h-1).concat("inIdx.a"),x="max"===n?"greaterThan":"lessThan",w=r?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${m.join()}),\n                             getBestIndicesAChannel(${g.join()}),\n                             getBestIndicesAChannel(${y.join()}),\n                             getBestIndicesAChannel(${b.join()})));`,v=`vec4(\n            getAChannel(${m.join()}),\n            hasNextCol ? getAChannel(${g.join()}) : 0.,\n            hasNextRow ? getAChannel(${y.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${b.join()}) : 0.)`,k=r?"":`\n      float getBestIndicesAChannel(${f.join()}) {\n        return getChannel(getBestIndicesA(${p.join()}),\n                                          vec2(${p.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${f.join()}) {\n        return getChannel(getA(${p.join()}),\n                               vec2(${p.slice(-2).join()}));\n      }\n      ${k}\n      void main() {\n        ${u} coords = getOutputCoords();\n        bool hasNextCol = ${l[o-1]} < ${i[o-1]-1};\n        bool hasNextRow = ${l[o-2]} < ${i[o-2]-1};\n        ${c}\n        ivec4 srcIdx = ivec4(sourceLocR${d}, sourceLocG${d},\n          sourceLocB${d}, sourceLocA${d}) * ${t};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${v};\n\n        for (int i = 0; i < ${t}; i++) {\n          inIdx = srcIdx;\n          ${w}\n          vec4 candidate = ${v};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${x}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function LZ(e,t,n,r=null){let s=t.shape[0],a=t.shape[1];null!=r&&(s=r.shape[0],a=r.shape[1]);const i=Pw(a),o={windowSize:i,inSize:a,batchSize:s,outSize:Math.ceil(a/i)},u=new OZ(o,n,null==r),l=[t];null!=r&&l.push(r);const c=e.runWebGLProgram(u,l,"int32");if(1===c.shape[1])return c;const h=LZ(e,t,n,c);return e.disposeIntermediateTensorInfo(c),h}function zZ(e,t,n,r=null){const s=null!=r?r.shape:t.shape,a=s[s.length-1],i=Pw(a),o=new MZ(s,i,n,null==r),u=null==r?[t]:[t,r],l=e.runWebGLProgram(o,u,"int32");if(l.shape.length===t.shape.length){const r=zZ(e,t,n,l);return e.disposeIntermediateTensorInfo(l),r}return l}function PZ(e,t,n,r){const s=[n];if(Pd("arg"+r.charAt(0).toUpperCase()+r.slice(1),s,t.shape.length),!ht().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const n=[],a=e.texData.get(t.dataId),i=null!==a&&a.isPacked;let o=t;i&&(o=e.unpackTensor(t),n.push(o));const[u,l]=Ld(o.shape,s),c=Ie(l),h=YJ({inputs:{x:o},backend:e,attrs:{shape:[-1,c]}});n.push(h);const p=LZ(e,h,r);n.push(p);const d=YJ({inputs:{x:p},backend:e,attrs:{shape:u}});return n.forEach((t=>e.disposeIntermediateTensorInfo(t))),d}return zZ(e,t,r)}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function BZ(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r;let i=De(a,s.shape);const o=Bd(i,s.shape.length);let u=s;const l=[];null!=o&&(u=lZ({inputs:{x:s},backend:n,attrs:{perm:o}}),l.push(u),i=Vd(i.length,u.shape.length)),Pd("argMax",[i[0]],u.shape.length);const c=PZ(n,u,i[0],"max");return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),c}const WZ={kernelName:St,backendName:"webgl",kernelFunc:BZ};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function VZ(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r;let i=De(a,s.shape);const o=Bd(i,s.shape.length);let u=s;const l=[];null!=o&&(u=lZ({inputs:{x:s},backend:n,attrs:{perm:o}}),l.push(u),i=Vd(i.length,u.shape.length)),Pd("argMin",[i[0]],u.shape.length);const c=PZ(n,u,i[0],"min");return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),c}const UZ={kernelName:Tt,backendName:"webgl",kernelFunc:VZ},GZ=XY+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n",HZ=BJ({opSnippet:GZ}),jZ={kernelName:$t,backendName:"webgl",kernelFunc:HZ},qZ=XY+"return log(x + sqrt(x * x + 1.0));",KZ=BJ({opSnippet:qZ}),XZ={kernelName:Ct,backendName:"webgl",kernelFunc:KZ},YZ=XY+"\n  return atan(x);\n",JZ=BJ({opSnippet:YZ}),ZZ={kernelName:Et,backendName:"webgl",kernelFunc:JZ},QZ=IJ+"\n  return atan(a, b);\n",eQ="\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+SJ+"\n  return result;\n",tQ=WJ({opSnippet:QZ,packedOpSnippet:eQ}),nQ={kernelName:At,backendName:"webgl",kernelFunc:tQ},rQ=XY+"\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;",sQ=BJ({opSnippet:rQ}),aQ={kernelName:Rt,backendName:"webgl",kernelFunc:sQ};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class iQ{constructor(e,t,n,r=!1,s=!1){if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const a=e.filterWidth,i=e.strideHeight,o=e.strideWidth,u=e.dilationHeight,l=e.dilationWidth,c=e.effectiveFilterHeight,h=e.effectiveFilterWidth,p=e.padInfo.top,d=e.padInfo.left;this.outputShape=e.outShape;const f="avg"===t,m=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,g=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let y="0.0";if(f||(y="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode=`\n        const ivec2 strides = ivec2(${i}, ${o});\n        const ivec2 pads = ivec2(${p}, ${d});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${c};\n              wR += ${u}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${h};\n                wC += ${l}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ${t} currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${r?s?m:g:`wR * ${h} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}const b="max";let x=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(x="avgValue / max(count, 1.0)");const w=4*Math.floor(a/4),v=a%4,k=`\n      if (${f}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ${b}(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${i}, ${o});\n      const ivec2 pads = ivec2(${p}, ${d});\n      const float initializationValue = ${y};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${y});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${c};\n            wR += ${u}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${w}; wC += 4) {\n            int xC = xCCorner + wC * ${l};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${l}, d),\n              getValue(batch, xR, xC + 2 * ${l}, d),\n              getValue(batch, xR, xC + 3 * ${l}, d)\n            );\n\n            ${k}\n          }\n\n          int xC = xCCorner + ${w};\n          if (${1===v}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${k}\n          } else if (${2===v}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${l}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${k}\n          } else if (${3===v}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${l}, d),\n              getValue(batch, xR, xC + 2 * ${l}, d),\n              initializationValue\n            );\n\n            ${k}\n          }\n        }\n        setOutput(${x});\n      }\n    `}}class oQ{constructor(e,t,n,r=!1,s=!1){if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const a=e.filterWidth,i=e.strideDepth,o=e.strideHeight,u=e.strideWidth,l=e.dilationDepth,c=e.dilationHeight,h=e.dilationWidth,p=e.effectiveFilterDepth,d=e.effectiveFilterHeight,f=e.effectiveFilterWidth,m=e.padInfo.front,g=e.padInfo.top,y=e.padInfo.left;this.outputShape=e.outShape;const b="avg"===t;let x="0.0";if(b||(x="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${i}, ${o}, ${u});\n        const ivec3 pads = ivec3(${m}, ${g}, ${y});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${p};\n              wD += ${l}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${d};\n                wR += ${c}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${f};\n                  wC += ${h}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ${t} currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${r?s?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${d} * ${f} +\n                      wR * ${f} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}const w="max";let v=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(v="avgValue / max(count, 1.0)");const k=4*Math.floor(a/4),I=a%4,N=`\n      if (${b}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ${w}(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${i}, ${o}, ${u});\n      const ivec3 pads = ivec3(${m}, ${g}, ${y});\n      const float initializationValue = ${x};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${x});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${p};\n            wD += ${l}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${d};\n            wR += ${c}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${k}; wC += 4) {\n              int xC = xCCorner + wC * ${h};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${h}, ch)\n              );\n\n              ${N}\n            }\n\n            int xC = xCCorner + ${k};\n            if (${1===I}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${N}\n            } else if (${2===I}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${N}\n            } else if (${3===I}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                initializationValue\n              );\n\n              ${N}\n            }\n          }\n        }\n        setOutput(${v});\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function uQ(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;tK(s,"avgPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:u}=r,l=1;we(Gh(i,l),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${l}'`));const c=Rh(s.shape,a,i,l,o,u);if(1===c.filterWidth&&1===c.filterHeight&&Te(c.inShape,c.outShape))return $J({inputs:{x:s},backend:n});const h=new iQ(c,"avg",!1);return n.runWebGLProgram(h,[s],"float32")}const lQ={kernelName:Ft,backendName:"webgl",kernelFunc:uQ};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function cQ(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:u,dataFormat:l}=r,c=[1,1,1],h=Ah(s.shape,a,i,c,o,u,l),p=new oQ(h,"avg",!1);return n.runWebGLProgram(p,[s],"float32")}const hQ={kernelName:Dt,backendName:"webgl",kernelFunc:cQ};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class pQ{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,s=e.strideWidth,a=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterHeight,u=e.effectiveFilterWidth,l=o-1-e.padInfo.top,c=u-1-e.padInfo.left,h=1/(t*n);this.userCode=`\n      const ivec2 pads = ivec2(${l}, ${c});\n      const float avgMultiplier = float(${h});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${o};\n            wR += ${a}) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${u};\n            wC+= ${i}) {\n            float dyC = float(dyCCorner + wC) / ${s}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class dQ{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,s=e.strideDepth,a=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,u=e.dilationHeight,l=e.dilationWidth,c=e.effectiveFilterDepth,h=e.effectiveFilterHeight,p=e.effectiveFilterWidth,d=c-1-e.padInfo.front,f=h-1-e.padInfo.top,m=p-1-e.padInfo.left,g=1/(t*n*r);this.userCode=`\n      const ivec3 pads = ivec3(${d}, ${f}, ${m});\n      const float avgMultiplier = float(${g});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${c};\n            wD += ${o}) {\n          float dyD = float(dyDCorner + wD) / ${s}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${h};\n              wR += ${u}) {\n            float dyR = float(dyRCorner + wR) / ${a}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${p};\n                wC += ${l}) {\n              float dyC = float(dyCCorner + wC) / ${i}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function fQ(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a,{filterSize:o,strides:u,pad:l,dimRoundingMode:c}=r,h=[1,1,1],p=Ah(i.shape,o,u,h,l,c),d=new dQ(p);return n.runWebGLProgram(d,[s],i.dtype)}const mQ={kernelName:Ot,backendName:"webgl",kernelFunc:fQ};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function gQ(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a;tK([s,a],"avgPoolGrad");const{filterSize:o,strides:u,pad:l}=r,c=Rh(i.shape,o,u,1,l),h=new pQ(c);return n.runWebGLProgram(h,[s],i.dtype)}const yQ={kernelName:_t,backendName:"webgl",kernelFunc:gQ};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function bQ(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:a}=t,{transposeA:i,transposeB:o}=r;return pZ({a:s,b:a,transposeA:i,transposeB:o,backend:n})}const xQ={kernelName:Mt,backendName:"webgl",kernelFunc:bQ};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class wQ{constructor(e,t,n,r,s,a){this.outputShape=[],this.variableNames=["x","mean","variance"],ul(e,t),ul(e,n);let i="0.0";null!=r&&(ul(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="1.0";null!=s&&(ul(e,s),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${i};\n        float scale = ${o};\n        float inv = scale * inversesqrt(variance + float(${a}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class vQ{constructor(e,t,n,r,s,a){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],ul(e,t),ul(e,n);let i="vec4(0.0)";null!=r&&(ul(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="vec4(1.0)";null!=s&&(ul(e,s),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        vec4 offset = ${i};\n        vec4 scale = ${o};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${a}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const kQ=({inputs:e,backend:t,attrs:n})=>{const{x:r,mean:s,variance:a,offset:i,scale:o}=e;we(s.shape.length===a.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),we(null==i||s.shape.length===i.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),we(null==o||s.shape.length===o.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));let{varianceEpsilon:u}=n;null==u&&(u=.001);const l=[r,s,a];let c=null;null!=i&&(c=i.shape,l.push(i));let h=null;null!=o&&(h=o.shape,l.push(o));const p=ht().getBool("WEBGL_PACK_NORMALIZATION")?new vQ(r.shape,s.shape,a.shape,c,h,u):new wQ(r.shape,s.shape,a.shape,c,h,u),d=t.runWebGLProgram(p,l,l[0].dtype);return d},IQ={kernelName:Rn,backendName:"webgl",kernelFunc:kQ};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class NQ{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=QK(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=TQ(this.rank);let r;const s=e.map(((e,t)=>`sourceLoc.${SQ[t]} = start[${t}] + coords.${SQ[t]};`));r=`\n        ${t} sourceLoc;\n        ${t} coords = getOutputCoords();\n        ${s.join("\n")}\n      `,this.userCode=`\n      void main() {\n        ${r}\n        setOutput(getSource(${n}));\n      }\n    `}}const SQ=["x","y","z","w","u","v"];function TQ(e){if(1===e)return"sourceLoc";if(e<=6)return SQ.slice(0,e).map((e=>"sourceLoc."+e)).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class $Q{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=QK(this.rank),n=MY("coords",this.rank),r=MY("sourceLoc",this.rank),s=1===this.rank?"sourceLoc":`vec2(${r.slice(-2).join()})`,a=`getChannel(getSource(${r.join()}), ${s})`,i=`\n      result.x = ${a};\n      if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n        ++${r[this.rank-1]};\n        result.y = ${a};\n        --${r[this.rank-1]};\n      }\n    `,o=1===this.rank?"":`\n      --${n[this.rank-1]};\n      if (++${n[this.rank-2]} < ${e[this.rank-2]}) {\n        ++${r[this.rank-2]};\n        result.z = ${a};\n        if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n          ++${r[this.rank-1]};\n          result.w = ${a};\n        }\n      }\n    `,u=this.rank<=4?`sourceLoc = coords +\n            ${t}(${e.map(((e,t)=>`start[${t}]`)).join()});`:e.map(((e,t)=>`${r[t]} = ${n[t]} + start[${t}];`)).join("\n");this.userCode=`\n      void main() {\n        ${t} coords = getOutputCoords();\n        ${t} sourceLoc;\n        ${u}\n        vec4 result = vec4(0.);\n        ${i}\n        ${o}\n        setOutput(result);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function CQ(e,t,n,r){const s=r.texData.get(e.dataId),a=r.makeTensorInfo(n,e.dtype),i=r.texData.get(a.dataId);Object.assign(i,s),i.refCount=1,i.shape=n,i.dtype=e.dtype;let o=zc(t,Xe(e.shape));s.slice&&(o+=s.slice.flatOffset),i.slice={flatOffset:o,origDataId:s.slice&&s.slice.origDataId||e.dataId};const u=r.dataRefCount.get(i.slice.origDataId)||1;return r.dataRefCount.set(i.slice.origDataId,u+1),a}function EQ(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,size:i}=r,[o,u]=Pc(s,a,i);if(Sc(s,o,u),0===Ie(u))return n.makeTensorInfo(u,s.dtype,[]);if(n.shouldExecuteOnCPU([s])||"string"===s.dtype){const e=n.texData.get(s.dataId),t=wY(e.values,o,u,s.shape,s.dtype);return n.makeTensorInfo(u,s.dtype,t)}const{isPacked:l}=n.texData.get(s.dataId),c=Lc(s.shape,o,u);if(l||!c){const e=ht().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new $Q(u):new NQ(u),t=[o];return n.runWebGLProgram(e,[s],s.dtype,t)}return n.uploadToGPU(s.dataId),CQ(s,o,u,n)}const RQ={kernelName:Yr,backendName:"webgl",kernelFunc:EQ},AQ=e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,crops:i}=r;we(s.shape.length<=4,(()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet"));const o=a.reduce(((e,t)=>e*t)),u=Ww(s.shape,a,o),l=Vw(u.length,a.length),c=Uw(s.shape,a,o),h=Gw(i,a.length),p=Hw(c,i,a.length),d=[],f=YJ({inputs:{x:s},backend:n,attrs:{shape:u}}),m=lZ({inputs:{x:f},backend:n,attrs:{perm:l}}),g=YJ({inputs:{x:m},backend:n,attrs:{shape:c}}),y=EQ({inputs:{x:g},backend:n,attrs:{begin:h,size:p}});return d.push(f),d.push(m),d.push(g),d.forEach((e=>n.disposeIntermediateTensorInfo(e))),y},FQ={kernelName:Lt,backendName:"webgl",kernelFunc:AQ};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function _Q(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i}=r,o=n.readSync(s.dataId),u=n.readSync(a.dataId),l=WX(o,u,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,l)}const DQ={kernelName:zt,backendName:"webgl",kernelFunc:_Q},OQ="\n  int r = int(a.r) & int(b.r);\n  int g = int(a.g) & int(b.g);\n  int rb = int(a.b) & int(b.b);\n  int ra = int(a.a) & int(b.a);\n  return vec4(r, g, rb, ra);\n",MQ="\n  return float(int(a.r) & int(b.r));\n";function LQ(e){const{inputs:t,backend:n}=e,{a:r,b:s}=t,a=ht().getBool("WEBGL_PACK_BINARY_OPERATIONS"),i=ht().getNumber("WEBGL_VERSION");if(n.shouldExecuteOnCPU([r,s])||1===i){const e=n.texData.get(r.dataId).values,t=n.texData.get(s.dataId).values,[a,i]=UX(r.shape,s.shape,e,t,r.dtype),o=n.makeTensorInfo(i,r.dtype),u=n.texData.get(o.dataId);return u.values=a,o}let o;return o=a?new TJ(OQ,r.shape,s.shape,!1):new NJ(MQ,r.shape,s.shape),n.runWebGLProgram(o,[r,s],r.dtype)}const zQ={kernelName:Pt,backendName:"webgl",kernelFunc:LQ};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function PQ(e){const{inputs:t,backend:n}=e,{s0:r,s1:s}=t,a=n.readSync(r.dataId),i=n.readSync(s.dataId),o=ul(Array.from(a),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}const BQ={kernelName:Wt,backendName:"webgl",kernelFunc:PQ},WQ="return float(a != b);",VQ=WJ({opSnippet:WQ,cpuKernelImpl:cY,dtype:"bool"}),UQ={kernelName:yr,backendName:"webgl",kernelFunc:VQ};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function GQ(e){const{inputs:t,backend:n}=e,{input:r}=t,s=n.texData.get(r.dataId);return $J({inputs:{x:s.complexTensorInfos.real},backend:n})}const HQ={kernelName:_r,backendName:"webgl",kernelFunc:GQ},jQ="return float(int(x));";function qQ(e,t){const n=new KY(e.shape,jQ),r=t.runWebGLProgram(n,[e],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function KQ(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dtype:a}=r;if("complex64"===a){if("complex64"===s.dtype)return $J({inputs:{x:s},backend:n});const e=pm(s.shape),t=KQ({inputs:{x:s},backend:n,attrs:{dtype:"float32"}}),r=EJ({inputs:{real:t,imag:e},backend:n});return e.dispose(),n.disposeIntermediateTensorInfo(t),r}if("complex64"===s.dtype){const e=GQ({inputs:{input:s},backend:n}),t=KQ({inputs:{x:e},backend:n,attrs:{dtype:a}});return n.disposeIntermediateTensorInfo(e),t}if(!Be(s.dtype,a)){const e=$J({inputs:{x:s},backend:n});return{dataId:e.dataId,shape:e.shape,dtype:a}}if(n.shouldExecuteOnCPU([s])){const e=n.texData.get(s.dataId).values,[t,r,i]=GX(e,s.shape,s.dtype,a);return n.makeTensorInfo(t,r,i)}if("int32"===a)return qQ(s,n);if("bool"===a){const e=n.makeTensorInfo([],"bool",Me("bool",1)),t={a:s,b:e},r=VQ({inputs:t,backend:n});return n.disposeIntermediateTensorInfo(e),r}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${a}`)}const XQ={kernelName:Vt,backendName:"webgl",kernelFunc:KQ},YQ="return ceil(x);",JQ=BJ({opSnippet:YQ,packedOpSnippet:YQ,cpuKernelImpl:HX}),ZQ={kernelName:Ut,backendName:"webgl",kernelFunc:JQ};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class QQ{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class e0{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function t0(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{clipValueMin:a,clipValueMax:i}=r;let o;o=ht().getBool("WEBGL_PACK_CLIP")?new e0(s.shape):new QQ(s.shape);const u=[[a],[i]];return n.runWebGLProgram(o,[s],s.dtype,u)}const n0={kernelName:Gt,backendName:"webgl",kernelFunc:t0};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class r0{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function s0(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}function a0(e){const{inputs:t,backend:n}=e,{x:r}=t,s=n.texData.get(r.dataId),a=new r0(r.shape),i=[s0(r,s.complexTensorInfos.real),s0(r,s.complexTensorInfos.imag)];return n.runWebGLProgram(a,i,i[0].dtype)}const i0={kernelName:jt,backendName:"webgl",kernelFunc:a0};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class o0{constructor(e){this.outputShape=[],this.outputShape=Fw(e,1),this.variableNames=e.map(((e,t)=>`T${t}`));const t=new Array(e.length-1);t[0]=e[0][1];for(let a=1;a<t.length;a++)t[a]=t[a-1]+e[a][1];const n=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let a=1;a<t.length;a++){const e=t[a-1];n.push(`else if (yC < ${t[a]}) setOutput(getT${a}(yR, yC-${e}));`)}const r=t.length,s=t[t.length-1];n.push(`else setOutput(getT${r}(yR, yC-${s}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${n.join("\n        ")}\n      }\n    `}}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class u0{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=Fw(e,t);const n=this.outputShape,r=n.length,s=QK(r),a=MY("coords",r),i=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map(((e,t)=>`T${t}`));const o=new Array(e.length-1);o[0]=e[0][t];for(let f=1;f<o.length;f++)o[f]=o[f-1]+e[f][t];const u=i[t],l=i.slice(-2),c=i.join();let h=`if (${u} < ${o[0]}) {\n        return getChannel(\n            getT0(${c}), vec2(${l.join()}));\n        }`;for(let f=1;f<o.length;f++){const e=o[f-1];h+=`\n        if (${u} < ${o[f]}  && ${u} >= ${o[f-1]}) {\n          return getChannel(\n            getT${f}(${l0(i,u,e)}),\n            vec2(${l0(l,u,e)}));\n        }`}const p=o.length,d=o[o.length-1];h+=`\n        return getChannel(\n          getT${p}(${l0(i,u,d)}),\n          vec2(${l0(l,u,d)}));`,this.userCode=`\n      float getValue(${i.map((e=>"int "+e))}) {\n        ${h}\n      }\n\n      void main() {\n        ${s} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${a}), 0., 0., 0.);\n\n        ${a[r-1]} = ${a[r-1]} + 1;\n        if (${a[r-1]} < ${n[r-1]}) {\n          result.g = getValue(${a});\n        }\n\n        ${a[r-2]} = ${a[r-2]} + 1;\n        if (${a[r-2]} < ${n[r-2]}) {\n          result.a = getValue(${a});\n        }\n\n        ${a[r-1]} = ${a[r-1]} - 1;\n        if (${a[r-2]} < ${n[r-2]} &&\n            ${a[r-1]} < ${n[r-1]}) {\n          result.b = getValue(${a});\n        }\n        setOutput(result);\n      }\n    `}}function l0(e,t,n){const r=e.indexOf(t),s=e.map(((e,t)=>t===r?`${e} - ${n}`:e));return s.join()}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function c0(e){const{inputs:t,backend:n}=e,{input:r}=t,s=n.texData.get(r.dataId);return $J({inputs:{x:s.complexTensorInfos.imag},backend:n})}const h0={kernelName:Ln,backendName:"webgl",kernelFunc:c0};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function p0(e,t,n){const r=e[0].dtype;if("complex64"===r){const r=e.map((e=>GQ({inputs:{input:e},backend:n}))),s=e.map((e=>c0({inputs:{input:e},backend:n}))),a=p0(r,t,n),i=p0(s,t,n),o=EJ({inputs:{real:a,imag:i},backend:n});return r.forEach((e=>n.disposeIntermediateTensorInfo(e))),s.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),o}let s=n.shouldExecuteOnCPU(e);if("string"===r&&(s=!0),s){const s=e.map((e=>{const r=Ie(e.shape.slice(t)),s=[-1,r];return YJ({inputs:{x:e},backend:n,attrs:{shape:s}})})),a=s.map((e=>({vals:n.readSync(e.dataId),shape:e.shape}))),i=Fw(s.map((e=>e.shape)),1),o=1===s[0].shape[0],u=jX(a,i,r,o),l=Fw(e.map((e=>e.shape)),t),c=n.makeTensorInfo(l,r,u);return s.forEach((e=>n.disposeIntermediateTensorInfo(e))),c}const a=e.filter((e=>Ie(e.shape)>0)),i=ht().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&a[0].shape.length>1;if(1===a.length){const t=i?new KY(e[0].shape,tJ):new uJ(e[0].shape,tJ);return n.runWebGLProgram(t,e,r)}const o=ht().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(a.length>o){const e=[];for(let s=0;s<a.length;s+=o){const r=a.slice(s,s+o);e.push(p0(r,t,n))}const r=p0(e,t,n);for(const t of e)n.disposeIntermediateTensorInfo(t);return r}if(i){const e=new u0(a.map((e=>e.shape)),t);return n.runWebGLProgram(e,a,r)}const{tensors2D:u,outShape:l}=d0(a,t,n),c=new o0(u.map((e=>e.shape))),h=n.runWebGLProgram(c,u,r);u.forEach((e=>n.disposeIntermediateTensorInfo(e)));const p=YJ({inputs:{x:h},attrs:{shape:l},backend:n});return n.disposeIntermediateTensorInfo(h),p}function d0(e,t,n){const r=Fw(e.map((e=>e.shape)),t),s=e.map((e=>YJ({inputs:{x:e},attrs:{shape:[-1,Ie(e.shape.slice(t))]},backend:n})));return{tensors2D:s,outShape:r}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function f0(e){const{inputs:t,backend:n,attrs:r}=e,{axis:s}=r,a=De(s,t[0].shape)[0],i=t.map((e=>e.shape));Aw(i,a);const o=Fw(t.map((e=>e.shape)),a);if(0===Ie(o))return n.makeTensorInfo(o,t[0].dtype,[]);const u=t.filter((e=>Ie(e.shape)>0));return 1===u.length?$J({inputs:{x:u[0]},backend:n}):p0(u,a,n)}const m0={kernelName:qt,backendName:"webgl",kernelFunc:f0};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class g0{constructor(e,t=!1,n=null,r=!1,s=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const a=e.padInfo.top,i=e.padInfo.left,o=e.strideHeight,u=e.strideWidth,l=e.dilationHeight,c=e.dilationWidth,h=e.filterHeight,p=e.filterWidth,d=4*Math.floor(e.inChannels/4),f=e.inChannels%4,m="channelsLast"===e.dataFormat,g=m?1:2,y=m?2:3,b=m?3:1;let x="",w="";n&&(x=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:s?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,w="result = activation(result);");const v=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${x}\n\n      const ivec2 strides = ivec2(${o}, ${u});\n      const ivec2 pads = ivec2(${a}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${b}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${g}], coords[${y}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${h}; wR++) {\n          int xR = xRCorner + wR * ${l};\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${p}; wC++) {\n            int xC = xCCorner + wC * ${c};\n\n            if (xC < 0 || xC >= ${e.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${d}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${m}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===f}) {\n\n              if (${m}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${d}) *\n                    getW(wR, wC, ${d}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${d}, xR, xC) *\n                    getW(wR, wC, ${d}, d2);\n              }\n\n            } else if (${2===f}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${d}, d2),\n                getW(wR, wC, ${d} + 1, d2)\n              );\n\n              if (${m}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${d}),\n                  getX(batch, xR, xC, ${d} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${d}, xR, xC),\n                  getX(batch, ${d} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===f}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${d}, d2),\n                getW(wR, wC, ${d} + 1, d2),\n                getW(wR, wC, ${d} + 2, d2)\n              );\n\n              if (${m}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${d}),\n                  getX(batch, xR, xC, ${d} + 1),\n                  getX(batch, xR, xC, ${d} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${d}, xR, xC),\n                  getX(batch, ${d} + 1, xR, xC),\n                  getX(batch, ${d} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${v}\n        ${w}\n        setOutput(result);\n      }\n    `}}class y0{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,n=e.padInfo.top,r=e.padInfo.left,s=e.strideDepth,a=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,u=e.dilationHeight,l=e.dilationWidth,c=e.filterDepth,h=e.filterHeight,p=e.filterWidth,d=4*Math.floor(e.inChannels/4),f=e.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${s}, ${a}, ${i});\n      const ivec3 pads = ivec3(${t}, ${n}, ${r});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${c}; wF++) {\n          int xF = xFCorner + wF * ${o};\n\n          if (xF < 0 || xF >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${h}; wR++) {\n            int xR = xRCorner + wR * ${u};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${p}; wC++) {\n              int xC = xCCorner + wC * ${l};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${d}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===f}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${d}) *\n                  getW(wF, wR, wC, ${d}, d2);\n              } else if (${2===f}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${d}),\n                  getX(batch, xF, xR, xC, ${d} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${d}, d2),\n                  getW(wF, wR, wC, ${d} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===f}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${d}),\n                  getX(batch, xF, xR, xC, ${d} + 1),\n                  getX(batch, xF, xR, xC, ${d} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${d}, d2),\n                  getW(wF, wR, wC, ${d} + 1, d2),\n                  getW(wF, wR, wC, ${d} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class b0{constructor(e,t=!1,n=null,r=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=uX(this.outputShape.length);const a=e.padInfo.left,i=e.strideWidth,o=e.dilationWidth,u=e.filterHeight,l=e.filterWidth,c=l;let h="\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;";for(let m=0;m<l;m++)h+=`\n           vec4 xTexelC${2*m};\n           int xTexelC${2*m}Ready;\n           vec4 xTexelC${2*m+1};\n           int xTexelC${2*m+1}Ready;\n           vec4 xC${m};`;h+=`\n     for (int r = 0; r < ${u}; r++) {\n      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {\n       `;for(let m=0;m<l;m++)h+=`\n           xTexelC${2*m} = vec4(0.0);\n           xTexelC${2*m}Ready = 0;\n           xTexelC${2*m+1} = vec4(0.0);\n           xTexelC${2*m+1}Ready = 0;\n           xC${m} = vec4(0.0);`;h+="\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       ";for(let m=0;m<(c+1)/2;m++){const t=2*m;if(h+=`\n           xC = xCCorner + ${t*o};\n           `,1===i){if(t<l&&(a%2===1?(h+=`\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                   xTexelC${t} = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${t}.zw = vec2(0.0);\n                   }\n                   xTexelC${t}Ready = 1;\n                 }\n               `,h+=1===o&&t>0?`\n                 xC${t} = vec4(xTexelC${t-2}.zw, xTexelC${t}.xy);\n                 `:`\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC${t} = vec4(previous.zw, xTexelC${t}.xy);\n                   } else {\n                     xC${t} = vec4(0.0, 0.0, xTexelC${t}.xy);\n                   }\n                   `):h+=`\n                 if (xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {\n                   xTexelC${t} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${t}.zw = vec2(0.0);\n                   }\n                   xTexelC${t}Ready = 1;\n                 }\n\n                 xC${t} = xTexelC${t};\n                 `,t+1<l)){const e=a%2===0?me(o):o;o%2===0&&a%2===1||o%2!==0&&a%2!==1?(h+=`\n                   xCOffset = xC + imod(pads[1], 2) + ${e};\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                     xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC${t+1}.zw = vec2(0.0);\n                     }\n                     xTexelC${t+1}Ready = 1;\n                   }\n                   `,h+=o>1?`\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC${t+1} = vec4(previous.zw, xTexelC${t+1}.xy);\n                     } else {\n                      xC${t+1} = vec4(0.0, 0.0, xTexelC${t+1}.xy);\n                     }\n                     `:`\n                     xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.xy);\n                     `):h+=1===e?`\n                     xC${t+1} = xTexelC${t};\n                     `:`\n                     xCOffset = xC + ${e};\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                       xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC${t+1}.zw = vec2(0.0);\n                       }\n                       xTexelC${t+1}Ready = 1;\n                     }\n\n                     xC${t+1} = xTexelC${t+1};\n                     `}}else t<l&&(a%2===1?(h+=`\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                   xTexelC${t} = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${t}.zw = vec2(0.0);\n                   }\n                   xTexelC${t}Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${t+1}Ready == 0) {\n                   xTexelC${t+1} = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC${t+1}.zw = vec2(0.0);\n                   }\n                   xTexelC${t+1}Ready = 1;\n                 }\n\n                 xC${t} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);\n               `,t+1<l&&(h+=`\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC${t+1} = vec4(xTexelC${t+1}.xy, final.xy);\n                 `)):(h+=`\n                 if(xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {\n                   xTexelC${t} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${t}.zw = vec2(0.0);\n                   }\n                   xTexelC${t}Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                   xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${t+1}.zw = vec2(0.);\n                   }\n                   xTexelC${t+1}Ready = 1;\n                 }\n\n                 xC${t} = vec4(\n                   xTexelC${t}.xy, xTexelC${t+1}.xy);\n               `,t+1<l&&(h+=`\n                   xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);\n                 `)));t<l&&(h+=`\n             wTexel = getW(r, ${t}, d1, d2);\n             dotProd += xC${t}.xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ${e.inChannels}) {\n               dotProd += xC${t}.yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           `,t+1<l&&(h+=`\n               wTexel = getW(r, ${t+1}, d1, d2);\n               dotProd += xC${t+1}.xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ${e.inChannels}) {\n                 dotProd += xC${t+1}.yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             `))}h+="\n     }\n   ",h+="\n     }\n   ",h+="\n     }\n   ";let p="",d="";n&&(p=r?`vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ${n}\n         }`:s?`vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ${n}\n         }`:`vec4 activation(vec4 x) {\n           ${n}\n         }`,d="result = activation(result);");const f=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n       ${p}\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ${h}\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ${f}\n         ${d}\n         setOutput(result);\n       }\n     `}}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class x0{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=uX(this.outputShape.length);const{dataFormat:n}=t,r=rK(),s="channelsLast"===n,a=s?1:2,i=s?2:3,o=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`;let u="";for(let l=0;l<=1;l++)for(let e=0;e<=1;e++)u+=`\n          blockIndex = rc.z + ${e};\n          pos = rc.y + ${l};\n\n          ${o}\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[${a}] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[${i}] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (${s}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*l+e}] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*l+e}] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${u}\n\n        ${r.output} = result;\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function w0(e,t){const n=e.length;return n>=3?t?[...e.slice(0,-3),e[n-3]*e[n-2],e[n-1]]:[...e.slice(0,-3),e[n-3],e[n-2]*e[n-1]]:!t&&1===n&&e[0]>1?[e[0],1]:null}function v0({x:e,filter:t,convInfo:n,backend:r,bias:s=null,preluActivationWeights:a=null,leakyreluAlpha:i=0,activation:o=null}){const u=e.shape,l=r.texData.get(e.dataId),c=n.inChannels,h=u[0]*u[1]*u[2],p=n.outChannels,d="channelsLast"===n.dataFormat,f=!1,m=!1;let g;const y=[];if(null!=a){const e=w0(a.shape,d);null!=e&&(a=YJ({inputs:{x:a},backend:r,attrs:{shape:e}}),y.push(a))}if(null!=s){const e=w0(s.shape,d);null!=e&&(s=YJ({inputs:{x:s},backend:r,attrs:{shape:e}}),y.push(s))}const b=(1===h||1===p)&&c>hZ,x=!b&&l.isPacked&&d&&null!=l.texture&&u[2]%2!==0&&Te(l.shape.slice(-3),u.slice(-3));if(x){const c=u[0]*u[1]*(u[2]+1),h={dataId:e.dataId,shape:[1,c,n.inChannels],dtype:e.dtype},p=l.shape;l.shape=l.shape.slice(),l.shape[l.shape.length-2]++,we(Bq(l.shape,h.shape),(()=>`packed reshape ${l.shape} to ${h.shape} isn't free`));const d=YJ({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}});y.push(d);const b=pZ({a:h,b:d,backend:r,transposeA:f,transposeB:m,bias:s,activation:o,preluActivationWeights:a,leakyreluAlpha:i}),x=r.texData.get(b.dataId);we(x.isPacked,(()=>"batchMatMul result is expected to be packed")),l.shape=p,x.shape=n.outShape,g=$J({inputs:{x:b},backend:r}),g.shape=n.outShape,y.push(b)}else{const u=n.outHeight*n.outWidth,l=YJ({inputs:{x:e},backend:r,attrs:{shape:d?[n.batchSize,u,n.inChannels]:[n.batchSize,n.inChannels,u]}}),c=YJ({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}}),h=pZ({a:d?l:c,b:d?c:l,transposeA:!d,transposeB:m,backend:r,bias:s,activation:o,preluActivationWeights:a,leakyreluAlpha:i});g=YJ({inputs:{x:h},backend:r,attrs:{shape:n.outShape}}),y.push(l),y.push(c),y.push(h)}for(const w of y)r.disposeIntermediateTensorInfo(w);return g}function k0({x:e,filter:t,convInfo:n,backend:r,bias:s=null,preluActivationWeights:a=null,leakyreluAlpha:i=0,activation:o=null}){const{filterWidth:u,filterHeight:l,inChannels:c,outWidth:h,outHeight:p,dataFormat:d}=n,f="channelsLast"===d,m=u*l*c,g=p*h,y=[n.batchSize,m,g],b=!0,x=!1,w=[];if(null!=a){const e=w0(a.shape,f);null!=e&&(a=YJ({inputs:{x:a},backend:r,attrs:{shape:e}}),w.push(a))}if(null!=s){const e=w0(s.shape,f);null!=e&&(s=YJ({inputs:{x:s},backend:r,attrs:{shape:e}}),w.push(s))}const v=YJ({inputs:{x:t},backend:r,attrs:{shape:[1,m,Ie(t.shape)/m]}});w.push(v);const k=new x0(y,n),I=[e.shape,[n.padInfo.top,n.padInfo.left],[n.strideHeight,n.strideWidth],[n.dilationHeight,n.dilationWidth],[n.inChannels],[n.filterWidth*n.inChannels],[n.outWidth]],N=r.runWebGLProgram(k,[e],"float32",I),S=YJ({inputs:{x:N},backend:r,attrs:{shape:y}});w.push(N),w.push(S);const T=null!=s,$=null!=a,C="leakyrelu"===o,E=o?VJ(o,!0):null,R=new UJ(f?S.shape:v.shape,f?v.shape:S.shape,f?[n.batchSize,g,n.outChannels]:[n.batchSize,n.outChannels,g],b,x,T,E,$,C),A=f?[S,v]:[v,S];if(s&&A.push(s),$&&A.push(a),C){const e=r.makeTensorInfo([],"float32",ga(i,"float32"));A.push(e),w.push(e)}const F=r.runWebGLProgram(R,A,"float32"),_=YJ({inputs:{x:F},backend:r,attrs:{shape:n.outShape}});w.push(F);for(const D of w)r.disposeIntermediateTensorInfo(D);return _}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function I0(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dataFormat:u,dilations:l,dimRoundingMode:c}=r,h=jh(u),p=Fh(s.shape,a.shape,i,l,o,c,!1,h);let d;if(1!==p.filterHeight||1!==p.filterWidth||1!==p.dilationHeight||1!==p.dilationWidth||1!==p.strideHeight||1!==p.strideWidth||"SAME"!==p.padInfo.type&&"VALID"!==p.padInfo.type)if(p.strideWidth<=2&&"channelsLast"===h&&ht().getBool("WEBGL_EXP_CONV")){const e=new b0(p),t=[[p.padInfo.top,p.padInfo.left],[p.strideHeight,p.strideWidth],[p.dilationHeight,p.dilationWidth],[p.inHeight,p.inWidth]];d=n.runWebGLProgram(e,[s,a],"float32",t)}else if(ht().getBool("WEBGL_CONV_IM2COL"))d=k0({x:s,filter:a,convInfo:p,backend:n});else{const e=new g0(p);d=n.runWebGLProgram(e,[s,a],"float32")}else d=v0({x:s,filter:a,convInfo:p,backend:n});const f=YJ({inputs:{x:d},backend:n,attrs:{shape:p.outShape}});return n.disposeIntermediateTensorInfo(d),f}const N0={kernelName:Kt,backendName:"webgl",kernelFunc:I0};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class S0{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,s=e.padInfo.left,a="channelsLast"===e.dataFormat;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${r};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${s};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              ${a?"float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);":"float dyValue = getDy(b, d2, yR, yC);\n              float xValue = getX(b, d1, xR, xC);\n              dotProd += (xValue * dyValue);"}\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class T0{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,s=e.strideWidth,a="channelsLast"===e.dataFormat,i=t-1-e.padInfo.top,o=n-1-e.padInfo.left,u=a?1:2,l=a?2:3,c=a?3:1;this.userCode=`\n      const ivec2 pads = ivec2(${i}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${c}];\n\n        ivec2 dyCorner = ivec2(coords[${u}], coords[${l}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${s}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n\n              if (${a}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class $0{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,s=e.padInfo.front,a=e.padInfo.top,i=e.padInfo.left;this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yF = 0; yF < ${e.outDepth}; yF++) {\n            int xF = wF + yF * ${t} - ${s};\n\n            if (xF < 0 || xF >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${e.outHeight}; yR++) {\n              int xR = wR + yR * ${n} - ${a};\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${e.outWidth}; yC++) {\n                int xC = wC + yC * ${r} - ${i};\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class C0{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,s=e.strideDepth,a=e.strideHeight,i=e.strideWidth,o=t-1-e.padInfo.front,u=n-1-e.padInfo.top,l=r-1-e.padInfo.left;this.userCode=`\n      const ivec3 pads = ivec3(${o}, ${u}, ${l});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${t}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${s}.0;\n\n          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${t} - 1 - wF;\n\n          for (int wR = 0; wR < ${n}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${a}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${n} - 1 - wR;\n\n            for (int wC = 0; wC < ${r}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${i}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${r} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function E0(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,dataFormat:u,dimRoundingMode:l,filterShape:c}=r,h=jh(u),p=Fh(s.shape,c,i,1,o,l,!1,h),d=new S0(p);return n.runWebGLProgram(d,[s,a],"float32")}const R0={kernelName:Xt,backendName:"webgl",kernelFunc:E0};
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class A0{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=uX(this.outputShape.length);const t=e.filterHeight,n=e.filterWidth,r=t-1-e.padInfo.top,s=n-1-e.padInfo.left;this.userCode=`\n      const ivec2 pads = ivec2(${r}, ${s});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        vec4 result = vec4(0.);\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / strides[0];\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            int wCPerm = ${n} - 1 - wC;\n\n            float dyC = float(dyCCorner + wC) / strides[1];\n            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)\n              && (fract(dyC) == 0.0);\n            int idyC = int(dyC);\n\n            float dyC2 = float(dyCCorner + wC + 1) / strides[1];\n            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)\n              && (fract(dyC2) == 0.0);\n            int idyC2 = int(dyC2);\n\n            if (idyCVal && idyCVal2) {\n              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?\n                  dySample : getDy(batch, idyR, idyC2, d2);\n\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n\n                dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample2.xy : dySample2.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal) {\n              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal2) {\n              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC2, d2);\n                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            }\n          }\n        }\n        setOutput(result);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function F0(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{inputShape:i,strides:o,pad:u,dataFormat:l,dimRoundingMode:c}=r,h=jh(l),p=Fh(i,a.shape,o,1,u,c,!1,h);if(ht().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&"channelsLast"===h){const e=[[p.strideHeight,p.strideWidth]],t=new A0(p);return n.runWebGLProgram(t,[s,a],"float32",e)}{const e=new T0(p);return n.runWebGLProgram(e,[s,a],"float32")}}const _0={kernelName:Yt,backendName:"webgl",kernelFunc:F0};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function D0(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:u}=r,l=_h(s.shape,a.shape,i,u,o),c=new y0(l);return n.runWebGLProgram(c,[s,a],"float32")}const O0={kernelName:Jt,backendName:"webgl",kernelFunc:D0};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function M0(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,filterShape:u}=r,l=_h(s.shape,u,i,1,o),c=new $0(l);return n.runWebGLProgram(c,[s,a],"float32")}const L0={kernelName:Zt,backendName:"webgl",kernelFunc:M0};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function z0(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{pad:i,strides:o,inputShape:u}=r,l=_h(u,a.shape,o,1,i),c=new C0(l);return n.runWebGLProgram(c,[s,a],"float32")}const P0={kernelName:Qt,backendName:"webgl",kernelFunc:z0},B0=PJ+"\n  return cos(x);\n",W0=`\n  vec4 result = cos(x);\n  bvec4 isNaN = isnan(x);\n  ${SJ}\n  return result;\n`,V0=BJ({opSnippet:B0,packedOpSnippet:W0}),U0={kernelName:en,backendName:"webgl",kernelFunc:V0},G0="\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n",H0=BJ({opSnippet:G0}),j0={kernelName:tn,backendName:"webgl",kernelFunc:H0};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class q0{constructor(e,t,n,r,s){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[a,i,o,u]=e,[l]=t,[c,h]=n;this.outputShape=[l,c,h,u];const p="bilinear"===r?1:0,[d,f]=[i-1+".0",o-1+".0"],[m,g,y]=c>1?[""+(i-1)/(c-1),"(y2-y1) * height_ratio",`y1*${d} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${d}`],[b,x,w]=h>1?[""+(o-1)/(h-1),"(x2-x1) * width_ratio",`x1*${f} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${f}`];this.userCode=`\n      const float height_ratio = float(${m});\n      const float width_ratio = float(${b});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${a}) {\n          return;\n        }\n\n        float height_scale = ${g};\n        float width_scale = ${x};\n\n        float in_y = ${y};\n        if( in_y < 0.0 || in_y > ${d} ) {\n          setOutput(float(${s}));\n          return;\n        }\n        float in_x = ${w};\n        if( in_x < 0.0 || in_x > ${f} ) {\n          setOutput(float(${s}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${p} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const K0=e=>{const{inputs:t,backend:n,attrs:r}=e,{image:s,boxes:a,boxInd:i}=t,{cropSize:o,method:u,extrapolationValue:l}=r,c=new q0(s.shape,a.shape,o,u,l);return n.runWebGLProgram(c,[s,a,i],"float32")},X0={kernelName:sn,backendName:"webgl",kernelFunc:K0};var Y0;(function(e){e["Prod"]="*",e["Sum"]="+"})(Y0||(Y0={}));class J0{constructor(e,t,n,r){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const s=this.outputShape.length,a=this.op===Y0.Prod?"1.0":"0.0",i=n?a:`getX(${Z0(s,"coords",this.op)})`,o=this.outputShape[this.outputShape.length-1];let u="",l="";n?(u=r?"end != "+(o-1):"end != 0",l=r?"end + 1":"end - 1"):(u=r?`end + pow2 < ${o}`:"end >= pow2",l=r?"end + pow2":"end - pow2"),this.userCode=`\n      void main() {\n        ${QK(s)} coords = getOutputCoords();\n        int end = ${Q0(s,"coords",this.op)};\n        float val = ${i};\n        int pow2 = int(pow(2.0, index));\n        if (${u}) {\n          int idx = ${l};\n          ${Q0(s,"coords",this.op)} = idx;\n          val ${this.op}= getX(${Z0(s,"coords",this.op)});\n        }\n        setOutput(val);\n      }\n    `}}function Z0(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.x, ${t}.y`;if(3===e)return`${t}.x, ${t}.y, ${t}.z`;if(4===e)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function Q0(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.y`;if(3===e)return`${t}.z`;if(4===e)return`${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function e1(e,t,n,r,s,a){const i=t.shape.length,o=Bd([r],i);let u=t;null!=o&&(u=lZ({inputs:{x:t},backend:n,attrs:{perm:o}}));const l=Vd(1,i)[0];if(l!==i-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${r}`);const c=u.shape[l];let h=$J({inputs:{x:u},backend:n});for(let p=0;p<=Math.ceil(Math.log2(c))-1;p++){const t=new J0(e,u.shape,!1,a),r=[[p]],s=h;h=n.runWebGLProgram(t,[h],h.dtype,r),n.disposeIntermediateTensorInfo(s)}if(s){const t=new J0(e,u.shape,s,a),r=h;h=n.runWebGLProgram(t,[h],h.dtype),n.disposeIntermediateTensorInfo(r)}if(null!=o){const e=Wd(o),t=lZ({inputs:{x:h},backend:n,attrs:{perm:e}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(u),t}return h}
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function t1(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r;return e1(Y0.Prod,s,n,a,i,o)}const n1={kernelName:nn,backendName:"webgl",kernelFunc:t1};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function r1(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r;return e1(Y0.Sum,s,n,a,i,o)}const s1={kernelName:rn,backendName:"webgl",kernelFunc:r1};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function a1(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i,binaryOutput:o}=r;if(1===s.shape.length){const e=n.readSync(s.dataId),t=n.readSync(a.dataId),r=WX(e,t,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,r)}if(2===s.shape.length){const e=n.bufferSync(s),t=n.bufferSync(a),r=VX(e,t,i,o);return n.makeTensorInfo(r.shape,a.dtype,r.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}const i1={kernelName:an,backendName:"webgl",kernelFunc:a1};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class o1{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${t};\n      int offset_h = imod(h, ${t});\n      int in_w = w / ${t};\n      int offset_w = imod(w, ${t});\n      int offset_d = (offset_h * ${t} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function u1(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockSize:a,dataFormat:i}=r,o=s.shape[0],u="NHWC"===i?s.shape[1]:s.shape[2],l="NHWC"===i?s.shape[2]:s.shape[3],c="NHWC"===i?s.shape[3]:s.shape[1],h=u*a,p=l*a,d=c/(a*a),f="NHWC"===i?[o,h,p,d]:[o,d,h,p],m=new o1(f,a,i);return n.runWebGLProgram(m,[s],s.dtype)}const l1={kernelName:on,backendName:"webgl",kernelFunc:u1};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class c1{constructor(e,t=!1,n=null,r=!1,s=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=uX(this.outputShape.length);const a=e.filterHeight,i=e.filterWidth,o=e.outChannels/e.inChannels;let u="",l="";n&&(u=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:s?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,l="result = activation(result);");const c=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${u}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${o};\n        int q = d2 - d1 * ${o};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${a}; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${i}; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${c}\n        ${l}\n        setOutput(result);\n      }\n    `}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class h1{constructor(e,t=!1,n=null,r=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=uX(this.outputShape.length);const a=e.outChannels/e.inChannels,i=e.padInfo.left,o=e.strideWidth,u=e.dilationWidth,l=e.filterHeight,c=e.filterWidth,h=c;let p="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let g=0;g<c;g++)p+=`\n          vec4 xTexelC${2*g};\n          int xTexelC${2*g}Ready;\n          vec4 xTexelC${2*g+1};\n          int xTexelC${2*g+1}Ready;\n          vec4 xC${g};`;p+=`\n    for (int r = 0; r < ${l}; r++) {\n      `;for(let g=0;g<c;g++)p+=`\n          xTexelC${2*g} = vec4(0.0);\n          xTexelC${2*g}Ready = 0;\n          xTexelC${2*g+1} = vec4(0.0);\n          xTexelC${2*g+1}Ready = 0;\n          xC${g} = vec4(0.0);`;p+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let g=0;g<(h+1)/2;g++){const e=2*g;if(p+=`\n          xC = xCCorner + ${e*u};\n          `,1===o){if(e<c&&(i%2===1?(p+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n              `,p+=1===u&&e>0?`\n                xC${e} = vec4(xTexelC${e-2}.zw, xTexelC${e}.xy);\n                `:`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${e} = vec4(previous.zw, xTexelC${e}.xy);\n                  } else {\n                    xC${e} = vec4(0.0, 0.0, xTexelC${e}.xy);\n                  }\n                  `):p+=`\n                if (xC >= 0 && xC < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n\n                xC${e} = xTexelC${e};\n                `,e+1<c)){const t=i%2===0?me(u):u;u%2===0&&i%2===1||u%2!==0&&i%2!==1?(p+=`\n                  xCOffset = xC + imod(pads[1], 2) + ${t};\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e+1}Ready == 0) {\n                    xTexelC${e+1} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC${e+1}.zw = vec2(0.0);\n                    }\n                    xTexelC${e+1}Ready = 1;\n                  }\n                  `,p+=u>1?`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC${e+1} = vec4(previous.zw, xTexelC${e+1}.xy);\n                    } else {\n                     xC${e+1} = vec4(0.0, 0.0, xTexelC${e+1}.xy);\n                    }\n                    `:`\n                    xC${e+1} = vec4(xTexelC${e}.zw, xTexelC${e+1}.xy);\n                    `):p+=1===t?`\n                    xC${e+1} = xTexelC${e};\n                    `:`\n                    xCOffset = xC + ${t};\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e+1}Ready == 0) {\n                      xTexelC${e+1} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC${e+1}.zw = vec2(0.0);\n                      }\n                      xTexelC${e+1}Ready = 1;\n                    }\n\n                    xC${e+1} = xTexelC${e+1};\n                    `}}else e<c&&(i%2===1?(p+=`\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${e+1}Ready == 0) {\n                  xTexelC${e+1} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC${e+1}.zw = vec2(0.0);\n                  }\n                  xTexelC${e+1}Ready = 1;\n                }\n\n                xC${e} = vec4(xTexelC${e}.zw, xTexelC${e+1}.zw);\n              `,e+1<c&&(p+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${e+1} = vec4(xTexelC${e+1}.xy, final.xy);\n                `)):(p+=`\n                if(xC >= 0 && xC < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e+1}Ready == 0) {\n                  xTexelC${e+1} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${e+1}.zw = vec2(0.);\n                  }\n                  xTexelC${e+1}Ready = 1;\n                }\n\n                xC${e} = vec4(\n                  xTexelC${e}.xy, xTexelC${e+1}.xy);\n              `,e+1<c&&(p+=`\n                  xC${e+1} = vec4(xTexelC${e}.zw, xTexelC${e+1}.zw);\n                `)));e<c&&(p+=`\n            wTexel = getW(r, ${e}, d1, q);\n            dotProd += xC${e} * vec4(wTexel.xz, wTexel.xz);\n          `,e+1<c&&(p+=`\n              wTexel = getW(r, ${e+1}, d1, q);\n              dotProd += xC${e+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}p+="\n    }\n  ",p+="\n      }\n    ";let d="",f="";n&&(d=r?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:s?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`vec4 activation(vec4 x) {\n          ${n}\n        }`,f="result = activation(result);");const m=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${d}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${a};\n        int q = d2 - d1 * ${a};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${p}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${m}\n        ${f}\n        setOutput(result);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function p1(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:u,dimRoundingMode:l}=r;let c=u;null==c&&(c=[1,1]),we(Gh(i,c),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`));const h=Fh(s.shape,a.shape,i,c,o,l,!0);let p;p=ht().getBool("WEBGL_PACK_DEPTHWISECONV")&&h.strideWidth<=2&&h.outChannels/h.inChannels===1?new h1(h):new c1(h);const d=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];return n.runWebGLProgram(p,[s,a],"float32",d)}const d1={kernelName:un,backendName:"webgl",kernelFunc:p1};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class f1{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,s=e.padInfo.left,a=e.outChannels/e.inChannels;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${a} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${r};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${s};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class m1{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,s=e.strideWidth,a=t-1-e.padInfo.top,i=n-1-e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${a}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${s}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${o}; dm++) {\n              int d2 = d1 * ${o} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function g1(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,dilations:o,pad:u,dimRoundingMode:l,filterShape:c}=r,h=Fh(s.shape,c,i,o,u,l,!0),p=new f1(h);return n.runWebGLProgram(p,[s,a],"float32")}const y1={kernelName:ln,backendName:"webgl",kernelFunc:g1};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function b1(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{strides:i,dilations:o,pad:u,dimRoundingMode:l,inputShape:c}=r,h=Fh(c,a.shape,i,o,u,l,!0),p=new m1(h);return n.runWebGLProgram(p,[s,a],"float32")}const x1={kernelName:cn,backendName:"webgl",kernelFunc:b1};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class w1{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function v1(e){const{inputs:t,backend:n}=e,{x:r}=t,s=[...r.shape,...r.shape],a=Ie(r.shape),i=YJ({inputs:{x:r},backend:n,attrs:{shape:[a]}}),o=new w1(a),u=n.runWebGLProgram(o,[i],i.dtype),l=YJ({inputs:{x:u},backend:n,attrs:{shape:s}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(u),l}const k1={kernelName:hn,backendName:"webgl",kernelFunc:v1};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class I1{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:n,padInfo:r,strideHeight:s,strideWidth:a,filterHeight:i,filterWidth:o,dilationHeight:u,dilationWidth:l}=e,{top:c,left:h}=r;this.userCode=`\n      const ivec2 strides = ivec2(${s}, ${a});\n      const ivec2 pads = ivec2(${c}, ${h});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${i}; h++) {\n          int hIn = hBeg + h * ${u};\n\n          if (hIn >= 0 && hIn < ${t}) {\n            for (int w = 0; w < ${o}; w++) {\n              int wIn = wBeg + w * ${l};\n\n              if (wIn >= 0 && wIn < ${n}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function N1(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:u}=r,l=Eh(s.shape,a.shape,i,o,"NHWC",u);let c;const h=new I1(l);c=n.runWebGLProgram(h,[s,a],"float32");const p=YJ({inputs:{x:c},backend:n,attrs:{shape:l.outShape}});return n.disposeIntermediateTensorInfo(c),p}const S1={kernelName:pn,backendName:"webgl",kernelFunc:N1};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function T1(e){const{inputs:t,backend:n,attrs:r}=e,{equation:s}=r,a=t,{allDims:i,summedDims:o,idDims:u}=pv(s,a.length);fv(i.length,u,a);const{path:l,steps:c}=mv(o,u),h=c.length;let p=null,d=i.length;const f=[];for(let m=0;m<h;++m){for(const e of c[m]){const{permutationIndices:t,expandDims:r}=dv(d,u[e]);let s;gv(t)?s=a[e]:(s=lZ({inputs:{x:a[e]},backend:n,attrs:{perm:t}}),f.push(s));const i=s.shape.slice();for(let e=0;e<r.length;++e)i.splice(r[e],0,1);Te(s.shape,i)||(s=YJ({inputs:{x:s},backend:n,attrs:{shape:i}}),f.push(s)),null===p?p=s:(p=qJ({inputs:{a:s,b:p},backend:n}),f.push(p))}m<h-1&&(l[m]>=0&&(p=oZ({inputs:{x:p},backend:n,attrs:{axis:l[m]-(i.length-d),keepDims:!1}}),f.push(p)),d--)}for(const m of f)m!==p&&n.disposeIntermediateTensorInfo(m);return p}const $1={kernelName:yn,backendName:"webgl",kernelFunc:T1},C1="return (x >= 0.0) ? x : (exp(x) - 1.0);",E1="\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",R1=BJ({opSnippet:C1,packedOpSnippet:E1}),A1={kernelName:bn,backendName:"webgl",kernelFunc:R1},F1="return (b >= 0.0) ? a : a * (b + 1.0);",_1="\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",D1=e=>{const{inputs:t,backend:n}=e,{dy:r,y:s}=t,a=ht().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new TJ(_1,r.shape,s.shape):new NJ(F1,r.shape,s.shape);return n.runWebGLProgram(a,[r,s],r.dtype)},O1={kernelName:xn,backendName:"webgl",kernelFunc:D1},M1="\n  return vec4(equal(a, b));\n",L1="return float(a == b);",z1=WJ({opSnippet:L1,packedOpSnippet:M1,dtype:"bool",cpuKernelImpl:qX}),P1={kernelName:vn,backendName:"webgl",kernelFunc:z1},B1=`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${Kw};\n  float a1 = ${Xw};\n  float a2 = ${Yw};\n  float a3 = ${Jw};\n  float a4 = ${Zw};\n  float a5 = ${Qw};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`,W1=BJ({opSnippet:B1}),V1={kernelName:wn,backendName:"webgl",kernelFunc:W1},U1=PJ+"\n  return exp(x);\n",G1="\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",H1=BJ({opSnippet:U1,packedOpSnippet:G1,cpuKernelImpl:KX,dtype:"float32"}),j1={kernelName:kn,backendName:"webgl",kernelFunc:H1};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function q1(e){const{inputs:t,attrs:n,backend:r}=e,{dim:s}=n,{input:a}=t,i=a.shape.length,o=a.shape.slice();let u=s;return s<0&&(we(-(i+1)<=s,(()=>`Axis must be in the interval [${-(i+1)}, ${i}]`)),u=i+s+1),o.splice(u,0,1),YJ({inputs:{x:a},backend:r,attrs:{shape:o}})}const K1={kernelName:In,backendName:"webgl",kernelFunc:q1},X1="return exp(x) - 1.0;",Y1=BJ({opSnippet:X1,packedOpSnippet:X1,cpuKernelImpl:XX}),J1={kernelName:Nn,backendName:"webgl",kernelFunc:Y1};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Z1{constructor(e,t,n){this.variableNames=["real","imag"];const r=t[1];this.outputShape=t;const s=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,a=n?`${r}.0`:"1.0";let i;if("real"===e)i="return real * expR - imag * expI;";else{if("imag"!==e)throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);i="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${s};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${i}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${r});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${r}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${a};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Q1(e,t,n){const r=n.texData.get(e.dataId),s=Ie(e.shape),a=e.shape[e.shape.length-1],i=s/a,o=YJ({inputs:{x:e},backend:n,attrs:{shape:[i,a]}}),u=o.shape,l=new Z1("real",u,t),c=new Z1("imag",u,t),h=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:u},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:u}],p=n.runWebGLProgram(l,h,"float32"),d=n.runWebGLProgram(c,h,"float32"),f=EJ({inputs:{real:p,imag:d},backend:n});n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(d);const m=YJ({inputs:{x:f},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(f),m}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function e2(e){const{inputs:t,backend:n}=e,{input:r}=t;return Q1(r,!1,n)}const t2={kernelName:Sn,backendName:"webgl",kernelFunc:e2};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class n2{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function r2(e){const{backend:t,attrs:n}=e,{shape:r,value:s}=n;let{dtype:a}=n;if(a=a||je(s),"string"===a){const e=Le(a,Ie(r));return e.fill(s),t.makeTensorInfo(r,a,e)}{const e=new n2(r,s),n=[[s]];return t.runWebGLProgram(e,[],a,n)}}const s2={kernelName:Tn,backendName:"webgl",kernelFunc:r2};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class a2{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${t} - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${t}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const i2={kernelName:$n,backendName:"webgl",kernelFunc:({inputs:e,backend:t})=>{const{image:n}=e,r=t,s=new a2(n.shape),a=r.runWebGLProgram(s,[n],n.dtype);return a}},o2="return floor(x);",u2=BJ({opSnippet:o2,packedOpSnippet:o2,cpuKernelImpl:YX}),l2={kernelName:Cn,backendName:"webgl",kernelFunc:u2},c2="\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",h2="\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",p2=WJ({opSnippet:c2,packedOpSnippet:h2,dtype:"int32"}),d2={kernelName:En,backendName:"webgl",kernelFunc:p2};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class f2{constructor(e){this.variableNames=["A"];const t=rK(),[n,r]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${n}.0);\n\n        vec4 values = ${t.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class m2{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=rK(),[n,r]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${r}.0, ${n}.0);\n            vec4 values = ${t.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${t.output} = result;\n      }\n    `}}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const g2={kernelName:Fs,backendName:"webgl",kernelFunc:x2};let y2,b2=ht().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function x2(e){const{inputs:t,backend:n,attrs:r}=e;let{pixels:s}=t;const{numChannels:a}=r,i="undefined"!==typeof HTMLVideoElement&&s instanceof HTMLVideoElement,o="undefined"!==typeof HTMLImageElement&&s instanceof HTMLImageElement,[u,l]=i?[s.videoWidth,s.videoHeight]:[s.width,s.height],c=[l,u],h=[l,u,a];if(o||i){const e=ht().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");null!=y2&&e===b2||(b2=e,y2=document.createElement("canvas").getContext("2d",{willReadFrequently:b2})),y2.canvas.width=u,y2.canvas.height=l,y2.drawImage(s,0,0,u,l),s=y2.canvas}const p=n.makeTensorInfo(c,"int32");n.texData.get(p.dataId).usage=Kj.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(p.dataId),s);const d=ht().getBool("WEBGL_PACK")?new m2(h):new f2(h),f=n.runWebGLProgram(d,[p],"int32");return n.disposeData(p.dataId),f}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function w2(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:u,pad:l,dataFormat:c,dilations:h,dimRoundingMode:p,activation:d,leakyreluAlpha:f}=r,m=jh(c),g=Fh(s.shape,a.shape,u,h,l,p,!1,m);let y;const b=[],x=null!=i,w=null!=o,v="leakyrelu"===d,k=()=>{const e=[s,a],t=(e,t)=>{if("NCHW"===t&&1===e.shape.length&&1!==e.shape[0]){const t=YJ({inputs:{x:e},backend:n,attrs:{shape:[e.shape[0],1,1]}});return b.push(t),t}return e};if(x&&e.push(t(i,c)),w&&e.push(t(o,c)),v){const t=n.makeTensorInfo([],"float32",ga(f,"float32"));e.push(t),b.push(t)}return e};if(1!==g.filterHeight||1!==g.filterWidth||1!==g.dilationHeight||1!==g.dilationWidth||1!==g.strideHeight||1!==g.strideWidth||"SAME"!==g.padInfo.type&&"VALID"!==g.padInfo.type)if(g.strideWidth<=2&&"channelsLast"===m&&ht().getBool("WEBGL_EXP_CONV")){const e=d?VJ(d,!0):null,t=new b0(g,x,e,w,v),r=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],s=k();y=n.runWebGLProgram(t,s,"float32",r)}else if(ht().getBool("WEBGL_CONV_IM2COL"))y=k0({x:s,filter:a,convInfo:g,backend:n,bias:i,activation:d,preluActivationWeights:o,leakyreluAlpha:f});else{const e=d?VJ(d,!1):null,t=new g0(g,x,e,w,v),r=k();y=n.runWebGLProgram(t,r,"float32")}else y=v0({x:s,filter:a,convInfo:g,backend:n,bias:i,activation:d,preluActivationWeights:o,leakyreluAlpha:f});const I=YJ({inputs:{x:y},backend:n,attrs:{shape:g.outShape}});return b.push(y),b.forEach((e=>n.disposeIntermediateTensorInfo(e))),I}const v2={kernelName:Os,backendName:"webgl",kernelFunc:w2};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function k2(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:u,pad:l,dilations:c,dimRoundingMode:h,activation:p,leakyreluAlpha:d}=r,f=[];let m=c;null==m&&(m=[1,1]),we(Gh(u,m),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${m}'`));const g=Fh(s.shape,a.shape,u,m,l,h,!0),y=ht().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels===1,b=p?VJ(p,y):null,x=[s,a],w=null!=i,v=null!=o,k="leakyrelu"===p;if(w&&x.push(i),v&&x.push(o),k){const e=n.makeTensorInfo([],"float32",ga(d,"float32"));x.push(e),f.push(e)}let I;I=y?new h1(g,w,b,v,k):new c1(g,w,b,v,k);const N=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],S=n.runWebGLProgram(I,x,"float32",N);return f.forEach((e=>n.disposeIntermediateTensorInfo(e))),S}const I2={kernelName:Ms,backendName:"webgl",kernelFunc:k2};class N2{constructor(e,t,n,r){this.sliceDim=e,this.strides=t,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=n;const s=QK(n.length);let a="\n    int index;";for(let i=0;i<this.sliceDim;i++)a+=`\n          index = round(getIndices(coords[0], ${i}));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[i]};\n          flattenIndex += index * ${this.strides[i]};`;this.userCode=`\n         void main() {\n          ${s} coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ${a}\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function S2(e){const{inputs:t,backend:n}=e,{params:r,indices:s}=t,a=s.shape,i=a[a.length-1],o=Ie(r.shape),[u,l,c,h]=xc(r,s),p=YJ({inputs:{x:s},backend:n,attrs:{shape:[l,i]}}),d=YJ({inputs:{x:r},backend:n,attrs:{shape:[Ie(r.shape)/c,c]}});if(n.shouldExecuteOnCPU([r,s])||"string"===r.dtype){const e=n.readSync(s.dataId),t=n.bufferSync(r),a=JX(e,t,r.dtype,l,i,c,h,r.shape,o);return n.makeTensorInfo(u,r.dtype,a.values)}const f=new N2(i,h,[l,c],r.shape),m=n.runWebGLProgram(f,[d,p],d.dtype),g=YJ({inputs:{x:m},backend:n,attrs:{shape:u}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(m),g}const T2={kernelName:Fn,backendName:"webgl",kernelFunc:S2};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class $2{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const n=QK(this.rank),r=C2(e,2);this.userCode=`\n      void main() {\n        ${n} resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;\n        setOutput(inBounds * getA(${r}));\n      }\n    `}}function C2(e,t){const n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let s=0;s<e.length;s++)2===s?r.push("index"):r.push(`${n[s]}`);return r.join()}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function E2(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,indices:a}=t,{axis:i,batchDims:o}=r,u=De(i,s.shape)[0];if(ht().get("DEBUG")){const e=n.readSync(a.dataId),t=s.shape[u];for(let n=0;n<e.length;++n){const r=e[n];we(r<=t-1&&r>=0,(()=>`GatherV2: the index value ${r} is not in [0, ${t-1}]`))}}const l=_v(s,a,u,o),c=Ie(a.shape),h=[],p=YJ({inputs:{x:s},backend:n,attrs:{shape:[l.batchSize,l.outerSize,l.dimSize,l.sliceSize]}}),d=YJ({inputs:{x:a},backend:n,attrs:{shape:[l.batchSize,c/l.batchSize]}});h.push(p),h.push(d);const f=[l.batchSize,l.outerSize,c/l.batchSize,l.sliceSize];if(n.shouldExecuteOnCPU([s,a])||"string"===s.dtype){const e=n.bufferSync(d),t=n.bufferSync(p),r=ZX(t,e,f);return h.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(l.outputShape,r.dtype,r.values)}const m=new $2(p.shape,f),g=n.runWebGLProgram(m,[p,d],p.dtype);h.push(g);const y=YJ({inputs:{x:g},backend:n,attrs:{shape:l.outputShape}});return h.forEach((e=>n.disposeIntermediateTensorInfo(e))),y}const R2={kernelName:An,backendName:"webgl",kernelFunc:E2},A2="return float(a > b);",F2="\n  return vec4(greaterThan(a, b));\n",_2=WJ({opSnippet:A2,packedOpSnippet:F2,cpuKernelImpl:QX,dtype:"bool"}),D2={kernelName:_n,backendName:"webgl",kernelFunc:_2},O2="return float(a >= b);",M2="\n  return vec4(greaterThanEqual(a, b));\n",L2=WJ({opSnippet:O2,packedOpSnippet:M2,dtype:"bool",cpuKernelImpl:eY}),z2={kernelName:Dn,backendName:"webgl",kernelFunc:L2};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function P2(e){const{inputs:t,backend:n}=e,{input:r}=t;return Q1(r,!0,n)}const B2={kernelName:Mn,backendName:"webgl",kernelFunc:P2},W2="return float(!isnan(x) && !isinf(x));",V2=BJ({opSnippet:W2,dtype:"bool"}),U2={kernelName:zn,backendName:"webgl",kernelFunc:V2},G2="return float(isinf(x));",H2=BJ({opSnippet:G2,dtype:"bool"}),j2={kernelName:Pn,backendName:"webgl",kernelFunc:H2},q2="return float(isnan(x));",K2=BJ({opSnippet:q2,dtype:"bool"}),X2={kernelName:Bn,backendName:"webgl",kernelFunc:K2},Y2="return float(a < b);",J2="\n  return vec4(lessThan(a, b));\n",Z2=WJ({opSnippet:Y2,packedOpSnippet:J2,cpuKernelImpl:tY,dtype:"bool"}),Q2={kernelName:Vn,backendName:"webgl",kernelFunc:Z2},e3="return float(a <= b);",t3="\n  return vec4(lessThanEqual(a, b));\n",n3=WJ({opSnippet:e3,packedOpSnippet:t3,cpuKernelImpl:nY,dtype:"bool"}),r3={kernelName:Un,backendName:"webgl",kernelFunc:n3};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function s3(e){const{backend:t,attrs:n}=e,{start:r,stop:s,num:a}=n,i=rY(r,s,a);return t.makeTensorInfo([i.length],"float32",i)}const a3={kernelName:Gn,backendName:"webgl",kernelFunc:s3},i3=PJ+"\n  return x < 0.0 ? 0./0. : log(x);\n",o3="\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",u3=BJ({opSnippet:i3,packedOpSnippet:o3,cpuKernelImpl:sY}),l3={kernelName:Hn,backendName:"webgl",kernelFunc:u3},c3=PJ+"\n  return log(1.0 + x);\n",h3=BJ({opSnippet:c3}),p3={kernelName:jn,backendName:"webgl",kernelFunc:h3},d3="return float(a >= 1.0 && b >= 1.0);",f3="\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",m3=WJ({opSnippet:d3,packedOpSnippet:f3,dtype:"bool"}),g3={kernelName:qn,backendName:"webgl",kernelFunc:m3},y3="return float(!(x >= 1.0));",b3=BJ({opSnippet:y3}),x3={kernelName:Kn,backendName:"webgl",kernelFunc:b3},w3="return float(a >= 1.0 || b >= 1.0);",v3="\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",k3=WJ({opSnippet:w3,packedOpSnippet:v3,dtype:"bool"}),I3={kernelName:Xn,backendName:"webgl",kernelFunc:k3};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class N3{constructor(e,t,n,r,s){this.variableNames=["x"],this.outputShape=[];const a=t,i=e[3]-1;let o;this.outputShape=e;const u=`float(${n}) + float(${r}) * sum`;o=.5===s?`inversesqrt(${u})`:1===s?`1.0/(${u})`:`exp(log(${u}) * float(-${s}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${a}; j <= ${a}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${i}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${o};\n        setOutput(val);\n      }\n    `}}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class S3{constructor(e,t,n,r,s){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const a=t,i=e[3]-1;let o;this.outputShape=e;const u=`float(${n}) + float(${r}) * sum`;o=.5===s?`inversesqrt(${u})`:1===s?`1.0/(${u})`:`exp(log(${u}) * float(-${s}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${a};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${a}; j <= ${a}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${i}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${o};\n        setOutput(result);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const T3=e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{depthRadius:a,bias:i,alpha:o,beta:u}=r,l=ht().getBool("WEBGL_PACK_NORMALIZATION")?new S3(s.shape,a,i,o,u):new N3(s.shape,a,i,o,u);return n.runWebGLProgram(l,[s],s.dtype)},$3={kernelName:Qn,backendName:"webgl",kernelFunc:T3};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class C3{constructor(e,t,n,r,s){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=r,this.beta=s,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${t})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${t} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${r}) * norm + float(${n});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${r})\n                * float(${s})\n                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${s});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const E3=e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s,y:a,dy:i}=t,{depthRadius:o,bias:u,alpha:l,beta:c}=r,h=new C3(s.shape,o,u,l,c);return n.runWebGLProgram(h,[s,a,i],s.dtype)},R3={kernelName:er,backendName:"webgl",kernelFunc:E3};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function A3(e,t,n,r){const s=Ie(t),a=Ie(e.shape),i=a/s,o=YJ({inputs:{x:e},attrs:{shape:[i,s]},backend:r}),u=tZ(o,e.dtype,"max",r),l=YJ({inputs:{x:u},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(o),r.disposeIntermediateTensorInfo(u),l}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function F3(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reductionIndices:a,keepDims:i}=r,o=s.shape.length,u=De(a,s.shape);let l=u;const c=Bd(l,o),h=null!=c,p=n.shouldExecuteOnCPU([s]);let d=s;if(h){if(p){const e=n.texData.get(d.dataId),t=e.values,r=new Array(o);for(let n=0;n<r.length;n++)r[n]=s.shape[c[n]];const a=_Y(t,s.shape,s.dtype,c,r);d=n.makeTensorInfo(r,s.dtype);const i=n.texData.get(d.dataId);i.values=a}else d=aZ(s,c,n);l=Vd(l.length,o)}Pd("max",l,o);const[f,m]=Ld(d.shape,l);let g,y=f;if(i&&(y=zd(f,u)),p){const e=n.texData.get(d.dataId),t=e.values,r=aY(t,Ie(m),y,s.dtype);g=n.makeTensorInfo(y,s.dtype);const a=n.texData.get(g.dataId);a.values=r}else g=A3(d,m,y,n);return h&&n.disposeIntermediateTensorInfo(d),g}const _3={kernelName:nr,backendName:"webgl",kernelFunc:F3},D3=IJ+"\n  return max(a, b);\n",O3="\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+SJ+"\n  return result;\n",M3=WJ({opSnippet:D3,packedOpSnippet:O3,cpuKernelImpl:iY}),L3={kernelName:rr,backendName:"webgl",kernelFunc:M3};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function z3(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;tK(s,"maxPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:u}=r,l=1;we(Gh(i,l),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${l}'`));const c=Rh(s.shape,a,i,l,o,u);if(1===c.filterWidth&&1===c.filterHeight&&Te(c.inShape,c.outShape))return $J({inputs:{x:s},backend:n});const h=new iQ(c,"max",!1);return n.runWebGLProgram(h,[s],s.dtype)}const P3={kernelName:sr,backendName:"webgl",kernelFunc:z3};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function B3(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dataFormat:u,dimRoundingMode:l}=r,c=[1,1,1],h=Ah(s.shape,a,i,c,o,l,u),p=new oQ(h,"max",!1);return n.runWebGLProgram(p,[s],s.dtype)}const W3={kernelName:ir,backendName:"webgl",kernelFunc:B3};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class V3{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,n=e.strideWidth,r=e.dilationHeight,s=e.effectiveFilterHeight,a=e.effectiveFilterWidth,i=s-1-e.padInfo.top,o=a-1-e.padInfo.left,u=s*a-1;this.userCode=`\n      const ivec2 pads = ivec2(${i}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${s};\n          wR += ${r}) {\n          float dyR = float(dyRCorner + wR) / ${t}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${a}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${n}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${u} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${a} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class U3{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,s=e.dilationDepth,a=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterDepth,u=e.effectiveFilterHeight,l=e.effectiveFilterWidth,c=o-1-e.padInfo.front,h=u-1-e.padInfo.top,p=l-1-e.padInfo.left,d=o*u*l-1;this.userCode=`\n      const ivec3 pads = ivec3(${c}, ${h}, ${p});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${o};\n           wD += ${s}) {\n          float dyD = float(dyDCorner + wD) / ${t}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${u};\n              wR += ${a}) {\n            float dyR = float(dyRCorner + wR) / ${n}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${l};\n                wC += ${i}) {\n              float dyC = float(dyCCorner + wC) / ${r}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${d} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${u} * ${l} +\n                  wR * ${l} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function G3(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a,{filterSize:o,strides:u,pad:l,dimRoundingMode:c}=r,h=[1,1,1],p=Ah(i.shape,o,u,h,l,c),d=new oQ(p,"max",!0),f=n.runWebGLProgram(d,[i],i.dtype),m=new U3(p),g=n.runWebGLProgram(m,[s,f],i.dtype);return n.disposeIntermediateTensorInfo(f),g}const H3={kernelName:or,backendName:"webgl",kernelFunc:G3};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function j3(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a,output:i}=t,o=a;tK([a,i],"maxPoolGrad");const{filterSize:u,strides:l,pad:c,dimRoundingMode:h}=r,p=Rh(o.shape,u,l,1,c,h),d=!0,f=new iQ(p,"max",d),m=n.runWebGLProgram(f,[o],o.dtype),g=new V3(p),y=n.runWebGLProgram(g,[s,m],o.dtype);return n.disposeIntermediateTensorInfo(m),y}const q3={kernelName:ar,backendName:"webgl",kernelFunc:j3};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function K3(e,t,n,r){let s=new iQ(n,"max",!1);const a=r.runWebGLProgram(s,[e],"float32");s=new iQ(n,"max",!0,!0,t);const i=r.runWebGLProgram(s,[e],"float32");return[a,i]}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const X3={kernelName:ur,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r}=e,{filterSize:s,strides:a,pad:i,includeBatchInIndex:o}=t,u=n;we(4===r.shape.length,(()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`));const l=[1,1];we(Gh(a,l),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${l}'`));const c=Rh(r.shape,s,a,l,i),[h,p]=K3(r,o,c,u);return[h,p]}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Y3(e,t,n,r){const s=Ie(t),a=Ie(e.shape),i=a/s,o=YJ({inputs:{x:e},attrs:{shape:[i,s]},backend:r}),u=tZ(o,"float32","mean",r),l=YJ({inputs:{x:u},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(o),r.disposeIntermediateTensorInfo(u),l}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const J3={kernelName:lr,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r}=e,{keepDims:s,axis:a}=t,i=n,o=r.shape.length,u=De(a,r.shape);let l=u;const c=Bd(l,o),h=null!=c,p=i.shouldExecuteOnCPU([r]),d=[];let f=r;if(h){if(p){const e=i.texData.get(f.dataId),t=e.values,n=new Array(o);for(let i=0;i<n.length;i++)n[i]=r.shape[c[i]];const s=_Y(t,r.shape,r.dtype,c,n);f=i.makeTensorInfo(n,r.dtype);const a=i.texData.get(f.dataId);a.values=s}else f=aZ(r,c,i);d.push(f),l=Vd(l.length,o)}Pd("sum",l,o);const[m,g]=Ld(f.shape,l);let y=m;s&&(y=zd(m,u));const b=Y3(f,g,y,i);for(const x of d)i.disposeIntermediateTensorInfo(x);return b}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Z3(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=s.shape.length,u=De(a,s.shape);let l=u;const c=Bd(l,o);let h=s;null!=c&&(h=lZ({inputs:{x:s},backend:n,attrs:{perm:c}}),l=Vd(l.length,s.shape.length)),Pd("min",l,o);const[p,d]=Ld(h.shape,l),f=Ie(d),m=YJ({inputs:{x:h},backend:n,attrs:{shape:[-1,f]}}),g=tZ(m,m.dtype,"min",n);let y;if(i){const e=zd(p,u);y=YJ({inputs:{x:g},backend:n,attrs:{shape:e}})}else y=YJ({inputs:{x:g},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),null!=c&&n.disposeIntermediateTensorInfo(h),y}const Q3={kernelName:cr,backendName:"webgl",kernelFunc:Z3},e4=IJ+"\n  return min(a, b);\n",t4="\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+SJ+"\n  return result;\n",n4=WJ({opSnippet:e4,packedOpSnippet:t4,cpuKernelImpl:oY}),r4={kernelName:hr,backendName:"webgl",kernelFunc:n4};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class s4{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,s=QK(r),a=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),u="reflect"===n?0:1;this.userCode=1!==r?`\n      ${s} start = ${s}(${a});\n      ${s} end = ${s}(${i});\n\n      void main() {\n        ${s} outC = getOutputCoords();\n        for (int i = 0; i < ${r}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${u};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${u};\n          }\n        }\n        ${s} coords = outC - start;\n        setOutput(getX(${o}));\n      }\n    `:`\n        int start = ${a};\n        int end = ${i};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${u};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${u};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class a4{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,s=QK(r),a=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),o=MY("rc",r),u=MY("source",r),l=`${o[r-1]} < ${this.outputShape[r-1]}`,c=1===r?"source":`vec2(${u.slice(-2).join()})`,h="reflect"===n?0:1;let p="";if(1===r){const e=`\n        ${s} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${h};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${h};\n        }\n        source -= start;\n      `;p=`\n        ${s} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${u.join()}), ${c});\n        ${o[r-1]} += 1;\n        if(${l}) {\n          ${e}\n          result[1] = getChannel(getX(${u.join()}), ${c});\n        }\n      `}else{const e=`\n        ${s} source = rc;\n        ${s} lt = ${s}(lessThan(source, start));\n        ${s} gte = ${s}(greaterThanEqual(source, end));\n        ${s} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${h}) +\n                gte * ((end - 1) * 2 - source + ${h});\n        source -= start;\n      `;p=`\n        ${s} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${u.join()}), ${c});\n        ${o[r-1]} += 1;\n        if(${l}) {\n          ${e}\n          result[1] = getChannel(getX(${u.join()}), ${c});\n        }\n        rc = outputLoc;\n        ${o[r-2]} += 1;\n        if(${o[r-2]} < ${this.outputShape[r-2]}) {\n          ${e}\n          result[2] = getChannel(getX(${u.join()}), ${c});\n          ${o[r-1]} += 1;\n          if(${l}) {\n            ${e}\n            result[3] = getChannel(getX(${u.join()}), ${c});\n          }\n        }\n      `}this.userCode=`\n      const ${s} start = ${s}(${a});\n      const ${s} end = ${s}(${i});\n\n      void main() {\n        ${s} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${p}\n        setOutput(result);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const i4=({inputs:e,backend:t,attrs:n})=>{const{x:r}=e,{paddings:s,mode:a}=n,i=ht().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new a4(r.shape,s,a):new s4(r.shape,s,a),o=t.runWebGLProgram(i,[r],r.dtype);return o},o4={kernelName:pr,backendName:"webgl",kernelFunc:i4},u4="if (b == 0.0) return NAN;\n  return mod(a, b);",l4="\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  "+SJ+"\n  return result;\n",c4=WJ({opSnippet:u4,packedOpSnippet:l4}),h4={kernelName:dr,backendName:"webgl",kernelFunc:c4};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class p4{constructor(e,t,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,n],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${t-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${t-1}));\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const d4="\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",f4="\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",m4=WJ({opSnippet:d4,packedOpSnippet:f4,checkOutOfBounds:!0}),g4={kernelName:gn,backendName:"webgl",kernelFunc:m4},y4="return a - b;",b4=WJ({opSnippet:y4,packedOpSnippet:y4,supportsComplex:!0,cpuKernelImpl:RY}),x4={kernelName:xs,backendName:"webgl",kernelFunc:b4};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function w4(e){const{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{dim:a}=r,i=De([a],s.shape),o=F3({inputs:{x:s},backend:n,attrs:{reductionIndices:i,keepDims:!1}}),u=zd(o.shape,i),l=YJ({inputs:{x:o},backend:n,attrs:{shape:u}}),c=b4({inputs:{a:s,b:l},backend:n}),h=H1({inputs:{x:c},backend:n}),p=oZ({inputs:{x:h},backend:n,attrs:{axis:i,keepDims:!1}}),d=YJ({inputs:{x:p},backend:n,attrs:{shape:u}}),f=m4({inputs:{a:h,b:d},backend:n});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(d),f}const v4={kernelName:is,backendName:"webgl",kernelFunc:w4};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function k4(e){const{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{numSamples:a,seed:i,normalized:o}=r,u=o?s:w4({inputs:{logits:s},backend:n,attrs:{dim:s.shape.length-1}}),l=u.shape[0],c=u.shape[1],h=new p4(l,c,a),p=[[i]],d=n.runWebGLProgram(h,[u],"int32",p);return o||n.disposeIntermediateTensorInfo(u),d}const I4={kernelName:fr,backendName:"webgl",kernelFunc:k4},N4=XY+"\n  return -x;\n",S4="\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n";function T4(e){const{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])){const e=n.texData.get(r.dataId),[t,s]=lY(e.values,r.shape,r.dtype);return n.makeTensorInfo(s,r.dtype,t)}let s;return s=ht().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new uJ(r.shape,S4):new KY(r.shape,N4),n.runWebGLProgram(s,[r],r.dtype)}const $4={kernelName:gr,backendName:"webgl",kernelFunc:T4},C4=ax;function E4(e){Ls("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:u}=r,l=n.readSync(s.dataId),c=n.readSync(a.dataId),{selectedIndices:h}=C4(l,c,i,o,u);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}const R4={kernelName:br,backendName:"webgl",kernelFunc:E4},A4=ix;function F4(e){Ls("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:u,padToMaxOutputSize:l}=r,c=n.readSync(s.dataId),h=n.readSync(a.dataId),{selectedIndices:p,validOutputs:d}=A4(c,h,i,o,u,l);return[n.makeTensorInfo([p.length],"int32",new Int32Array(p)),n.makeTensorInfo([],"int32",new Int32Array([d]))]}const _4={kernelName:xr,backendName:"webgl",kernelFunc:F4},D4=ox;function O4(e){Ls("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:u,softNmsSigma:l}=r,c=n.readSync(s.dataId),h=n.readSync(a.dataId),p=i,d=o,f=u,m=l,{selectedIndices:g,selectedScores:y}=D4(c,h,p,d,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}const M4={kernelName:wr,backendName:"webgl",kernelFunc:O4};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class L4{constructor(e,t,n,r){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${r}), float(${n}),\n                      float(index == coords.y)));\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const z4=e=>{const{inputs:t,backend:n,attrs:r}=e,{indices:s}=t,{dtype:a,depth:i,onValue:o,offValue:u}=r,l=Ie(s.shape),c=new L4(l,i,o,u),h=YJ({inputs:{x:s},backend:n,attrs:{shape:[l]}}),p=n.runWebGLProgram(c,[h],a);n.disposeIntermediateTensorInfo(h);const d=[...s.shape,i],f=YJ({inputs:{x:p},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(p),f},P4={kernelName:kr,backendName:"webgl",kernelFunc:z4};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function B4(e){const{inputs:t,backend:n}=e,{x:r}=t;if("complex64"===r.dtype){const e=GQ({inputs:{input:r},backend:n}),t=B4({inputs:{x:e},backend:n}),s=c0({inputs:{input:r},backend:n}),a=B4({inputs:{x:s},backend:n}),i=EJ({inputs:{real:t,imag:a},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),i}return r2({attrs:{shape:r.shape,dtype:r.dtype,value:"string"===r.dtype?"":0},backend:n})}const W4={kernelName:Rs,backendName:"webgl",kernelFunc:B4};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function V4(e){const{inputs:t,backend:n}=e,{x:r}=t;if("string"===r.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===r.dtype){const e=GQ({inputs:{input:r},backend:n}),t=V4({inputs:{x:e},backend:n}),s=c0({inputs:{input:r},backend:n}),a=B4({inputs:{x:s},backend:n}),i=EJ({inputs:{real:t,imag:a},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),i}return r2({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:n})}const U4={kernelName:vr,backendName:"webgl",kernelFunc:V4};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function G4(e){const{inputs:t,backend:n,attrs:r}=e,{axis:s}=r;if(1===t.length)return q1({inputs:{input:t[0]},backend:n,attrs:{dim:s}});const a=t[0].shape,i=t[0].dtype;t.forEach((e=>{ve(a,e.shape,"All tensors passed to stack must have matching shapes"),we(i===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const o=[],u=t.map((e=>{const t=q1({inputs:{input:e},backend:n,attrs:{dim:s}});return o.push(t),t})),l=f0({inputs:u,backend:n,attrs:{axis:s}});return o.forEach((e=>n.disposeIntermediateTensorInfo(e))),l}const H4={kernelName:Ir,backendName:"webgl",kernelFunc:G4};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class j4{constructor(e,t,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,s=QK(r),a=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);this.userCode=1!==r?`\n      ${s} start = ${s}(${a});\n      ${s} end = ${s}(${i});\n\n      void main() {\n        ${s} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${s} coords = outC - start;\n          setOutput(getX(${o}));\n        }\n      }\n    `:`\n        int start = ${a};\n        int end = ${i};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class q4{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,s=QK(r),a=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),o=MY("rc",r),u=MY("source",r),l=`${o[r-1]} < ${this.outputShape[r-1]}`,c=1===r?"source":`vec2(${u.slice(-2).join()})`,h=[`${s} rc = outputLoc;`,`${o[r-1]} += 1;\n       if(${l}) {\n      `,1===r?"":`}\n       rc = outputLoc;\n       ${o[r-2]} += 1;\n       if(${o[r-2]} < ${this.outputShape[r-2]}) {`,1===r?"":`  ${o[r-1]} += 1;\n         if(${l}) {`],p=1===r?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let d="";for(let f=0,m=1===r?2:4;f<m;f++)d+=`\n        ${h[f]}\n        if (${p}) {\n          result[${f}] = float(value);\n        } else {\n          ${s} source = rc - start;\n          result[${f}] = getChannel(getX(${u.join()}), ${c});\n        }\n      `;d+=1===r?"} ":"}}",this.userCode=`\n      const ${s} start = ${s}(${a});\n      const ${s} end = ${s}(${i});\n\n      void main() {\n        ${s} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${d}\n        setOutput(result);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const K4=e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:a,constantValue:i}=r;if(0===Ie(s.shape)){const e=a.map(((e,t)=>e[0]+s.shape[t]+e[1]));return r2({backend:n,attrs:{shape:e,value:i,dtype:s.dtype}})}const o=ht().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new q4(s.shape,a,i):new j4(s.shape,a,i),u=[[i]];return n.runWebGLProgram(o,[s],s.dtype,u)},X4={kernelName:Nr,backendName:"webgl",kernelFunc:K4},Y4="\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",J4="\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  "+SJ+"\n  return result;\n",Z4=WJ({opSnippet:Y4,packedOpSnippet:J4}),Q4={kernelName:Tr,backendName:"webgl",kernelFunc:Z4};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function e6(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=s.shape.length,u=[],l=De(a,s.shape);let c=l;const h=Bd(c,o);let p,d=s;if(null!=h&&(d=lZ({inputs:{x:s},backend:n,attrs:{perm:h}}),c=Vd(c.length,o),u.push(d)),Pd("prod",c,o),n.shouldExecuteOnCPU([d])){const e=n.texData.get(d.dataId).values,{outVals:t,outShape:r,outDtype:s}=hY(d.shape,d.dtype,e,c);p=n.makeTensorInfo(r,s,t)}else{const[e,t]=Ld(d.shape,c),r=Ie(t),a=YJ({inputs:{x:d},backend:n,attrs:{shape:[-1,r]}}),i=ni(s.dtype),o=tZ(a,i,"prod",n);p=YJ({inputs:{x:o},backend:n,attrs:{shape:e}}),u.push(a),u.push(o)}if(i){u.push(p);const e=zd(p.shape,l);p=YJ({inputs:{x:p},backend:n,attrs:{shape:e}})}return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),p}const t6={kernelName:Cr,backendName:"webgl",kernelFunc:e6};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function n6(e){const{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:s,paramsDenseValues:a,indices:i}=t,{outputRaggedRank:o}=r,u=s.map((e=>n.readSync(e.dataId))),l=s.map((e=>e.shape)),c=n.readSync(a.dataId),h=n.readSync(i.dataId),[p,d,f]=pY(u,l,c,a.shape,a.dtype,h,i.shape,o),m=p.map((e=>n.makeTensorInfo([e.length],"int32",e))),g=n.makeTensorInfo(f,a.dtype,d);return m.concat([g])}const r6={kernelName:Er,backendName:"webgl",kernelFunc:n6};
/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function s6(e){const{inputs:t,backend:n}=e,{starts:r,limits:s,deltas:a}=t,i=n.readSync(r.dataId),o=n.readSync(s.dataId),u=n.readSync(a.dataId),[l,c]=dY(i,r.shape,r.dtype,o,s.shape,u,a.shape),h=n.makeTensorInfo([l.length],"int32",l),p=n.makeTensorInfo([c.length],r.dtype,c);return[h,p]}const a6={kernelName:Rr,backendName:"webgl",kernelFunc:s6};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function i6(e){const{inputs:t,backend:n,attrs:r}=e,{shape:s,values:a,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:u}=r,l=n.readSync(s.dataId),c=n.readSync(a.dataId),h=n.readSync(i.dataId),p=o.map((e=>n.readSync(e.dataId))),d=o.map((e=>e.shape)),[f,m]=fY(l,s.shape,c,a.shape,a.dtype,h,i.shape,p,d,u);return n.makeTensorInfo(f,a.dtype,m)}const o6={kernelName:Ar,backendName:"webgl",kernelFunc:i6},u6=e=>{const{backend:t,attrs:n}=e,{start:r,stop:s,step:a,dtype:i}=n,o=mY(r,s,a,i);return t.makeTensorInfo([o.length],i,o)},l6={kernelName:Fr,backendName:"webgl",kernelFunc:u6},c6="return 1.0 / x;",h6=BJ({opSnippet:c6}),p6={kernelName:Dr,backendName:"webgl",kernelFunc:h6},d6=XY+"\n  return (x < 0.0) ? 0.0 : x;\n",f6="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",m6=BJ({opSnippet:d6,packedOpSnippet:f6}),g6={kernelName:Or,backendName:"webgl",kernelFunc:m6},y6=XY+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",b6="\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",x6=BJ({opSnippet:y6,packedOpSnippet:b6}),w6={kernelName:Wr,backendName:"webgl",kernelFunc:x6};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class v6{constructor(e,t,n,r,s){this.variableNames=["A"],this.outputShape=[];const[a,i,o,u]=e;this.outputShape=[a,t,n,u];const l=[r&&t>1?i-1:i,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n];let h;h=s?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${l[0]/c[0]},\n          ${l[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${h};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class k6{constructor(e,t,n,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[a,i,o,u]=e;this.outputShape=[a,t,n,u];const l=[r&&t>1?i-1:i,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n];let h;h=s?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${l[0]/c[0]},\n          ${l[1]/c[1]},\n          ${l[1]/c[1]});\n      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,\n                                     ${o}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${h};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${u-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function I6(e){const{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:i,size:o}=r,[u,l]=o,c=ht().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new k6(s.shape,u,l,a,i):new v6(s.shape,u,l,a,i);return n.runWebGLProgram(c,[s],"float32")}const N6={kernelName:Pr,backendName:"webgl",kernelFunc:I6};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class S6{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,s]=t,[,a,i]=e,o=[n&&a>1?r-1:r,n&&i>1?s-1:s],u=[n&&a>1?a-1:a,n&&i>1?i-1:i],l=o[0]/u[0],c=o[1]/u[1],h=1/l,p=1/c,d=2*Math.ceil(h)+2,f=2*Math.ceil(p)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${l});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${p});\n\n        const int winHeight = int(${d});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${a}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${i}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${s-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function T6(e){const{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r,o=new S6(a.shape,s.shape,i);return n.runWebGLProgram(o,[a],a.dtype)}const $6={kernelName:Br,backendName:"webgl",kernelFunc:T6};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class C6{constructor(e,t,n,r,s){this.variableNames=["A"],this.outputShape=[];const[a,i,o,u]=e;this.outputShape=[a,t,n,u];const l=[r&&t>1?i-1:i,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n],h=r?"0.5":"0.0";let p;p=s?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${l[0]/c[0]},\n          ${l[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${p};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${h})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class E6{constructor(e,t,n,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[a,i,o,u]=e;this.outputShape=[a,t,n,u];const l=[r&&t>1?i-1:i,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n],h=r?"0.5":"0.0";let p;p=s?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${l[0]/c[0]},\n          ${l[1]/c[1]},\n          ${l[1]/c[1]});\n      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,\n                                     ${o}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${p};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${h})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${u-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function R6(e){const{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:i,size:o}=r,[u,l]=o,c=ht().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new E6(s.shape,u,l,a,i):new C6(s.shape,u,l,a,i);return n.runWebGLProgram(c,[s],s.dtype)}const A6={kernelName:Lr,backendName:"webgl",kernelFunc:R6};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class F6{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,s]=t,[,a,i]=e,o=[n&&a>1?r-1:r,n&&i>1?s-1:s],u=[n&&a>1?a-1:a,n&&i>1?i-1:i],l=o[0]/u[0],c=o[1]/u[1],h=1/l,p=1/c,d=2*Math.ceil(h)+2,f=2*Math.ceil(p)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${l});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${p});\n\n        const int winHeight = int(${d});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${a}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${i}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${o[0]}) *\n                (float(dyR) / float(${u[0]}));\n\n            float sourceFracCol =\n                float(${o[1]}) *\n                  (float(dyC) / float(${u[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${r}) - 1),\n                ${n} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${s}) - 1),\n                ${n} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function _6(e){const{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r,o=new F6(a.shape,s.shape,i);return n.runWebGLProgram(o,[a],a.dtype)}const D6={kernelName:zr,backendName:"webgl",kernelFunc:_6};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class O6{constructor(e,t){this.variableNames=["x"];const n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=e,1===n)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${e[0]} - coord - 1));\n        }\n      `);const r=n=>-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - coords[${n}] - 1`:`coords[${n}]`,s=e.map(((e,t)=>r(t))).join(","),a=QK(n);this.userCode=`\n      void main() {\n        ${a} coords = getOutputCoords();\n        setOutput(getX(${s}));\n      }\n    `}}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class M6{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=e;const r=MY("rc",n),s=`${r[n-1]} + 1 < ${this.outputShape[n-1]}`,a=`${r[n-2]} + 1 < ${this.outputShape[n-2]}`,i=QK(n);function o(e){return h(e)}function u(e){return e[n-1]="("+e[n-1]+" + 1)",h(e)}function l(e){return e[n-2]="("+e[n-2]+" + 1)",h(e)}function c(e){return e[n-1]="("+e[n-1]+" + 1)",e[n-2]="("+e[n-2]+" + 1)",h(e)}function h(t){const n=e.map(((e,n)=>p(n,t))),r=n.join(","),s=n.slice(-2).join(",");return`getChannel(getX(${r}), vec2(${s}))`}function p(n,r){return-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - ${r[n]} - 1`:`${r[n]}`}this.userCode=1===n?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${e[0]} - rc - 1),\n            ${e[0]} - rc - 1);\n          if(${s}){\n              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),\n                ${e[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${i} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${o(r.slice())};\n          if(${s}){\n            result.g = ${u(r.slice())};\n          }\n          if(${a}) {\n            result.b = ${l(r.slice())};\n            if(${s}) {\n              result.a = ${c(r.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function L6(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dims:a}=r,i=s.shape.length,o=De(a,s.shape);if(0===i)return $J({inputs:{x:s},backend:n});const u=ht().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new M6(s.shape,o):new O6(s.shape,o);return n.runWebGLProgram(u,[s],s.dtype)}const z6={kernelName:Vr,backendName:"webgl",kernelFunc:L6};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class P6{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const n=e[1],r=e[2];this.outputShape=e;let s="";s="number"===typeof t?`float outputValue = ${t.toFixed(2)};`:`\n        vec3 fill = vec3(${t.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${s}\n          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${n}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const B6={kernelName:_s,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:r}=e,{radians:s,fillValue:a,center:i}=t,o=n,u=new P6(r.shape,a),[l,c]=Bw(i,r.shape[1],r.shape[2]),h=[[l,c,Math.sin(s),Math.cos(s)]],p=o.runWebGLProgram(u,[r],r.dtype,h);return p}},W6="\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n",V6=BJ({opSnippet:W6}),U6={kernelName:Ur,backendName:"webgl",kernelFunc:V6},G6="return inversesqrt(x);",H6=BJ({opSnippet:G6,cpuKernelImpl:gY}),j6={kernelName:Gr,backendName:"webgl",kernelFunc:H6};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class q6{constructor(e,t,n,r,s,a,i=!0,o=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=a;const u=QK(s.length),l=QK(a.length);let c="";1===n?c="i":2===n&&(c="i, j");const h=`getIndices(${c})`;let p="";1===r?p="i":2===r&&(p="i, coords[1]");const d=`getUpdates(${p})`;let f="";o&&(f="coords[0], coords[1]");const m=`getDefaultValue(${f})`,g=t>1?"strides[j]":"strides";this.userCode=`\n        ${u} strides = ${u}(${s});\n\n        void main() {\n          ${l} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${e}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${t}; j++) {\n              int index = round(${h});\n              flattenedIndex += index * ${g};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ${d};\n              found = true;\n            }\n          }\n          setOutput(mix(${m}, sum, float(found)));\n        }\n      `}}
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class K6{constructor(e,t,n,r,s,a,i=!0,o=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=a;const u=QK(s.length),l=QK(a.length);let c="";1===n?c="i":2===n&&(c="i, j");const h=`getIndices(${c})`;let p="";1===r?p="i":2===r&&(p="i, coords[1]");const d=`getUpdates(${p})`;let f="";o&&(f="coords[0], coords[1]");const m=`getDefaultValue(${f})`,g=t>1?"strides[j]":"strides",y=t>1?"strides[j + 1]":"strides";this.userCode=`\n        ${u} strides = ${u}(${s});\n\n        void main() {\n          ${l} coords = getOutputCoords();\n          vec4 sum = vec4(0.);\n          vec4 found = vec4(0.);\n          for (int i = 0; i < ${e}; i+=2) {\n            ivec2 flattenedIndex = ivec2(0);\n            for (int j = 0; j < ${t}; j+=2) {\n              ivec4 index = round(${h});\n              flattenedIndex += index.xz * ${g};\n              if (j + 1 < ${t}) {\n                flattenedIndex += index.yw * ${y};\n              }\n            }\n            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||\n                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {\n              vec4 updVals = ${d};\n              if (flattenedIndex[0] == coords[0]) {\n                sum.xy += updVals.xy;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[0] == coords[0] + 1) {\n                sum.zw += updVals.xy;\n                found.zw = vec2(1.);\n              }\n              if (flattenedIndex[1] == coords[0]) {\n                sum.xy += updVals.zw;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[1] == coords[0] + 1) {\n                sum.zw += updVals.zw;\n                found.zw = vec2(1.);\n              }\n            }\n          }\n          setOutput(mix(${m}, sum, found));\n        }\n      `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function X6(e){const{inputs:t,backend:n,attrs:r}=e,{indices:s,updates:a}=t,{shape:i}=r,{sliceRank:o,numUpdates:u,sliceSize:l,strides:c,outputSize:h}=kc(a,s,i),p=[h/l,l];if(0===h)return n.makeTensorInfo(i,s.dtype);const d=YJ({inputs:{x:s},backend:n,attrs:{shape:[u,o]}}),f=YJ({inputs:{x:a},backend:n,attrs:{shape:[u,l]}}),m=n.makeTensorInfo([],"float32",new Float32Array([0]));let g;g=ht().getBool("WEBGL_PACK")?new K6(u,o,d.shape.length,f.shape.length,c,p):new q6(u,o,d.shape.length,f.shape.length,c,p);const y=n.runWebGLProgram(g,[f,d,m],f.dtype),b=YJ({inputs:{x:y},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(m),b}const Y6={kernelName:Hr,backendName:"webgl",kernelFunc:X6};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class J6{constructor(e,t,n,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,n];const s="while (left < right) {",a=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,i=2===ht().getNumber("WEBGL_VERSION")?s:a,o="left"===r?"<":"<=";this.userCode=`\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ${i}\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ${o} value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     `}}
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Z6(e){const{inputs:t,backend:n,attrs:r}=e,{sortedSequence:s,values:a}=t,{side:i}=r,o=new J6(s.shape[0],s.shape[1],a.shape[1],i),u=[[s.shape[1]]];return n.runWebGLProgram(o,[s,a],"int32",u)}const Q6={kernelName:qr,backendName:"webgl",kernelFunc:Z6};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class e5{constructor(e,t,n){let r,s;if(this.variableNames=["c","a","b"],this.outputShape=t,n>4)throw Error(`Where for rank ${n} is not yet supported`);if(1===n)s="resRC",r="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],a=[],i=[];for(let r=0;r<t.length;r++)i.push(`${n[r]}`),r<e&&a.push(`${n[r]}`);r=a.join(),s=i.join()}const a=QK(n);this.userCode=`\n      void main() {\n        ${a} resRC = getOutputCoords();\n        float cVal = getC(${r});\n        if (cVal >= 1.0) {\n          setOutput(getA(${s}));\n        } else {\n          setOutput(getB(${s}));\n        }\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function t5(e){const{inputs:t,backend:n}=e,{condition:r,t:s,e:a}=t,i=new e5(r.shape.length,s.shape,s.shape.length);return n.runWebGLProgram(i,[r,s,a],ti(s.dtype,a.dtype))}const n5={kernelName:Kr,backendName:"webgl",kernelFunc:t5},r5=`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${jw};\n  float scale = ${qw};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`,s5=BJ({opSnippet:r5}),a5={kernelName:Xr,backendName:"webgl",kernelFunc:s5},i5=PJ+"\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",o5="\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",u5=BJ({opSnippet:i5,packedOpSnippet:o5,cpuKernelImpl:bY}),l5={kernelName:es,backendName:"webgl",kernelFunc:u5},c5="\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n",h5=BJ({opSnippet:c5}),p5={kernelName:Qr,backendName:"webgl",kernelFunc:h5},d5=PJ+"\n  return sin(x);\n",f5=`\n  vec4 result = sin(x);\n  bvec4 isNaN = isnan(x);\n  ${SJ}\n  return result;\n`,m5=BJ({opSnippet:d5,packedOpSnippet:f5}),g5={kernelName:Jr,backendName:"webgl",kernelFunc:m5},y5="\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n",b5=BJ({opSnippet:y5}),x5={kernelName:Zr,backendName:"webgl",kernelFunc:b5},w5="\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n",v5=BJ({opSnippet:w5}),k5={kernelName:ts,backendName:"webgl",kernelFunc:v5},I5=e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,paddings:i}=r;we(s.shape.length<=4,(()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet"));const o=a.reduce(((e,t)=>e*t)),u=[[0,0]];u.push(...i);for(let y=1+a.length;y<s.shape.length;++y)u.push([0,0]);const l=[],c=K4({inputs:{x:s},backend:n,attrs:{paddings:u,constantValue:0}}),h=Ww(c.shape,a,o,!1),p=Vw(h.length,a.length,!1),d=Uw(c.shape,a,o,!1),f=YJ({inputs:{x:c},backend:n,attrs:{shape:h}}),m=lZ({inputs:{x:f},backend:n,attrs:{perm:p}}),g=YJ({inputs:{x:m},backend:n,attrs:{shape:d}});return l.push(c),l.push(f),l.push(m),l.forEach((e=>n.disposeIntermediateTensorInfo(e))),g},N5={kernelName:ss,backendName:"webgl",kernelFunc:I5};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function S5(e){const{inputs:t,backend:n}=e,{indices:r,values:s,denseShape:a,defaultValue:i}=t;if(1!==a.shape.length)throw new Error(`Dense shape must be a vector, saw:\n         ${a.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n         ${r.shape}`);if(1!==s.shape.length)throw new Error(`Values must be a vector, saw:\n         ${s.shape}`);if(0!==i.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${i.shape}`);const o=n.readSync(r.dataId),u=n.readSync(s.dataId),l=n.readSync(a.dataId),c=n.readSync(i.dataId)[0],[h,p,d,f,m]=vY(o,r.shape,r.dtype,u,s.dtype,l,c);return[n.makeTensorInfo(p,r.dtype,h),n.makeTensorInfo([p[0]],s.dtype,d),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((e=>Number(e))))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}const T5={kernelName:os,backendName:"webgl",kernelFunc:S5};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function $5(e){const{inputs:t,backend:n}=e,{inputIndices:r,inputShape:s,newShape:a}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(1!==s.shape.length)throw new Error(`Input shape should be a vector but received shape ${s.shape}`);if(1!==a.shape.length)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);const i=Array.from(n.readSync(s.dataId)),o=n.readSync(r.dataId),u=Array.from(n.readSync(a.dataId)),[l,c,h]=kY(o,r.shape,r.dtype,i,u);return[n.makeTensorInfo(c,r.dtype,l),n.makeTensorInfo([h.length],a.dtype,new Int32Array(h))]}const C5={kernelName:us,backendName:"webgl",kernelFunc:$5};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function E5(e){const{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n              ${s.shape}`);if(1!==a.shape.length)throw new Error(`Segment ids should be a vector but received shape\n              ${a.shape}`);const i=n.readSync(r.dataId),o=n.readSync(s.dataId),u=n.readSync(a.dataId),[l,c]=IY(i,r.shape,r.dtype,o,u,!0);return n.makeTensorInfo(c,r.dtype,l)}const R5={kernelName:ls,backendName:"webgl",kernelFunc:E5};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function A5(e){const{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n             ${s.shape}`);if(1!==a.shape.length)throw new Error(`Segment ids should be a vector but received shape\n             ${a.shape}`);const i=n.readSync(r.dataId),o=n.readSync(s.dataId),u=n.readSync(a.dataId),[l,c]=IY(i,r.shape,r.dtype,o,u);return n.makeTensorInfo(c,r.dtype,l)}const F5={kernelName:cs,backendName:"webgl",kernelFunc:A5};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function _5(e){const{inputs:t,backend:n,attrs:r}=e,{sparseIndices:s,sparseValues:a,defaultValue:i}=t,{outputShape:o}=r,{sliceRank:u,numUpdates:l,sliceSize:c,strides:h,outputSize:p}=kc(a,s,o),d=!1;if("string"===a.dtype){const e=n.bufferSync(s),t=n.bufferSync(a),r=ka(n.readSync(i.dataId)[0]),f=yY(e,t,o,p,c,l,u,h,r,d);return n.makeTensorInfo(o,f.dtype,f.values)}const f=new q6(l,u,s.shape.length,a.shape.length,h,[p,1],d),m=n.runWebGLProgram(f,[a,s,i],a.dtype),g=YJ({inputs:{x:m},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(m),g}const D5={kernelName:hs,backendName:"webgl",kernelFunc:_5};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function O5(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{numOrSizeSplits:a,axis:i}=r,o=De(i,s.shape)[0],u=bv(s,a,o),l=s.shape.length,c=new Array(l).fill(0),h=s.shape.slice();return u.map((e=>{const t=[...h];t[o]=e;const r=EQ({inputs:{x:s},backend:n,attrs:{begin:c,size:t}});return c[o]+=e,r}))}const M5={kernelName:as,backendName:"webgl",kernelFunc:O5},L5="return sqrt(x);",z5=BJ({opSnippet:L5,packedOpSnippet:L5,cpuKernelImpl:NY}),P5={kernelName:ns,backendName:"webgl",kernelFunc:z5},B5="return x * x;",W5=BJ({opSnippet:B5}),V5={kernelName:ds,backendName:"webgl",kernelFunc:W5},U5="return (a - b) * (a - b);",G5=WJ({opSnippet:U5,packedOpSnippet:U5}),H5={kernelName:ps,backendName:"webgl",kernelFunc:G5};
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function j5(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");const a=n.readSync(s.dataId),i=Dv(a),o=SY(i,"string",r);return n.makeTensorInfo(s.shape,"string",o)}const q5={kernelName:fs,backendName:"webgl",kernelFunc:j5};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function K5({inputs:e,attrs:t,backend:n}){const{x:r}=e,s=XY+`\n    return x > 0.0 ? 1.0 : float(${t.alpha});\n  `,a=new KY(r.shape,s);return n.runWebGLProgram(a,[r],r.dtype)}const X5={kernelName:As,backendName:"webgl",kernelFunc:K5};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Y5{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;const r=n.length,s=QK(n.length),a=QK(n.length);let i="";if(1===r)i="coords * strides + begin";else{let e=0;i=n.map(((t,r)=>(e++,1===n.length?`coords * strides[${r}] + begin[${r}]`:`coords[${e-1}] * strides[${r}] + begin[${r}]`))).join(",")}this.userCode=`\n      ${s} begin = ${s}(${e});\n      ${s} strides = ${s}(${t});\n\n      void main() {\n        ${a} coords = getOutputCoords();\n        setOutput(getX(${i}));\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function J5(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,end:i,strides:o,beginMask:u,endMask:l,ellipsisMask:c,newAxisMask:h,shrinkAxisMask:p}=r,{finalShapeSparse:d,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:b,end:x,strides:w}=Bc(s.shape,a,i,o,u,l,c,h,p);let v;if(m)v=YJ({inputs:{x:s},backend:n,attrs:{shape:f}});else if(g||y){we(s.shape.length>=1,(()=>`Input must have rank at least 1, got: ${s.shape.length}`));const e=$c(b,x,w),t=EQ({inputs:{x:s},backend:n,attrs:{begin:b,size:e}});v=YJ({inputs:{x:t},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(t)}else{const e=n.shouldExecuteOnCPU([s]);if(e){const e=n.readSync(s.dataId),t=qo(s.shape,s.dtype,e),r=TY(d,t,w,b);v=n.makeTensorInfo(f,s.dtype,r.values)}else{const e=new Y5(b,w,d);v=n.runWebGLProgram(e,[s],s.dtype)}}const k=YJ({inputs:{x:v},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(v),k}const Z5={kernelName:ms,backendName:"webgl",kernelFunc:J5};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Q5(e){const{inputs:t,backend:n,attrs:r}=e,{separator:s,nGramWidths:a,leftPad:i,rightPad:o,padWidth:u,preserveShortSequences:l}=r,{data:c,dataSplits:h}=t,p=n.readSync(c.dataId),d=n.readSync(h.dataId),[f,m]=$Y(p,d,s,a,i,o,u,l);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(h.shape,"int32",m)]}const e8={kernelName:gs,backendName:"webgl",kernelFunc:Q5};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function t8(e){const{inputs:t,backend:n,attrs:r}=e,{skipEmpty:s}=r,{input:a,delimiter:i}=t;if("string"!==a.dtype)throw new Error("Input must be of datatype string");if(1!==a.shape.length)throw new Error(`Input must be a vector, got shape: ${a.shape}`);if(0!==i.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const o=n.readSync(a.dataId),u=n.readSync(i.dataId)[0],[l,c,h]=CY(o,u,s),p=c.length;return[n.makeTensorInfo([p,2],"int32",l),n.makeTensorInfo([p],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(h))]}const n8={kernelName:ys,backendName:"webgl",kernelFunc:t8};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function r8(e){const{inputs:t,backend:n,attrs:r}=e,{numBuckets:s}=r,{input:a}=t;if("string"!==a.dtype)throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const i=n.readSync(a.dataId),o=EY(i,s);return n.makeTensorInfo(a.shape,"int32",o)}const s8={kernelName:bs,backendName:"webgl",kernelFunc:r8},a8="return tan(x);",i8=BJ({opSnippet:a8}),o8={kernelName:ws,backendName:"webgl",kernelFunc:i8},u8="\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n",l8=BJ({opSnippet:u8}),c8={kernelName:vs,backendName:"webgl",kernelFunc:l8};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function h8(e){const{inputs:t,backend:n,attrs:r}=e,{tensor:s,indices:a,updates:i}=t,{}=r,{sliceRank:o,numUpdates:u,sliceSize:l,strides:c,outputSize:h}=kc(i,a,s.shape),p=[h/l,l];if(0===h)return n.makeTensorInfo(s.shape,a.dtype);const d=YJ({inputs:{x:a},backend:n,attrs:{shape:[u,o]}}),f=YJ({inputs:{x:i},backend:n,attrs:{shape:[u,l]}}),m=YJ({inputs:{x:s},backend:n,attrs:{shape:p}}),g=new q6(u,o,d.shape.length,f.shape.length,c,p,!1,!0),y=n.runWebGLProgram(g,[f,d,m],m.dtype),b=YJ({inputs:{x:y},backend:n,attrs:{shape:s.shape}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(y),b}const p8={kernelName:jr,backendName:"webgl",kernelFunc:h8};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class d8{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let a=0;a<n.length;a++)n[a]=e[a]*t[a];this.outputShape=n,this.rank=n.length;const r=QK(this.rank),s=f8(e);this.userCode=`\n      void main() {\n        ${r} resRC = getOutputCoords();\n        setOutput(getA(${s}));\n      }\n    `}}function f8(e){const t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(1===t)return`imod(resRC, ${e[0]})`;const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let s=0;s<e.length;s++)r.push(`imod(${n[s]}, ${e[s]})`);return r.join()}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function m8(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reps:a}=r;if("string"===s.dtype||s.shape.length>5){const e=n.readSync(s.dataId),t="string"===s.dtype?e.map((e=>ka(e))):e,r=qo(s.shape,s.dtype,t),i=AY(r,a);return n.makeTensorInfo(i.shape,i.dtype,i.values)}const i=new d8(s.shape,a),o=n.runWebGLProgram(i,[s],s.dtype);return o}const g8={kernelName:ks,backendName:"webgl",kernelFunc:m8};class y8{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}}class b8{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function x8(e,t){null!==t&&e.disposeIntermediateTensorInfo(t)}function w8(e){let t=1;while(t<e)t*=2;return t}function v8(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{k:a,sorted:i}=r,o=ht().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),u=ht().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),l=s.shape,c=l[l.length-1];if(n.shouldExecuteOnCPU([s])||c<o||a>u){const e=n.readSync(s.dataId),[t,r]=FY(e,l,s.dtype,a,i);return[n.makeTensorInfo(t.shape,t.dtype,t.values),n.makeTensorInfo(r.shape,r.dtype,r.values)]}if(0===a)return l[l.length-1]=0,[n.makeTensorInfo(l,s.dtype,[]),n.makeTensorInfo(l,"int32",[])];if(1===c)return[s,r2({attrs:{shape:l,dtype:"int32",value:0},backend:n})];const h=n.texData.get(s.dataId),p=null!==h&&h.isPacked,d=p?n.unpackTensor(s):s,f=Ie(l),m=f/c,g=YJ({inputs:{x:d},attrs:{shape:[m,c]},backend:n});p&&x8(n,d);const y=w8(a),b=w8(c);let x=null;const w=()=>null===x?[g,g]:[g,x],v=(e,t,r)=>{const s=w(),a=new y8(r),i=null===x?1:0,o=[[c],[i],[Number.NEGATIVE_INFINITY],[e],[t]],u=x;x=n.runWebGLProgram(a,s,"int32",o),x8(n,u)};for(let T=1;T<y;T*=2){const e=2*T;for(let t=T;t>=1;t/=2)v(e,t,[m,b])}for(let T=b;T>y;T/=2){const e=w(),t=new b8([m,T/2]),r=null===x?1:0,s=[[c],[r],[y]],a=x;x=n.runWebGLProgram(t,e,"int32",s),x8(n,a);const i=y/2,o=2*i;for(let n=i;n>=1;n/=2)v(o,n,x.shape)}let k=x;x=EQ({inputs:{x:x},backend:n,attrs:{begin:0,size:[m,a]}}),x8(n,k);let I=E2({inputs:{x:g,indices:x},backend:n,attrs:{axis:1,batchDims:1}});x8(n,g);const N=l.slice(0,-1);N.push(a),k=x,x=YJ({inputs:{x:x},attrs:{shape:N},backend:n}),x8(n,k);const S=I;return I=YJ({inputs:{x:I},attrs:{shape:N},backend:n}),x8(n,S),[I,x]}const k8={kernelName:Is,backendName:"webgl",kernelFunc:v8};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class I8{constructor(e,t,n,r,s,a){this.variableNames=["Image","Transforms"],this.outputShape=a;const i="nearest"===n?1:2;let o;switch(r){case"constant":o=1;break;case"reflect":o=2;break;case"wrap":o=3;break;case"nearest":o=4;break;default:o=1;break}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${o} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${o} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${o} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${s});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${s});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${t}));\n                float mapY = mapCoord(inY, float(${e}));\n\n                if (${i} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function N8(e){const{inputs:t,backend:n,attrs:r}=e,{image:s,transforms:a}=t,{interpolation:i,fillMode:o,fillValue:u,outputShape:l}=r,[c,h,p,d]=s.shape,[f,m]=null!=l?l:[h,p],g=[c,f,m,d],y=new I8(h,p,i,o,u,g);return n.runWebGLProgram(y,[s,a],"float32")}const S8={kernelName:Ns,backendName:"webgl",kernelFunc:N8};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function T8(e){const{inputs:t,attrs:n,backend:r}=e,{axis:s}=n,{x:a}=t;tK(a,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const i=r.readSync(a.dataId),{outputValues:o,outputShape:u,indices:l}=DY(i,s,a.shape,a.dtype);return[r.makeTensorInfo(u,a.dtype,o),r.makeTensorInfo([l.length],"int32",l)]}const $8={kernelName:Ts,backendName:"webgl",kernelFunc:T8};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function C8(e){const{inputs:t,backend:n,attrs:r}=e,{value:s}=t;let{axis:a}=r;a<0&&(a+=s.shape.length);const i=s,o=i.shape.length,u=s.shape[a],l=new Array(o-1);let c=0;for(let m=0;m<o;m++)m!==a&&(l[c++]=i.shape[m]);const h=[],p=new Array(o).fill(0),d=i.shape.slice();d[a]=1;const f=new Array(u);for(let m=0;m<f.length;m++){p[a]=m;const e=EQ({inputs:{x:i},backend:n,attrs:{begin:p,size:d}}),t=YJ({inputs:{x:e},backend:n,attrs:{shape:l}});f[m]=t,h.push(e)}return h.forEach((e=>n.disposeIntermediateTensorInfo(e))),f}const E8={kernelName:$s,backendName:"webgl",kernelFunc:C8};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class R8{constructor(e,t){this.variableNames=["x","segmentIds"];const n=e.windowSize,r=e.batchSize,s=e.inSize,a=e.numSegments,i=a*Math.ceil(s/n);this.outputShape=[r,i];const o="0.0",u="sumValue",l=4*Math.floor(n/4),c=n%4,h="\n        sumValue += dot(values, segFilter);\n    ";let p="";s%n>0&&(p=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return initializationValue;\n        }\n      `);let d="";s%n>0&&(d=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${o};\n\n      float getValue(int batch, int inIdx) {\n        ${p}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${d}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${a})) * float(${n}));\n        int currentSeg = int(mod(float(outIdx), float(${a})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${l}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${h}\n        }\n\n        int inIdx = inOffset + ${l};\n        if (${1===c}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${h}\n        } else if (${2===c}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${h}\n        } else if (${3===c}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${h}\n        }\n        setOutput(${u});\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function A8(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,segmentIds:a}=t,{numSegments:i}=r,o=s.shape.length,u=[];let l=0;const c=Bd([l],o);let h=s;null!=c&&(h=lZ({inputs:{x:s},backend:n,attrs:{perm:c}}),u.push(h),l=Vd(1,o)[0]);const p=Fv(h.shape,l,i),d=Ie([h.shape[l]]),f=YJ({inputs:{x:h},backend:n,attrs:{shape:[-1,d]}});u.push(f);const m=ni(s.dtype),g=(e,t,r,s,a)=>{const i=e.shape[0],o=e.shape[1],l=Av(o,a),c={windowSize:l,inSize:o,batchSize:i,numSegments:a},h=new R8(c,t),p=n.compileAndRun(h,[e,r],s);if(u.push(p),p.shape[1]===a)return p;const d=u6({backend:n,attrs:{start:0,stop:a,step:1,dtype:"float32"}}),f=m8({inputs:{x:d},backend:n,attrs:{reps:[o/l]}});u.push(d),u.push(f);const m=g(p,t,f,s,a);return m},y=g(f,"unsortedSegmentSum",a,m,i),b=YJ({inputs:{x:y},backend:n,attrs:{shape:p}});let x=b;if(null!=c){u.push(b);const e=Wd(c);x=lZ({inputs:{x:x},backend:n,attrs:{perm:e}})}return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),x}const F8={kernelName:Cs,backendName:"webgl",kernelFunc:A8},_8=[fZ,yZ,wZ,IZ,TZ,RZ,FZ,DZ,WZ,UZ,jZ,XZ,ZZ,nQ,aQ,lQ,hQ,mQ,yQ,xQ,IQ,FQ,DQ,zQ,BQ,XQ,ZQ,n0,RJ,i0,m0,N0,R0,_0,O0,L0,P0,U0,j0,X0,n1,s1,i1,l1,d1,y1,x1,k1,S1,$1,A1,O1,P1,V1,j1,K1,J1,t2,s2,i2,l2,d2,g2,v2,I2,T2,R2,D2,z2,CJ,B2,h0,U2,j2,X2,DJ,Q2,r3,a3,l3,p3,g3,x3,I3,$3,R3,_3,L3,P3,W3,H3,q3,X3,J3,Q3,r4,o4,h4,I4,KJ,$4,R4,_4,M4,UQ,P4,U4,H4,X4,Q4,zJ,t6,r6,a6,o6,l6,HQ,g4,p6,g6,w6,JJ,N6,$6,A6,D6,z6,B6,U6,j6,Y6,Q6,n5,a5,l5,p5,g5,x5,RQ,v4,k5,N5,T5,C5,R5,F5,D5,M5,P5,V5,H5,q5,X5,Z5,e8,n8,s8,x4,uZ,o8,c8,p8,g8,k8,S8,cZ,$8,E8,F8,W4];for(const c7 of _8)Gs(c7);
/** @license See the LICENSE file. */
const D8="4.11.0",O8={"tfjs-core":rh,"tfjs-backend-cpu":qB,"tfjs-backend-webgl":wJ,"tfjs-data":cz,"tfjs-layers":WE,"tfjs-converter":KM,tfjs:D8},M8=e=>"tensor"===e?"tensor":"base64",L8=({output:e,progressOutput:t,...n}={})=>({...n,output:M8(e),progressOutput:M8(t||e)}),z8={jsdelivr:(e,t,n)=>`https://cdn.jsdelivr.net/npm/${e}@${t}/${n}`,unpkg:(e,t,n)=>`https://unpkg.com/${e}@${t}/${n}`},P8=["jsdelivr","unpkg"],B8=(e,t,n)=>new Error([`Could not resolve URL ${t} for package ${null===n||void 0===n?void 0:n.name}@${null===n||void 0===n?void 0:n.version}`,"Errors include:",...e.map((([e,t])=>`- ${e}: ${t.message}`))].join("\n"));async function W8(e,t){const{modelType:n,_internals:r,path:s}=t;if(s)return await jk(e,s,n);if(!r)throw new Error(wk);const a=[];for(const i of P8){const t=z8[i];try{const s=t(r.name,r.version,r.path);return await jk(e,s,n)}catch(l7){a.push([i,l7 instanceof Error?l7:new Error(`There was an unknown error: ${JSON.stringify(l7)}`)])}}throw B8(a,s||r.path,r)}const V8=async(e,t)=>{const n=await t;try{jv(n)}catch(l7){if(rk(l7))throw Rk(l7.type,n);throw new Error(wk)}const r=Vk(n),s=await W8(e,r);return{model:s,modelDefinition:r}},U8="https://upscalerjs.com/documentation/troubleshooting#environment-disallows-base64",G8="https://upscalerjs.com/documentation/troubleshooting#environment-disallows-string-input",H8=()=>new Error(["Environment does not support a string URL as an input format.",`For more information, see ${G8}.`].join("\n")),j8=()=>new Error(["Environment does not support base64 as an output format.",`For more information, see ${U8}.`].join("\n")),q8=e=>new Error([`Unsupported dimensions for incoming pixels: ${e.shape.length}.`,"Only 3 or 4 rank tensors are supported."].join("\n")),K8=()=>new Error(["Failed to load image"].join(" ")),X8=e=>new Promise(((t,n)=>{const r=new Image;r.src=e,r.crossOrigin="anonymous",r.onload=()=>t(r),r.onerror=()=>n(K8())})),Y8=e=>dc(e),J8=async(e,t)=>{if(Vv(e))return e;if(Uv(e)){const t=await X8(e);return Y8(t)}return Y8(e)},Z8=async(e,t)=>{const n=await J8(t,e);if(Wv(n)){const e=n.expandDims(0);return n.dispose(),e}if(Bv(n))return n;throw q8(n)},Q8=(e,t)=>{const n=tI(e,t),[r,s]=t.shape,a=new ImageData(s,r);a.data.set(n);const i=document.createElement("canvas");i.width=s,i.height=r;const o=i.getContext("2d");if(!o)throw new Error("No context found");return o.putImageData(a,0,0),i.toDataURL()},e7=e=>{try{if(!0!==(new Image&&"createElement"in document))throw e()}catch(l7){throw e()}},t7=(e,{output:t="base64",progressOutput:n})=>{"string"===typeof e&&e7(H8),"base64"!==n&&"base64"!==t||e7(j8)};var n7=pI({tf:X,getUpscaleOptions:L8,loadModel:V8,getImageAsTensor:Z8,tensorAsBase64:Q8,checkValidEnvironment:t7}),r7=n(75912),s7={name:"UpscaleView",data(){return{metaInfo:{title:"Âú®Á∫øÂõæÁâáÈ´òÊ∏ÖÂåñÂ∑•ÂÖ∑ - AIÊîæÂ§ß‰∏çÊ®°Á≥ä",meta:[{name:"description",content:"‰∏ä‰º†Ê®°Á≥äÂõæÁâáÂêéÔºåÂà©Áî® AI ÊäÄÊúØÊó†ÊçüÊîæÂ§ßÔºåÊèêÂçáÊ∏ÖÊô∞Â∫¶ÔºåÈÄÇÂêàÂ§¥ÂÉè„ÄÅÊèíÁîª„ÄÅ‰∫ßÂìÅÂõæÁ≠âÂú∫ÊôØ„ÄÇ"},{name:"keywords",content:"ÂõæÁâáÂèòÊ∏ÖÊô∞,AIÊîæÂ§ßÂõæÁâá,Âú®Á∫øÈ´òÊ∏ÖÂåñ,ÂõæÁâáÂ¢ûÂº∫,ÂõæÂÉèÊîæÂ§ßÂ∑•ÂÖ∑"}]},imgs:[],multipleSelection:[],upscaler:null,loadingModel:!1,modelLoaded:!1,modelProgress:{key:"UpscalerJSÊ®°Âûã",current:"",total:"",progress:""},webglNotSupported:!1,aiFailed:!1,tileWidth:100,tileHeight:100,maxRetries:3}},async mounted(){if(!window.__PRERENDER_INJECTED__&&(this.webglNotSupported=!(window.WebGLRenderingContext&&document.createElement("canvas").getContext("webgl")),!this.webglNotSupported)){this.setupWebGLContextListeners(),this.loadingModel=!0,this.modelProgress.current="Âä†ËΩΩ‰∏≠",this.modelProgress.total="",this.modelProgress.progress="0";try{this.upscaler=new n7,!1===this.webglNotSupported&&await this.upscaler.upscale(document.createElement("canvas")),this.modelLoaded=!0,this.modelProgress.current="Â∑≤Âä†ËΩΩ",this.modelProgress.progress="100"}catch(e){console.error("Ê®°ÂûãÂä†ËΩΩÂ§±Ë¥•:",e),this.webglNotSupported=!0}finally{this.loadingModel=!1}}},methods:{formatFileSize(e){if(0===e)return"0 B";const t={TB:Math.pow(1024,4),GB:Math.pow(1024,3),MB:Math.pow(1024,2),KB:1024,B:1};function n(e){for(let n in t)if(e>=t[n])return n}const r=n(e),s=Math.round(e/t[r]*100)/100;return`${s} ${r}`},handleUploadChange(e,t){this.imgs=[];for(const n of t){const e=n.raw||n;let t={img:URL.createObjectURL(e),imgFile:e,upscaleImg:null,upscaleImgFile:null,imgError:!1,startTime:null,endTime:null,processing:!1,msg:"",progress:0,currentTile:0,totalTiles:0,currentTileX:0,currentTileY:0};e.type&&e.type.startsWith("image/gif")&&(t.imgError=!0,t.msg="gif‰∏çËÉΩÁî®"),this.imgs.push(t)}},isProcessing(){return this.imgs.some((e=>e.processing))},async upscaleMany(){console.log(`üöÄ ÂºÄÂßã‰∏≤Ë°åÂ§ÑÁêÜ${this.imgs.length}Âº†ÂõæÁâáÔºå‰∏ÄÂº†Âº†Â§ÑÁêÜÔºÅ`);for(let t=0;t<this.imgs.length;t++){const n=this.imgs[t];if(n.upscaleImg||n.processing)console.log(`‚è≠Ô∏è Ë∑≥ËøáÁ¨¨${t+1}/${this.imgs.length}Âº†ÂõæÁâá: ${n.imgFile.name} (Â∑≤Â§ÑÁêÜÊàñÊ≠£Âú®Â§ÑÁêÜ)`);else{console.log(`üìã ÂºÄÂßãÂ§ÑÁêÜÁ¨¨${t+1}/${this.imgs.length}Âº†ÂõæÁâá: ${n.imgFile.name}`);try{await this.upscale(n),console.log(`‚úÖ Á¨¨${t+1}/${this.imgs.length}Âº†ÂõæÁâáÂ§ÑÁêÜÂÆåÊàê: ${n.imgFile.name}`)}catch(e){console.error(`‚ùå Á¨¨${t+1}/${this.imgs.length}Âº†ÂõæÁâáÂ§ÑÁêÜÂ§±Ë¥•: ${n.imgFile.name}`,e),n.msg="Â§ÑÁêÜÂ§±Ë¥•: "+e.message,n.processing=!1}t<this.imgs.length-1&&(console.log("‚è≥ Á≠âÂæÖ1ÁßíÂêéÂ§ÑÁêÜ‰∏ã‰∏ÄÂº†ÂõæÁâá..."),await new Promise((e=>setTimeout(e,1e3))))}}console.log(`üéâ ÊâÄÊúâ${this.imgs.length}Âº†ÂõæÁâáÂ§ÑÁêÜÂÆåÊàêÔºÅ`)},async upscale(e){try{if(null!==e.upscaleImg)return;if(e.imgError)return void(e.msg="ÈÄâÊã©ÁöÑÂõæÁâáÊñá‰ª∂ÊúâËØØ");if(!e.img)return void(e.msg="Ê≤°‰∏ä‰º†");if(e.processing)return;e.msg="È´òÊ∏ÖÂ§ÑÁêÜ‰∏≠...",e.processing=!0,e.progress=0,e.startTime=(new Date).getTime(),console.log(`üéØ ÂºÄÂßãÂ§ÑÁêÜÂõæÁâá: ${e.imgFile.name}`);const t=new window.Image;t.src=e.img,await new Promise(((e,n)=>{t.onload=e,t.onerror=n})),console.log(`üì∑ ÂõæÁâáÂä†ËΩΩÂÆåÊàê: ${t.width}x${t.height}`);const{tileWidth:n,tileHeight:r,needTiling:s,warning:a}=this.calculateOptimalTileSize(t.width,t.height);console.log("ü§ñ Êô∫ËÉΩÂàÜÂùóÂà§Êñ≠:"),console.log(`   ÂõæÁâáÂ∞∫ÂØ∏: ${t.width}x${t.height}`),console.log("   ÊòØÂê¶ÈúÄË¶ÅÂàÜÂùó: "+(s?"ÊòØ":"Âê¶")),console.log(`   ÂàÜÂùóÂ∞∫ÂØ∏: ${n}x${r}`),a&&(console.log(`‚ö†Ô∏è Ë≠¶Âëä: ${a}`),this.$message.warning(a)),s?(console.log("üì¶ ÈÄâÊã©Â§ßÂõæÂàÜÂùóÂ§ÑÁêÜÊ®°Âºè"),await this.processLargeImage(t,e,n,r),console.log(`üéâ Â§ßÂõæÂàÜÂùóÂ§ÑÁêÜÂÆåÊàê: ${e.imgFile.name}`)):(console.log("üñºÔ∏è ÈÄâÊã©Â∞èÂõæÁõ¥Êé•Â§ÑÁêÜÊ®°Âºè"),await this.processSmallImage(t,e),console.log(`üéâ Â∞èÂõæÂ§ÑÁêÜÂÆåÊàê: ${e.imgFile.name}`))}catch(t){throw console.error(`‚ùå ÂõæÁâáÂ§ÑÁêÜÈîôËØØ: ${e.imgFile.name}`,t),e.upscaleImg&&URL.revokeObjectURL(e.upscaleImg),e.upscaleImg=null,e.upscaleImgFile=null,e.processing=!1,t.message.includes("ÂõæÁâáÂ∞∫ÂØ∏ËøáÂ§ß")?(e.msg="ÂõæÁâáÂ∞∫ÂØ∏ËøáÂ§ßÔºåËØ∑‰ΩøÁî®Êõ¥Â∞èÁöÑÂõæÁâá",this.$message.error("ÂõæÁâáÂ∞∫ÂØ∏ËøáÂ§ßÔºåËØ∑‰ΩøÁî®Â∞è‰∫é1024x1024ÁöÑÂõæÁâáÔºÅ")):t.message.includes("WebGL")||t.message.includes("shader")||t.message.includes("context")?(this.webglNotSupported=!0,this.aiFailed=!0,e.msg="WebGLÈîôËØØÔºöGPUÊÄßËÉΩ‰∏çË∂≥",this.$message.error("WebGLÈîôËØØÔºöGPUÊÄßËÉΩ‰∏çË∂≥ÊàñÊòæÂç°È©±Âä®ÈóÆÈ¢òÔºåËØ∑Âà∑Êñ∞È°µÈù¢ÊàñÊõ¥Êç¢ËÆæÂ§áÔºÅ")):(e.msg="È´òÊ∏ÖÂåñÂ§±Ë¥•ÔºöËÆæÂ§áÊÄßËÉΩ‰∏çË∂≥ÊàñÂõæÁâáËøáÂ§ß",this.aiFailed=!0,this.$message.error("È´òÊ∏ÖÂåñÂ§±Ë¥•ÔºöËÆæÂ§áÊÄßËÉΩ‰∏çË∂≥ÊàñÂõæÁâáËøáÂ§ßÔºåËØ∑Â∞ùËØïÊõ¥Êç¢ËÆæÂ§áÊàñÁº©Â∞èÂõæÁâáÂ∞∫ÂØ∏ÔºÅ")),window.gc&&window.gc(),t}},handleSelectionChange(e){this.multipleSelection=e},handleDeleteRow(e){const t=this.imgs[e];if(this.$refs.uploadRef){const e=this.$refs.uploadRef.uploadFiles.find((e=>e.raw===t.imgFile));e&&this.$refs.uploadRef.handleRemove(e)}t.upscaleImg&&URL.revokeObjectURL(t.upscaleImg),this.imgs.splice(e,1),window.gc&&window.gc()},handleBatchDelete(){this.multipleSelection.forEach((e=>{if(e.img&&URL.revokeObjectURL(e.img),e.upscaleImg&&URL.revokeObjectURL(e.upscaleImg),this.$refs.uploadRef){const t=this.$refs.uploadRef.uploadFiles.find((t=>t.raw===e.imgFile));t&&this.$refs.uploadRef.handleRemove(t)}})),this.imgs=this.imgs.filter((e=>!this.multipleSelection.includes(e))),this.multipleSelection=[],this.$refs.imgTable&&this.$refs.imgTable.clearSelection(),window.gc&&window.gc()},calculateOptimalTileSize(e,t){const n=e*t,r=(n/1048576).toFixed(1);let s=null;const a=this.tileWidth,i=this.tileHeight,o=Math.ceil(e/a),u=Math.ceil(t/i),l=o*u;return l>1e4?s=`Ê£ÄÊµãÂà∞${r}MPÂ∑®Â§ßÂõæÔºåÂ∞ÜÂàÜ‰∏∫${l}ÂùóÂ§ÑÁêÜÔºåÂ§ÑÁêÜÊó∂Èó¥ÊûÅÈïøÔºÅ`:l>5e3?s=`Ê£ÄÊµãÂà∞${r}MPË∂ÖÂ§ßÂõæÔºåÂ∞ÜÂàÜ‰∏∫${l}ÂùóÂ§ÑÁêÜÔºåÂ§ÑÁêÜÊó∂Èó¥ÂæàÈïøÔºÅ`:l>1e3?s=`Ê£ÄÊµãÂà∞${r}MPÂ§ßÂõæÔºåÂ∞ÜÂàÜ‰∏∫${l}ÂùóÂ§ÑÁêÜÔºåÈ¢ÑËÆ°ÈúÄË¶ÅËæÉÈïøÊó∂Èó¥`:l>100&&(s=`Ê£ÄÊµãÂà∞${r}MPÂõæÁâáÔºåÂ∞ÜÂàÜ‰∏∫${l}ÂùóÂ§ÑÁêÜ`),console.log("üìè Ëá™ÂÆö‰πâÂàÜÂùóËÆ°ÁÆó:"),console.log(`   ÂõæÁâáÂ∞∫ÂØ∏: ${e}x${t}`),console.log(`   ÂàÜÂùóÂ∞∫ÂØ∏: ${a}x${i} (Áî®Êà∑ËÆæÁΩÆ)`),console.log(`   ÂàÜÂùóÊï∞Èáè: ${o}x${u} = ${l}Âùó`),console.log("   ÊâÄÊúâÂõæÁâáÈÉΩÂàÜÂùóÂ§ÑÁêÜÔºÅ"),{tileWidth:a,tileHeight:i,needTiling:!0,warning:s}},async processSmallImage(e,t){console.log("üìä Â∞èÂõæÁõ¥Êé•Â§ÑÁêÜ:"),console.log(`   ÂõæÁâáÂ∞∫ÂØ∏: ${e.width}x${e.height}`),console.log("   Â§ÑÁêÜÊñπÂºè: Áõ¥Êé•È´òÊ∏ÖÂåñ"),t.progress=10,t.msg="Â∞èÂõæÈ´òÊ∏ÖÂåñÂ§ÑÁêÜ‰∏≠...",console.log("‚ö° ÂºÄÂßãÂ∞èÂõæÈ´òÊ∏ÖÂåñ..."),t.progress=50;const n=await this.upscaler.upscale(e);console.log("‚úÖ Â∞èÂõæÈ´òÊ∏ÖÂåñÂÆåÊàê"),t.progress=80,t.upscaleImg=n;const r=await fetch(n),s=await r.blob();t.upscaleImgFile=s,t.endTime=(new Date).getTime(),t.processing=!1,t.progress=100,t.msg="ÂÆåÊàê",console.log(`üéâ Â∞èÂõæÂ§ÑÁêÜÂÆåÊàêÔºåÊÄªÁî®Êó∂: ${Math.floor((t.endTime-t.startTime)/1e3)}Áßí`)},async processLargeImage(e,t,n,r){const{width:s,height:a}=e,i=2,o=Math.ceil(s/n),u=Math.ceil(a/r),l=o*u,c=Math.ceil(3*l/60);t.msg=`üöÄ ${n}x${r}ÂàÜÂùóÂ§ÑÁêÜ (${o}x${u}=${l}Âùó, È¢ÑËÆ°${c}ÂàÜÈíü)`,t.progress=0,t.startTime=(new Date).getTime(),t.totalTiles=l,t.currentTile=0,console.log(`üìä ÂºÄÂßã${n}x${r}ÂàÜÂùóÂ§ÑÁêÜ:`),console.log(`   ÂõæÁâáÂ∞∫ÂØ∏: ${s}x${a}`),console.log(`   ÂàÜÂùóÂ∞∫ÂØ∏: ${n}x${r} (Áî®Êà∑ËÆæÁΩÆ)`),console.log(`   ÂàÜÂùóÊï∞Èáè: ${o}x${u} = ${l}Âùó`),console.log(`   È¢ÑËÆ°Êó∂Èó¥: ${c}ÂàÜÈíü`),console.log(`   ÊúÄÂ§ßÈáçËØïÊ¨°Êï∞: ${this.maxRetries}Ê¨°`),console.log("   ËøõÂ∫¶ËÆ°ÁÆó: ÂΩìÂâçÂàÜÁâá/ÊÄªÂàÜÁâáÊï∞Èáè");const h=document.createElement("canvas");h.width=s*i,h.height=a*i;const p=h.getContext("2d");let d=0;for(let m=0;m<u;m++)for(let u=0;u<o;u++){const o=u*n,c=m*r,g=Math.min(n,s-o),y=Math.min(r,a-c);console.log(`üîç ÂàáÂá∫Á¨¨${d+1}ÁâáÂ∞èÂõæ [${u+1},${m+1}]:`),console.log(`   ‰ΩçÁΩÆ: (${o}, ${c})`),console.log(`   Â∞∫ÂØ∏: ${g}x${y}`),console.log(`   ËåÉÂõ¥: X[${o}-${o+g}], Y[${c}-${c+y}]`);const b=document.createElement("canvas");b.width=g,b.height=y;const x=b.getContext("2d");x.drawImage(e,o,c,g,y,0,0,g,y);let w=0,v=null,k=!1;while(w<this.maxRetries&&!k)try{const e=w>0?` (ÈáçËØï${w}/${this.maxRetries})`:"";console.log(`‚ö° ÂºÄÂßãÈ´òÊ∏ÖÂåñÁ¨¨${d+1}ÁâáÂ∞èÂõæ[${u+1},${m+1}]${e}...`),v=await this.upscaler.upscale(b),k=!0,w>0&&console.log(`‚úÖ Á¨¨${d+1}ÁâáÂ∞èÂõæÈáçËØï${w}Ê¨°ÂêéÊàêÂäü`)}catch(f){if(w++,console.error(`‚ùå Á¨¨${d+1}ÁâáÂ∞èÂõæÂ§ÑÁêÜÂ§±Ë¥• (Â∞ùËØï${w}/${this.maxRetries}):`,f.message),!(w<this.maxRetries)){console.error(`üí• Á¨¨${d+1}ÁâáÂ∞èÂõæÈáçËØï${this.maxRetries}Ê¨°Âêé‰ªçÁÑ∂Â§±Ë¥•ÔºåË∑≥ËøáÊ≠§ÂàÜÁâá`);break}console.log(`üîÑ ÂáÜÂ§áÈáçËØïÁ¨¨${d+1}ÁâáÂ∞èÂõæ...`),await new Promise((e=>setTimeout(e,1e3)))}if(k&&v)try{const e=new Image;await new Promise(((t,n)=>{e.onload=t,e.onerror=n,e.src=v})),console.log(`‚úÖ Á¨¨${d+1}ÁâáÂ∞èÂõæÈ´òÊ∏ÖÂåñÂÆåÊàê:`),console.log(`   ÂéüÂßãÂ∞∫ÂØ∏: ${g}x${y}`),console.log(`   È´òÊ∏ÖÂ∞∫ÂØ∏: ${e.width}x${e.height}`),console.log(`   ÊîæÂ§ßÂÄçÊï∞: ${(e.width/g).toFixed(1)}x`),console.log(`üîó ÂêàÂπ∂Á¨¨${d+1}ÁâáÂà∞ÁªìÊûúÂõæ...`),p.drawImage(e,o*i,c*i,g*i,y*i);const n=h.toDataURL("image/jpeg",.9);t.upscaleImg=n,console.log(`üé® ÂÆûÊó∂ÊòæÁ§∫: Â∑≤ÂÆåÊàê${d+1}/${l}ÁâáÁöÑÁªìÊûúÂõæ`),console.log(`üóëÔ∏è ÈáäÊîæÁ¨¨${d+1}ÁâáÂ∞èÂõæËµÑÊ∫ê`),b.width=0,b.height=0,e.src=""}catch(f){console.error(`ÂêàÂπ∂Á¨¨${d+1}ÁâáÊó∂Âá∫Èîô:`,f),p.drawImage(e,o,c,g,y,o*i,c*i,g*i,y*i)}else console.log(`‚ö†Ô∏è Á¨¨${d+1}ÁâáÂ§ÑÁêÜÂ§±Ë¥•Ôºå‰ΩøÁî®ÂéüÂõæÊõø‰ª£`),p.drawImage(e,o,c,g,y,o*i,c*i,g*i,y*i);d++,t.progress=Math.round(d/l*100);const I=(new Date).getTime(),N=(I-t.startTime)/1e3,S=N/d,T=l-d,$=Math.ceil(T*S/60),C=u+1,E=m+1;t.msg=`üîÑ Â§ÑÁêÜÂàÜÁâá[${C},${E}] Á¨¨${d}/${l}Âùó (${t.progress}%) Ââ©‰Ωô${$}ÂàÜÈíü`,t.currentTile=d,t.totalTiles=l,t.currentTileX=C,t.currentTileY=E,console.log(`üîÑ Ê≠£Âú®Â§ÑÁêÜ: Á¨¨${d}Âùó/${l}Âùó - ÂàÜÁâá[${C},${E}] - Â∞∫ÂØ∏${g}x${y} - ËøõÂ∫¶${t.progress}% (${d}/${l}) - Ââ©‰Ωô${$}ÂàÜÈíü`),await new Promise((e=>setTimeout(e,10))),d%4===0&&window.gc&&window.gc()}h.toBlob((e=>{t.upscaleImg=URL.createObjectURL(e),t.upscaleImgFile=e,t.endTime=(new Date).getTime(),t.processing=!1,t.progress=100,t.msg="ÂÆåÊàê",h.width=0,h.height=0}),"image/png")},setupWebGLContextListeners(){window.addEventListener("webglcontextlost",(e=>{e.preventDefault(),console.warn("WebGL‰∏ä‰∏ãÊñá‰∏¢Â§±ÔºåÁ¶ÅÁî®AIÈ´òÊ∏ÖÂåñÂäüËÉΩ"),this.webglNotSupported=!0,this.aiFailed=!0,this.$message.error("GPUÂÜÖÂ≠ò‰∏çË∂≥ÂØºËá¥WebGL‰∏ä‰∏ãÊñá‰∏¢Â§±ÔºåËØ∑Âà∑Êñ∞È°µÈù¢ÔºÅ")})),window.addEventListener("webglcontextrestored",(()=>{console.log("WebGL‰∏ä‰∏ãÊñáÂ∑≤ÊÅ¢Â§ç"),this.$message.info("WebGL‰∏ä‰∏ãÊñáÂ∑≤ÊÅ¢Â§çÔºåÂª∫ËÆÆÂà∑Êñ∞È°µÈù¢ÈáçÊñ∞ÂàùÂßãÂåñ")}))},async downloadImg(e){if(!e.upscaleImgFile||!e.imgFile)return void this.$message.warning("ÂõæÁâáËøòÊú™Â§ÑÁêÜÂÆåÊàêÔºÅ");const t=e.imgFile.name.replace(/\.[^.]+$/,"")+"_hd.png";await r7.A.downloadFile(e.upscaleImgFile,t)},async handleDownloadZip(){const e=this.imgs.filter((e=>e.upscaleImgFile&&e.imgFile&&e.imgFile.name)).map((e=>({file:e.upscaleImgFile,save_name:e.imgFile.name.replace(/\.[^.]+$/,"")+"_hd.png"})));0!==e.length?await r7.A.downloadAsZip(e,`upscale_${Date.now()}.zip`,"file","save_name"):this.$message.warning("Ê≤°ÊúâÂèØÊâìÂåÖÁöÑÈ´òÊ∏ÖÂõæÁâáÔºÅ")}},beforeDestroy(){this.imgs.forEach((e=>{e.upscaleImg&&URL.revokeObjectURL(e.upscaleImg)})),this.upscaler&&this.upscaler.terminate&&this.upscaler.terminate(),window.gc&&window.gc()}},a7=s7,i7=n(81656),o7=(0,i7.A)(a7,Y,J,!1,null,"0944d600",null),u7=o7.exports},18860:function(e,t,n){n(16280),n(16573),n(78100),n(77936),n(48140),n(21903),n(91134),n(28845),n(37467),n(44732),n(79577),e.exports=s;var r=null;try{r=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(E){}function s(e,t,n){this.low=0|e,this.high=0|t,this.unsigned=!!n}function a(e){return!0===(e&&e["__isLong__"])}s.prototype.__isLong__,Object.defineProperty(s.prototype,"__isLong__",{value:!0}),s.isLong=a;var i={},o={};function u(e,t){var n,r,s;return t?(e>>>=0,(s=0<=e&&e<256)&&(r=o[e],r)?r:(n=c(e,(0|e)<0?-1:0,!0),s&&(o[e]=n),n)):(e|=0,(s=-128<=e&&e<128)&&(r=i[e],r)?r:(n=c(e,e<0?-1:0,!1),s&&(i[e]=n),n))}function l(e,t){if(isNaN(e))return t?v:w;if(t){if(e<0)return v;if(e>=y)return T}else{if(e<=-b)return $;if(e+1>=b)return S}return e<0?l(-e,t).neg():c(e%g|0,e/g|0,t)}function c(e,t,n){return new s(e,t,n)}s.fromInt=u,s.fromNumber=l,s.fromBits=c;var h=Math.pow;function p(e,t,n){if(0===e.length)throw Error("empty string");if("NaN"===e||"Infinity"===e||"+Infinity"===e||"-Infinity"===e)return w;if("number"===typeof t?(n=t,t=!1):t=!!t,n=n||10,n<2||36<n)throw RangeError("radix");var r;if((r=e.indexOf("-"))>0)throw Error("interior hyphen");if(0===r)return p(e.substring(1),t,n).neg();for(var s=l(h(n,8)),a=w,i=0;i<e.length;i+=8){var o=Math.min(8,e.length-i),u=parseInt(e.substring(i,i+o),n);if(o<8){var c=l(h(n,o));a=a.mul(c).add(l(u))}else a=a.mul(s),a=a.add(l(u))}return a.unsigned=t,a}function d(e,t){return"number"===typeof e?l(e,t):"string"===typeof e?p(e,t):c(e.low,e.high,"boolean"===typeof t?t:e.unsigned)}s.fromString=p,s.fromValue=d;var f=65536,m=1<<24,g=f*f,y=g*g,b=y/2,x=u(m),w=u(0);s.ZERO=w;var v=u(0,!0);s.UZERO=v;var k=u(1);s.ONE=k;var I=u(1,!0);s.UONE=I;var N=u(-1);s.NEG_ONE=N;var S=c(-1,2147483647,!1);s.MAX_VALUE=S;var T=c(-1,-1,!0);s.MAX_UNSIGNED_VALUE=T;var $=c(0,-2147483648,!1);s.MIN_VALUE=$;var C=s.prototype;C.toInt=function(){return this.unsigned?this.low>>>0:this.low},C.toNumber=function(){return this.unsigned?(this.high>>>0)*g+(this.low>>>0):this.high*g+(this.low>>>0)},C.toString=function(e){if(e=e||10,e<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq($)){var t=l(e),n=this.div(t),r=n.mul(t).sub(this);return n.toString(e)+r.toInt().toString(e)}return"-"+this.neg().toString(e)}var s=l(h(e,6),this.unsigned),a=this,i="";while(1){var o=a.div(s),u=a.sub(o.mul(s)).toInt()>>>0,c=u.toString(e);if(a=o,a.isZero())return c+i;while(c.length<6)c="0"+c;i=""+c+i}},C.getHighBits=function(){return this.high},C.getHighBitsUnsigned=function(){return this.high>>>0},C.getLowBits=function(){return this.low},C.getLowBitsUnsigned=function(){return this.low>>>0},C.getNumBitsAbs=function(){if(this.isNegative())return this.eq($)?64:this.neg().getNumBitsAbs();for(var e=0!=this.high?this.high:this.low,t=31;t>0;t--)if(0!=(e&1<<t))break;return 0!=this.high?t+33:t+1},C.isZero=function(){return 0===this.high&&0===this.low},C.eqz=C.isZero,C.isNegative=function(){return!this.unsigned&&this.high<0},C.isPositive=function(){return this.unsigned||this.high>=0},C.isOdd=function(){return 1===(1&this.low)},C.isEven=function(){return 0===(1&this.low)},C.equals=function(e){return a(e)||(e=d(e)),(this.unsigned===e.unsigned||this.high>>>31!==1||e.high>>>31!==1)&&(this.high===e.high&&this.low===e.low)},C.eq=C.equals,C.notEquals=function(e){return!this.eq(e)},C.neq=C.notEquals,C.ne=C.notEquals,C.lessThan=function(e){return this.comp(e)<0},C.lt=C.lessThan,C.lessThanOrEqual=function(e){return this.comp(e)<=0},C.lte=C.lessThanOrEqual,C.le=C.lessThanOrEqual,C.greaterThan=function(e){return this.comp(e)>0},C.gt=C.greaterThan,C.greaterThanOrEqual=function(e){return this.comp(e)>=0},C.gte=C.greaterThanOrEqual,C.ge=C.greaterThanOrEqual,C.compare=function(e){if(a(e)||(e=d(e)),this.eq(e))return 0;var t=this.isNegative(),n=e.isNegative();return t&&!n?-1:!t&&n?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1},C.comp=C.compare,C.negate=function(){return!this.unsigned&&this.eq($)?$:this.not().add(k)},C.neg=C.negate,C.add=function(e){a(e)||(e=d(e));var t=this.high>>>16,n=65535&this.high,r=this.low>>>16,s=65535&this.low,i=e.high>>>16,o=65535&e.high,u=e.low>>>16,l=65535&e.low,h=0,p=0,f=0,m=0;return m+=s+l,f+=m>>>16,m&=65535,f+=r+u,p+=f>>>16,f&=65535,p+=n+o,h+=p>>>16,p&=65535,h+=t+i,h&=65535,c(f<<16|m,h<<16|p,this.unsigned)},C.subtract=function(e){return a(e)||(e=d(e)),this.add(e.neg())},C.sub=C.subtract,C.multiply=function(e){if(this.isZero())return w;if(a(e)||(e=d(e)),r){var t=r.mul(this.low,this.high,e.low,e.high);return c(t,r.get_high(),this.unsigned)}if(e.isZero())return w;if(this.eq($))return e.isOdd()?$:w;if(e.eq($))return this.isOdd()?$:w;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(x)&&e.lt(x))return l(this.toNumber()*e.toNumber(),this.unsigned);var n=this.high>>>16,s=65535&this.high,i=this.low>>>16,o=65535&this.low,u=e.high>>>16,h=65535&e.high,p=e.low>>>16,f=65535&e.low,m=0,g=0,y=0,b=0;return b+=o*f,y+=b>>>16,b&=65535,y+=i*f,g+=y>>>16,y&=65535,y+=o*p,g+=y>>>16,y&=65535,g+=s*f,m+=g>>>16,g&=65535,g+=i*p,m+=g>>>16,g&=65535,g+=o*h,m+=g>>>16,g&=65535,m+=n*f+s*p+i*h+o*u,m&=65535,c(y<<16|b,m<<16|g,this.unsigned)},C.mul=C.multiply,C.divide=function(e){if(a(e)||(e=d(e)),e.isZero())throw Error("division by zero");if(r){if(!this.unsigned&&-2147483648===this.high&&-1===e.low&&-1===e.high)return this;var t=(this.unsigned?r.div_u:r.div_s)(this.low,this.high,e.low,e.high);return c(t,r.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?v:w;var n,s,i;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return v;if(e.gt(this.shru(1)))return I;i=v}else{if(this.eq($)){if(e.eq(k)||e.eq(N))return $;if(e.eq($))return k;var o=this.shr(1);return n=o.div(e).shl(1),n.eq(w)?e.isNegative()?k:N:(s=this.sub(e.mul(n)),i=n.add(s.div(e)),i)}if(e.eq($))return this.unsigned?v:w;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();i=w}s=this;while(s.gte(e)){n=Math.max(1,Math.floor(s.toNumber()/e.toNumber()));var u=Math.ceil(Math.log(n)/Math.LN2),p=u<=48?1:h(2,u-48),f=l(n),m=f.mul(e);while(m.isNegative()||m.gt(s))n-=p,f=l(n,this.unsigned),m=f.mul(e);f.isZero()&&(f=k),i=i.add(f),s=s.sub(m)}return i},C.div=C.divide,C.modulo=function(e){if(a(e)||(e=d(e)),r){var t=(this.unsigned?r.rem_u:r.rem_s)(this.low,this.high,e.low,e.high);return c(t,r.get_high(),this.unsigned)}return this.sub(this.div(e).mul(e))},C.mod=C.modulo,C.rem=C.modulo,C.not=function(){return c(~this.low,~this.high,this.unsigned)},C.and=function(e){return a(e)||(e=d(e)),c(this.low&e.low,this.high&e.high,this.unsigned)},C.or=function(e){return a(e)||(e=d(e)),c(this.low|e.low,this.high|e.high,this.unsigned)},C.xor=function(e){return a(e)||(e=d(e)),c(this.low^e.low,this.high^e.high,this.unsigned)},C.shiftLeft=function(e){return a(e)&&(e=e.toInt()),0===(e&=63)?this:e<32?c(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):c(0,this.low<<e-32,this.unsigned)},C.shl=C.shiftLeft,C.shiftRight=function(e){return a(e)&&(e=e.toInt()),0===(e&=63)?this:e<32?c(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):c(this.high>>e-32,this.high>=0?0:-1,this.unsigned)},C.shr=C.shiftRight,C.shiftRightUnsigned=function(e){if(a(e)&&(e=e.toInt()),e&=63,0===e)return this;var t=this.high;if(e<32){var n=this.low;return c(n>>>e|t<<32-e,t>>>e,this.unsigned)}return c(32===e?t:t>>>e-32,0,this.unsigned)},C.shru=C.shiftRightUnsigned,C.shr_u=C.shiftRightUnsigned,C.toSigned=function(){return this.unsigned?c(this.low,this.high,!1):this},C.toUnsigned=function(){return this.unsigned?this:c(this.low,this.high,!0)},C.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()},C.toBytesLE=function(){var e=this.high,t=this.low;return[255&t,t>>>8&255,t>>>16&255,t>>>24,255&e,e>>>8&255,e>>>16&255,e>>>24]},C.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,255&e,t>>>24,t>>>16&255,t>>>8&255,255&t]},s.fromBytes=function(e,t,n){return n?s.fromBytesLE(e,t):s.fromBytesBE(e,t)},s.fromBytesLE=function(e,t){return new s(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)},s.fromBytesBE=function(e,t){return new s(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)}},70928:function(e,t,n){var r=n(13785),s=n(54008),a=n(71030),i=n(33404),o=n(99018),u=n(65396),l=n(70336);l.alea=r,l.xor128=s,l.xorwow=a,l.xorshift7=i,l.xor4096=o,l.tychei=u,e.exports=l},13785:function(e,t,n){var r;e=n.nmd(e),function(e,s){function a(e){var t=this,n=u();t.next=function(){var e=2091639*t.s0+2.3283064365386963e-10*t.c;return t.s0=t.s1,t.s1=t.s2,t.s2=e-(t.c=0|e)},t.c=1,t.s0=n(" "),t.s1=n(" "),t.s2=n(" "),t.s0-=n(e),t.s0<0&&(t.s0+=1),t.s1-=n(e),t.s1<0&&(t.s1+=1),t.s2-=n(e),t.s2<0&&(t.s2+=1),n=null}function i(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function o(e,t){var n=new a(e),r=t&&t.state,s=n.next;return s.int32=function(){return 4294967296*n.next()|0},s.double=function(){return s()+11102230246251565e-32*(2097152*s()|0)},s.quick=s,r&&("object"==typeof r&&i(r,n),s.state=function(){return i(n,{})}),s}function u(){var e=4022871197,t=function(t){t=String(t);for(var n=0;n<t.length;n++){e+=t.charCodeAt(n);var r=.02519603282416938*e;e=r>>>0,r-=e,r*=e,e=r>>>0,r-=e,e+=4294967296*r}return 2.3283064365386963e-10*(e>>>0)};return t}s&&s.exports?s.exports=o:n.amdD&&n.amdO?(r=function(){return o}.call(t,n,t,s),void 0===r||(s.exports=r)):this.alea=o}(0,e,n.amdD)},65396:function(e,t,n){var r;e=n.nmd(e),function(e,s){function a(e){var t=this,n="";t.next=function(){var e=t.b,n=t.c,r=t.d,s=t.a;return e=e<<25^e>>>7^n,n=n-r|0,r=r<<24^r>>>8^s,s=s-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-r|0,t.d=r<<16^n>>>16^s,t.a=s-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var r=0;r<n.length+20;r++)t.b^=0|n.charCodeAt(r),t.next()}function i(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function o(e,t){var n=new a(e),r=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=n.next()>>>11,t=(n.next()>>>0)/4294967296,r=(e+t)/(1<<21)}while(0===r);return r},s.int32=n.next,s.quick=s,r&&("object"==typeof r&&i(r,n),s.state=function(){return i(n,{})}),s}s&&s.exports?s.exports=o:n.amdD&&n.amdO?(r=function(){return o}.call(t,n,t,s),void 0===r||(s.exports=r)):this.tychei=o}(0,e,n.amdD)},54008:function(e,t,n){var r;e=n.nmd(e),function(e,s){function a(e){var t=this,n="";t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),t.next()}function i(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function o(e,t){var n=new a(e),r=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=n.next()>>>11,t=(n.next()>>>0)/4294967296,r=(e+t)/(1<<21)}while(0===r);return r},s.int32=n.next,s.quick=s,r&&("object"==typeof r&&i(r,n),s.state=function(){return i(n,{})}),s}s&&s.exports?s.exports=o:n.amdD&&n.amdO?(r=function(){return o}.call(t,n,t,s),void 0===r||(s.exports=r)):this.xor128=o}(0,e,n.amdD)},99018:function(e,t,n){var r;e=n.nmd(e),function(e,s){function a(e){var t=this;function n(e,t){var n,r,s,a,i,o=[],u=128;for(t===(0|t)?(r=t,t=null):(t+="\0",r=0,u=Math.max(u,t.length)),s=0,a=-32;a<u;++a)t&&(r^=t.charCodeAt((a+32)%t.length)),0===a&&(i=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,a>=0&&(i=i+1640531527|0,n=o[127&a]^=r+i,s=0==n?s+1:0);for(s>=128&&(o[127&(t&&t.length||0)]=-1),s=127,a=512;a>0;--a)r=o[s+34&127],n=o[s=s+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,o[s]=r^n;e.w=i,e.X=o,e.i=s}t.next=function(){var e,n,r=t.w,s=t.X,a=t.i;return t.w=r=r+1640531527|0,n=s[a+34&127],e=s[a=a+1&127],n^=n<<13,e^=e<<17,n^=n>>>15,e^=e>>>12,n=s[a]=n^e,t.i=a,n+(r^r>>>16)|0},n(t,e)}function i(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function o(e,t){null==e&&(e=+new Date);var n=new a(e),r=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=n.next()>>>11,t=(n.next()>>>0)/4294967296,r=(e+t)/(1<<21)}while(0===r);return r},s.int32=n.next,s.quick=s,r&&(r.X&&i(r,n),s.state=function(){return i(n,{})}),s}s&&s.exports?s.exports=o:n.amdD&&n.amdO?(r=function(){return o}.call(t,n,t,s),void 0===r||(s.exports=r)):this.xor4096=o}(0,e,n.amdD)},33404:function(e,t,n){var r;e=n.nmd(e),n(44114),function(e,s){function a(e){var t=this;function n(e,t){var n,r=[];if(t===(0|t))r[0]=t;else for(t=""+t,n=0;n<t.length;++n)r[7&n]=r[7&n]<<15^t.charCodeAt(n)+r[n+1&7]<<13;while(r.length<8)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n?r[7]=-1:r[n],e.x=r,e.i=0,n=256;n>0;--n)e.next()}t.next=function(){var e,n,r=t.x,s=t.i;return e=r[s],e^=e>>>7,n=e^e<<24,e=r[s+1&7],n^=e^e>>>10,e=r[s+3&7],n^=e^e>>>3,e=r[s+4&7],n^=e^e<<7,e=r[s+7&7],e^=e<<13,n^=e^e<<9,r[s]=n,t.i=s+1&7,n},n(t,e)}function i(e,t){return t.x=e.x.slice(),t.i=e.i,t}function o(e,t){null==e&&(e=+new Date);var n=new a(e),r=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=n.next()>>>11,t=(n.next()>>>0)/4294967296,r=(e+t)/(1<<21)}while(0===r);return r},s.int32=n.next,s.quick=s,r&&(r.x&&i(r,n),s.state=function(){return i(n,{})}),s}s&&s.exports?s.exports=o:n.amdD&&n.amdO?(r=function(){return o}.call(t,n,t,s),void 0===r||(s.exports=r)):this.xorshift7=o}(0,e,n.amdD)},71030:function(e,t,n){var r;e=n.nmd(e),function(e,s){function a(e){var t=this,n="";t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),r==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function i(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function o(e,t){var n=new a(e),r=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=n.next()>>>11,t=(n.next()>>>0)/4294967296,r=(e+t)/(1<<21)}while(0===r);return r},s.int32=n.next,s.quick=s,r&&("object"==typeof r&&i(r,n),s.state=function(){return i(n,{})}),s}s&&s.exports?s.exports=o:n.amdD&&n.amdO?(r=function(){return o}.call(t,n,t,s),void 0===r||(s.exports=r)):this.xorwow=o}(0,e,n.amdD)},70336:function(e,t,n){var r;n(44114),n(16573),n(78100),n(77936),n(48140),n(21903),n(91134),n(28845),n(37467),n(44732),n(79577),n(13611),function(s,a,i){var o,u=256,l=6,c=52,h="random",p=i.pow(u,l),d=i.pow(2,c),f=2*d,m=u-1;function g(e,t,n){var r=[];t=1==t?{entropy:!0}:t||{};var s=w(x(t.entropy?[e,k(a)]:null==e?v():e,3),r),o=new y(r),c=function(){var e=o.g(l),t=p,n=0;while(e<d)e=(e+n)*u,t*=u,n=o.g(1);while(e>=f)e/=2,t/=2,n>>>=1;return(e+n)/t};return c.int32=function(){return 0|o.g(4)},c.quick=function(){return o.g(4)/4294967296},c.double=c,w(k(o.S),a),(t.pass||n||function(e,t,n,r){return r&&(r.S&&b(r,o),e.state=function(){return b(o,{})}),n?(i[h]=e,t):e})(c,s,"global"in t?t.global:this==i,t.state)}function y(e){var t,n=e.length,r=this,s=0,a=r.i=r.j=0,i=r.S=[];n||(e=[n++]);while(s<u)i[s]=s++;for(s=0;s<u;s++)i[s]=i[a=m&a+e[s%n]+(t=i[s])],i[a]=t;(r.g=function(e){var t,n=0,s=r.i,a=r.j,i=r.S;while(e--)t=i[s=m&s+1],n=n*u+i[m&(i[s]=i[a=m&a+t])+(i[a]=t)];return r.i=s,r.j=a,n})(u)}function b(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function x(e,t){var n,r=[],s=typeof e;if(t&&"object"==s)for(n in e)try{r.push(x(e[n],t-1))}catch(a){}return r.length?r:"string"==s?e:e+"\0"}function w(e,t){var n,r=e+"",s=0;while(s<r.length)t[m&s]=m&(n^=19*t[m&s])+r.charCodeAt(s++);return k(t)}function v(){try{var e;return o&&(e=o.randomBytes)?e=e(u):(e=new Uint8Array(u),(s.crypto||s.msCrypto).getRandomValues(e)),k(e)}catch(r){var t=s.navigator,n=t&&t.plugins;return[+new Date,s,n,s.screen,k(a)]}}function k(e){return String.fromCharCode.apply(0,e)}if(w(i.random(),a),e.exports){e.exports=g;try{o=n(41234)}catch(I){}}else r=function(){return g}.call(t,n,t,e),void 0===r||(e.exports=r)}("undefined"!==typeof self?self:this,[],Math)},75912:function(e,t,n){"use strict";n(16280),n(14603),n(47566),n(98721);var r=n(44813),s=n.n(r);class a{static formatBytes(e){if(0===e)return"0 Bytes";const t=1024,n=["Bytes","KB","MB","GB","TB"],r=Math.floor(Math.log(e)/Math.log(t));return parseFloat((e/Math.pow(t,r)).toFixed(2))+" "+n[r]}static getFileExtension(e){return e.slice(2+(e.lastIndexOf(".")-1>>>0))}static getExt(e){return e.split(".").pop().toLowerCase()}static getFileNameWithoutExtension(e){return e.replace(/\.[^/.]+$/,"")}static getBaseName(e){const t=-1===e.lastIndexOf(".")?e:e.substring(0,e.lastIndexOf("."));return t}static isImageFile(e){const t=["jpg","jpeg","png","gif","bmp","webp","svg"],n=this.getFileExtension(e).toLowerCase();return t.includes(n)}static isVideoFile(e){const t=["mp4","avi","mov","wmv","flv","webm","mkv"],n=this.getFileExtension(e).toLowerCase();return t.includes(n)}static isAudioFile(e){const t=["mp3","wav","flac","aac","ogg","wma"],n=this.getFileExtension(e).toLowerCase();return t.includes(n)}static isDocumentFile(e){const t=["pdf","doc","docx","xls","xlsx","ppt","pptx","txt"],n=this.getFileExtension(e).toLowerCase();return t.includes(n)}static generateUniqueFileName(e){const t=Date.now(),n=Math.random().toString(36).substring(2,8),r=this.getFileExtension(e),s=this.getFileNameWithoutExtension(e);return`${s}_${t}_${n}.${r}`}static fileToBase64(e){return new Promise(((t,n)=>{const r=new FileReader;r.readAsDataURL(e),r.onload=()=>t(r.result),r.onerror=e=>n(e)}))}static downloadFile(e,t){const n=document.createElement("a");n.href=e,n.download=t,document.body.appendChild(n),n.click(),document.body.removeChild(n)}static blobToFile(e,t){return new File([e],t,{type:e.type})}static fileToBlob(e){return e instanceof Blob?e:new Blob([e],{type:e.type})}static isBlob(e){return e instanceof Blob}static async getBlobByUrl(e){if(a.isBlob(e))return e;try{const t=await fetch(e);if(!t.ok)throw new Error("Network response was not ok: "+t.statusText);return await t.blob()}catch(t){throw console.error("Error fetching the blob:",t),t}}static async download(e,t){let n=null;n=a.isBlob(e)?e:await a.getBlobByUrl(e);const r=URL.createObjectURL(n),s=document.createElement("a");s.href=r,s.download=t,document.body.appendChild(s),s.click(),document.body.removeChild(s),URL.revokeObjectURL(r)}static async downloadAsZip(e,t=(new Date).getTime()+".zip",n="file_url",r="save_name"){const i=new(s());for(const s of e){const e=await a.getBlobByUrl(s[n]);i.file(s[r],e)}try{const e=await i.generateAsync({type:"blob"});await a.download(e,t)}catch(o){console.error("Error while generating zip:",o)}}static compressImage(e,t=.8,n=1920,r=1080){return new Promise((s=>{const a=document.createElement("canvas"),i=a.getContext("2d"),o=new Image;o.onload=()=>{let{width:u,height:l}=o;u>n&&(l=l*n/u,u=n),l>r&&(u=u*r/l,l=r),a.width=u,a.height=l,i.drawImage(o,0,0,u,l),a.toBlob((t=>{const n=new File([t],e.name,{type:e.type,lastModified:Date.now()});s(n)}),e.type,t)},o.src=URL.createObjectURL(e)}))}}t.A=a},85817:function(){},18590:function(){},4530:function(){},8108:function(){},80551:function(){},41234:function(){},90679:function(e,t,n){"use strict";var r=n(1625),s=TypeError;e.exports=function(e,t){if(r(t,e))return e;throw new s("Incorrect invocation")}},55002:function(e){"use strict";e.exports={IndexSizeError:{s:"INDEX_SIZE_ERR",c:1,m:1},DOMStringSizeError:{s:"DOMSTRING_SIZE_ERR",c:2,m:0},HierarchyRequestError:{s:"HIERARCHY_REQUEST_ERR",c:3,m:1},WrongDocumentError:{s:"WRONG_DOCUMENT_ERR",c:4,m:1},InvalidCharacterError:{s:"INVALID_CHARACTER_ERR",c:5,m:1},NoDataAllowedError:{s:"NO_DATA_ALLOWED_ERR",c:6,m:0},NoModificationAllowedError:{s:"NO_MODIFICATION_ALLOWED_ERR",c:7,m:1},NotFoundError:{s:"NOT_FOUND_ERR",c:8,m:1},NotSupportedError:{s:"NOT_SUPPORTED_ERR",c:9,m:1},InUseAttributeError:{s:"INUSE_ATTRIBUTE_ERR",c:10,m:1},InvalidStateError:{s:"INVALID_STATE_ERR",c:11,m:1},SyntaxError:{s:"SYNTAX_ERR",c:12,m:1},InvalidModificationError:{s:"INVALID_MODIFICATION_ERR",c:13,m:1},NamespaceError:{s:"NAMESPACE_ERR",c:14,m:1},InvalidAccessError:{s:"INVALID_ACCESS_ERR",c:15,m:1},ValidationError:{s:"VALIDATION_ERR",c:16,m:0},TypeMismatchError:{s:"TYPE_MISMATCH_ERR",c:17,m:1},SecurityError:{s:"SECURITY_ERR",c:18,m:1},NetworkError:{s:"NETWORK_ERR",c:19,m:1},AbortError:{s:"ABORT_ERR",c:20,m:1},URLMismatchError:{s:"URL_MISMATCH_ERR",c:21,m:1},QuotaExceededError:{s:"QUOTA_EXCEEDED_ERR",c:22,m:1},TimeoutError:{s:"TIMEOUT_ERR",c:23,m:1},InvalidNodeTypeError:{s:"INVALID_NODE_TYPE_ERR",c:24,m:1},DataCloneError:{s:"DATA_CLONE_ERR",c:25,m:1}}},64979:function(e,t,n){"use strict";var r=n(46518),s=n(44576),a=n(97751),i=n(6980),o=n(24913).f,u=n(39297),l=n(90679),c=n(23167),h=n(32603),p=n(55002),d=n(16193),f=n(43724),m=n(96395),g="DOMException",y=a("Error"),b=a(g),x=function(){l(this,w);var e=arguments.length,t=h(e<1?void 0:arguments[0]),n=h(e<2?void 0:arguments[1],"Error"),r=new b(t,n),s=new y(t);return s.name=g,o(r,"stack",i(1,d(s.stack,1))),c(r,this,x),r},w=x.prototype=b.prototype,v="stack"in new y(g),k="stack"in new b(1,2),I=b&&f&&Object.getOwnPropertyDescriptor(s,g),N=!!I&&!(I.writable&&I.configurable),S=v&&!N&&!k;r({global:!0,constructor:!0,forced:m||S},{DOMException:S?x:b});var T=a(g),$=T.prototype;if($.constructor!==T)for(var C in m||o($,"constructor",i(1,T)),p)if(u(p,C)){var E=p[C],R=E.s;u(T,R)||o(T,R,i(6,E.c))}},91114:function(e,t,n){"use strict";function r(e){return r="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},r(e)}n.d(t,{A:function(){return i}});n(16280);function s(e,t){if("object"!=r(e)||!e)return e;var n=e[Symbol.toPrimitive];if(void 0!==n){var s=n.call(e,t||"default");if("object"!=r(s))return s;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===t?String:Number)(e)}function a(e){var t=s(e,"string");return"symbol"==r(t)?t:t+""}function i(e,t,n){return(t=a(t))in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}}}]);
//# sourceMappingURL=4647.72b494f7.js.map